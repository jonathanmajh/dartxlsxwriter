// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `libxlsxwriter`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class DartxlsxwriterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  DartxlsxwriterBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  DartxlsxwriterBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// INDENT-ON*
  ffi.Pointer<lxw_sst> lxw_sst_new() {
    return _lxw_sst_new();
  }

  late final _lxw_sst_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_sst> Function()>>(
          'lxw_sst_new');
  late final _lxw_sst_new =
      _lxw_sst_newPtr.asFunction<ffi.Pointer<lxw_sst> Function()>();

  void lxw_sst_free(
    ffi.Pointer<lxw_sst> sst,
  ) {
    return _lxw_sst_free(
      sst,
    );
  }

  late final _lxw_sst_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_sst>)>>(
          'lxw_sst_free');
  late final _lxw_sst_free =
      _lxw_sst_freePtr.asFunction<void Function(ffi.Pointer<lxw_sst>)>();

  ffi.Pointer<sst_element> lxw_get_sst_index(
    ffi.Pointer<lxw_sst> sst,
    ffi.Pointer<ffi.Char> string,
    int is_rich_string,
  ) {
    return _lxw_get_sst_index(
      sst,
      string,
      is_rich_string,
    );
  }

  late final _lxw_get_sst_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<sst_element> Function(ffi.Pointer<lxw_sst>,
              ffi.Pointer<ffi.Char>, ffi.Uint8)>>('lxw_get_sst_index');
  late final _lxw_get_sst_index = _lxw_get_sst_indexPtr.asFunction<
      ffi.Pointer<sst_element> Function(
          ffi.Pointer<lxw_sst>, ffi.Pointer<ffi.Char>, int)>();

  void lxw_sst_assemble_xml_file(
    ffi.Pointer<lxw_sst> self,
  ) {
    return _lxw_sst_assemble_xml_file(
      self,
    );
  }

  late final _lxw_sst_assemble_xml_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_sst>)>>(
          'lxw_sst_assemble_xml_file');
  late final _lxw_sst_assemble_xml_file = _lxw_sst_assemble_xml_filePtr
      .asFunction<void Function(ffi.Pointer<lxw_sst>)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_hash_element> lxw_hash_key_exists(
    ffi.Pointer<lxw_hash_table> lxw_hash,
    ffi.Pointer<ffi.Void> key,
    int key_len,
  ) {
    return _lxw_hash_key_exists(
      lxw_hash,
      key,
      key_len,
    );
  }

  late final _lxw_hash_key_existsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_hash_element> Function(ffi.Pointer<lxw_hash_table>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('lxw_hash_key_exists');
  late final _lxw_hash_key_exists = _lxw_hash_key_existsPtr.asFunction<
      ffi.Pointer<lxw_hash_element> Function(
          ffi.Pointer<lxw_hash_table>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<lxw_hash_element> lxw_insert_hash_element(
    ffi.Pointer<lxw_hash_table> lxw_hash,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
    int key_len,
  ) {
    return _lxw_insert_hash_element(
      lxw_hash,
      key,
      value,
      key_len,
    );
  }

  late final _lxw_insert_hash_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_hash_element> Function(
              ffi.Pointer<lxw_hash_table>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('lxw_insert_hash_element');
  late final _lxw_insert_hash_element = _lxw_insert_hash_elementPtr.asFunction<
      ffi.Pointer<lxw_hash_element> Function(ffi.Pointer<lxw_hash_table>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<lxw_hash_table> lxw_hash_new(
    int num_buckets,
    int free_key,
    int free_value,
  ) {
    return _lxw_hash_new(
      num_buckets,
      free_key,
      free_value,
    );
  }

  late final _lxw_hash_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_hash_table> Function(
              ffi.Uint32, ffi.Uint8, ffi.Uint8)>>('lxw_hash_new');
  late final _lxw_hash_new = _lxw_hash_newPtr
      .asFunction<ffi.Pointer<lxw_hash_table> Function(int, int, int)>();

  void lxw_hash_free(
    ffi.Pointer<lxw_hash_table> lxw_hash,
  ) {
    return _lxw_hash_free(
      lxw_hash,
    );
  }

  late final _lxw_hash_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_hash_table>)>>(
      'lxw_hash_free');
  late final _lxw_hash_free = _lxw_hash_freePtr
      .asFunction<void Function(ffi.Pointer<lxw_hash_table>)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_format> lxw_format_new() {
    return _lxw_format_new();
  }

  late final _lxw_format_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_format> Function()>>(
          'lxw_format_new');
  late final _lxw_format_new =
      _lxw_format_newPtr.asFunction<ffi.Pointer<lxw_format> Function()>();

  void lxw_format_free(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_free(
      format,
    );
  }

  late final _lxw_format_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'lxw_format_free');
  late final _lxw_format_free =
      _lxw_format_freePtr.asFunction<void Function(ffi.Pointer<lxw_format>)>();

  int lxw_format_get_xf_index(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_get_xf_index(
      format,
    );
  }

  late final _lxw_format_get_xf_indexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<lxw_format>)>>(
          'lxw_format_get_xf_index');
  late final _lxw_format_get_xf_index = _lxw_format_get_xf_indexPtr
      .asFunction<int Function(ffi.Pointer<lxw_format>)>();

  int lxw_format_get_dxf_index(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_get_dxf_index(
      format,
    );
  }

  late final _lxw_format_get_dxf_indexPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<lxw_format>)>>(
          'lxw_format_get_dxf_index');
  late final _lxw_format_get_dxf_index = _lxw_format_get_dxf_indexPtr
      .asFunction<int Function(ffi.Pointer<lxw_format>)>();

  ffi.Pointer<lxw_font> lxw_format_get_font_key(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_get_font_key(
      format,
    );
  }

  late final _lxw_format_get_font_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_font> Function(
              ffi.Pointer<lxw_format>)>>('lxw_format_get_font_key');
  late final _lxw_format_get_font_key = _lxw_format_get_font_keyPtr
      .asFunction<ffi.Pointer<lxw_font> Function(ffi.Pointer<lxw_format>)>();

  ffi.Pointer<lxw_border> lxw_format_get_border_key(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_get_border_key(
      format,
    );
  }

  late final _lxw_format_get_border_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_border> Function(
              ffi.Pointer<lxw_format>)>>('lxw_format_get_border_key');
  late final _lxw_format_get_border_key = _lxw_format_get_border_keyPtr
      .asFunction<ffi.Pointer<lxw_border> Function(ffi.Pointer<lxw_format>)>();

  ffi.Pointer<lxw_fill> lxw_format_get_fill_key(
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_format_get_fill_key(
      format,
    );
  }

  late final _lxw_format_get_fill_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_fill> Function(
              ffi.Pointer<lxw_format>)>>('lxw_format_get_fill_key');
  late final _lxw_format_get_fill_key = _lxw_format_get_fill_keyPtr
      .asFunction<ffi.Pointer<lxw_fill> Function(ffi.Pointer<lxw_format>)>();

  /// @brief Set the font used in the cell.
  ///
  /// @param format    Pointer to a Format instance.
  /// @param font_name Cell font name.
  ///
  /// Specify the font used used in the cell format:
  ///
  /// @code
  /// format_set_font_name(format, "Avenir Black Oblique");
  /// @endcode
  ///
  /// @image html format_set_font_name.png
  ///
  /// Excel can only display fonts that are installed on the system that it is
  /// running on. Therefore it is generally best to use the fonts that come as
  /// standard with Excel such as Calibri, Times New Roman and Courier New.
  ///
  /// The default font in Excel 2007, and later, is Calibri.
  void format_set_font_name(
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<ffi.Char> font_name,
  ) {
    return _format_set_font_name(
      format,
      font_name,
    );
  }

  late final _format_set_font_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>)>>('format_set_font_name');
  late final _format_set_font_name = _format_set_font_namePtr.asFunction<
      void Function(ffi.Pointer<lxw_format>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the size of the font used in the cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param size   The cell font size.
  ///
  /// Set the font size of the cell format:
  ///
  /// @code
  /// format_set_font_size(format, 30);
  /// @endcode
  ///
  /// @image html format_font_size.png
  ///
  /// Excel adjusts the height of a row to accommodate the largest font
  /// size in the row. You can also explicitly specify the height of a
  /// row using the worksheet_set_row() function.
  void format_set_font_size(
    ffi.Pointer<lxw_format> format,
    double size,
  ) {
    return _format_set_font_size(
      format,
      size,
    );
  }

  late final _format_set_font_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Double)>>('format_set_font_size');
  late final _format_set_font_size = _format_set_font_sizePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, double)>();

  /// @brief Set the color of the font used in the cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell font color.
  ///
  ///
  /// Set the font color:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_font_color(format, LXW_COLOR_RED);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Wheelbarrow", format);
  /// @endcode
  ///
  /// @image html format_font_color.png
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  ///
  /// @note
  /// The format_set_font_color() method is used to set the font color in a
  /// cell. To set the color of a cell background use the format_set_bg_color()
  /// and format_set_pattern() methods.
  void format_set_font_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_font_color(
      format,
      color,
    );
  }

  late final _format_set_font_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_font_color');
  late final _format_set_font_color = _format_set_font_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Turn on bold for the format font.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// Set the bold property of the font:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_bold(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Bold Text", format);
  /// @endcode
  ///
  /// @image html format_font_bold.png
  void format_set_bold(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_bold(
      format,
    );
  }

  late final _format_set_boldPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_bold');
  late final _format_set_bold =
      _format_set_boldPtr.asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Turn on italic for the format font.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// Set the italic property of the font:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_italic(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Italic Text", format);
  /// @endcode
  ///
  /// @image html format_font_italic.png
  void format_set_italic(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_italic(
      format,
    );
  }

  late final _format_set_italicPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_italic');
  late final _format_set_italic = _format_set_italicPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Turn on underline for the format:
  ///
  /// @param format Pointer to a Format instance.
  /// @param style Underline style.
  ///
  /// Set the underline property of the format:
  ///
  /// @code
  /// format_set_underline(format, LXW_UNDERLINE_SINGLE);
  /// @endcode
  ///
  /// @image html format_font_underlined.png
  ///
  /// The available underline styles are:
  ///
  /// - #LXW_UNDERLINE_SINGLE
  /// - #LXW_UNDERLINE_DOUBLE
  /// - #LXW_UNDERLINE_SINGLE_ACCOUNTING
  /// - #LXW_UNDERLINE_DOUBLE_ACCOUNTING
  void format_set_underline(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_underline(
      format,
      style,
    );
  }

  late final _format_set_underlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_underline');
  late final _format_set_underline = _format_set_underlinePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the strikeout property of the font.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// @image html format_font_strikeout.png
  void format_set_font_strikeout(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_strikeout(
      format,
    );
  }

  late final _format_set_font_strikeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_strikeout');
  late final _format_set_font_strikeout = _format_set_font_strikeoutPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Set the superscript/subscript property of the font.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Superscript or subscript style.
  ///
  /// Set the superscript o subscript property of the font.
  ///
  /// @image html format_font_script.png
  ///
  /// The available script styles are:
  ///
  /// - #LXW_FONT_SUPERSCRIPT
  /// - #LXW_FONT_SUBSCRIPT
  void format_set_font_script(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_font_script(
      format,
      style,
    );
  }

  late final _format_set_font_scriptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_font_script');
  late final _format_set_font_script = _format_set_font_scriptPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the number format for a cell.
  ///
  /// @param format      Pointer to a Format instance.
  /// @param num_format The cell number format string.
  ///
  /// This method is used to define the numerical format of a number in
  /// Excel. It controls whether a number is displayed as an integer, a
  /// floating point number, a date, a currency value or some other user
  /// defined format.
  ///
  /// The numerical format of a cell can be specified by using a format
  /// string:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_num_format(format, "d mmm yyyy");
  /// @endcode
  ///
  /// Format strings can control any aspect of number formatting allowed by Excel:
  ///
  /// @dontinclude format_num_format.c
  /// @skipline set_num_format
  /// @until 1209
  ///
  /// @image html format_set_num_format.png
  ///
  /// To set a number format that matches an Excel format category such as "Date"
  /// or "Currency" see @ref ww_formats_categories.
  ///
  /// The number system used for dates is described in @ref working_with_dates.
  ///
  /// For more information on number formats in Excel refer to the
  /// [Microsoft documentation on cell formats](http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx).
  void format_set_num_format(
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<ffi.Char> num_format,
  ) {
    return _format_set_num_format(
      format,
      num_format,
    );
  }

  late final _format_set_num_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>)>>('format_set_num_format');
  late final _format_set_num_format = _format_set_num_formatPtr.asFunction<
      void Function(ffi.Pointer<lxw_format>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the Excel built-in number format for a cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param index  The built-in number format index for the cell.
  ///
  /// This function is similar to format_set_num_format() except that it takes an
  /// index to a limited number of Excel's built-in number formats instead of a
  /// user defined format string:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_num_format_index(format, 0x0F); // d-mmm-yy
  /// @endcode
  ///
  /// @note
  /// Unless you need to specifically access one of Excel's built-in number
  /// formats the format_set_num_format() function above is a better
  /// solution. The format_set_num_format_index() function is mainly included for
  /// backward compatibility and completeness.
  ///
  /// The Excel built-in number formats as shown in the table below:
  ///
  /// | Index | Index | Format String                                        |
  /// | ----- | ----- | ---------------------------------------------------- |
  /// | 0     | 0x00  | `General`                                            |
  /// | 1     | 0x01  | `0`                                                  |
  /// | 2     | 0x02  | `0.00`                                               |
  /// | 3     | 0x03  | `#,##0`                                              |
  /// | 4     | 0x04  | `#,##0.00`                                           |
  /// | 5     | 0x05  | `($#,##0_);($#,##0)`                                 |
  /// | 6     | 0x06  | `($#,##0_);[Red]($#,##0)`                            |
  /// | 7     | 0x07  | `($#,##0.00_);($#,##0.00)`                           |
  /// | 8     | 0x08  | `($#,##0.00_);[Red]($#,##0.00)`                      |
  /// | 9     | 0x09  | `0%`                                                 |
  /// | 10    | 0x0a  | `0.00%`                                              |
  /// | 11    | 0x0b  | `0.00E+00`                                           |
  /// | 12    | 0x0c  | `# ?/?`                                              |
  /// | 13    | 0x0d  | `# ??/??`                                            |
  /// | 14    | 0x0e  | `m/d/yy`                                             |
  /// | 15    | 0x0f  | `d-mmm-yy`                                           |
  /// | 16    | 0x10  | `d-mmm`                                              |
  /// | 17    | 0x11  | `mmm-yy`                                             |
  /// | 18    | 0x12  | `h:mm AM/PM`                                         |
  /// | 19    | 0x13  | `h:mm:ss AM/PM`                                      |
  /// | 20    | 0x14  | `h:mm`                                               |
  /// | 21    | 0x15  | `h:mm:ss`                                            |
  /// | 22    | 0x16  | `m/d/yy h:mm`                                        |
  /// | ...   | ...   | ...                                                  |
  /// | 37    | 0x25  | `(#,##0_);(#,##0)`                                   |
  /// | 38    | 0x26  | `(#,##0_);[Red](#,##0)`                              |
  /// | 39    | 0x27  | `(#,##0.00_);(#,##0.00)`                             |
  /// | 40    | 0x28  | `(#,##0.00_);[Red](#,##0.00)`                        |
  /// | 41    | 0x29  | `_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)`            |
  /// | 42    | 0x2a  | `_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)`         |
  /// | 43    | 0x2b  | `_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)`    |
  /// | 44    | 0x2c  | `_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)` |
  /// | 45    | 0x2d  | `mm:ss`                                              |
  /// | 46    | 0x2e  | `[h]:mm:ss`                                          |
  /// | 47    | 0x2f  | `mm:ss.0`                                            |
  /// | 48    | 0x30  | `##0.0E+0`                                           |
  /// | 49    | 0x31  | `@`                                                  |
  ///
  /// @note
  /// -  Numeric formats 23 to 36 are not documented by Microsoft and may differ
  /// in international versions. The listed date and currency formats may also
  /// vary depending on system settings.
  /// - The dollar sign in the above format appears as the defined local currency
  /// symbol.
  /// - These formats can also be set via format_set_num_format().
  /// - See also @ref ww_formats_categories.
  void format_set_num_format_index(
    ffi.Pointer<lxw_format> format,
    int index,
  ) {
    return _format_set_num_format_index(
      format,
      index,
    );
  }

  late final _format_set_num_format_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              ffi.Uint8)>>('format_set_num_format_index');
  late final _format_set_num_format_index = _format_set_num_format_indexPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell unlocked state.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// This property can be used to allow modification of a cell in a protected
  /// worksheet. In Excel, cell locking is turned on by default for all
  /// cells. However, it only has an effect if the worksheet has been protected
  /// using the worksheet worksheet_protect() function:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_unlocked(format);
  ///
  /// // Enable worksheet protection, without password or options.
  /// worksheet_protect(worksheet, NULL, NULL);
  ///
  /// // This cell cannot be edited.
  /// worksheet_write_formula(worksheet, 0, 0, "=1+2", NULL);
  ///
  /// // This cell can be edited.
  /// worksheet_write_formula(worksheet, 1, 0, "=1+2", format);
  /// @endcode
  void format_set_unlocked(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_unlocked(
      format,
    );
  }

  late final _format_set_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_unlocked');
  late final _format_set_unlocked = _format_set_unlockedPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Hide formulas in a cell.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// This property is used to hide a formula while still displaying its
  /// result. This is generally used to hide complex calculations from end users
  /// who are only interested in the result. It only has an effect if the
  /// worksheet has been protected using the worksheet worksheet_protect()
  /// function:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_hidden(format);
  ///
  /// // Enable worksheet protection, without password or options.
  /// worksheet_protect(worksheet, NULL, NULL);
  ///
  /// // The formula in this cell isn't visible.
  /// worksheet_write_formula(worksheet, 0, 0, "=1+2", format);
  /// @endcode
  void format_set_hidden(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_hidden(
      format,
    );
  }

  late final _format_set_hiddenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_hidden');
  late final _format_set_hidden = _format_set_hiddenPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Set the alignment for data in the cell.
  ///
  /// @param format    Pointer to a Format instance.
  /// @param alignment The horizontal and or vertical alignment direction.
  ///
  /// This method is used to set the horizontal and vertical text alignment within a
  /// cell. The following are the available horizontal alignments:
  ///
  /// - #LXW_ALIGN_LEFT
  /// - #LXW_ALIGN_CENTER
  /// - #LXW_ALIGN_RIGHT
  /// - #LXW_ALIGN_FILL
  /// - #LXW_ALIGN_JUSTIFY
  /// - #LXW_ALIGN_CENTER_ACROSS
  /// - #LXW_ALIGN_DISTRIBUTED
  ///
  /// The following are the available vertical alignments:
  ///
  /// - #LXW_ALIGN_VERTICAL_TOP
  /// - #LXW_ALIGN_VERTICAL_BOTTOM
  /// - #LXW_ALIGN_VERTICAL_CENTER
  /// - #LXW_ALIGN_VERTICAL_JUSTIFY
  /// - #LXW_ALIGN_VERTICAL_DISTRIBUTED
  ///
  /// As in Excel, vertical and horizontal alignments can be combined:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  ///
  /// format_set_align(format, LXW_ALIGN_CENTER);
  /// format_set_align(format, LXW_ALIGN_VERTICAL_CENTER);
  ///
  /// worksheet_set_row(0, 30);
  /// worksheet_write_string(worksheet, 0, 0, "Some Text", format);
  /// @endcode
  ///
  /// @image html format_font_align.png
  ///
  /// Text can be aligned across two or more adjacent cells using the
  /// center_across property. However, for genuine merged cells it is better to
  /// use the worksheet_merge_range() worksheet method.
  ///
  /// The vertical justify option can be used to provide automatic text wrapping
  /// in a cell. The height of the cell will be adjusted to accommodate the
  /// wrapped text. To specify where the text wraps use the
  /// format_set_text_wrap() method.
  void format_set_align(
    ffi.Pointer<lxw_format> format,
    int alignment,
  ) {
    return _format_set_align(
      format,
      alignment,
    );
  }

  late final _format_set_alignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_align');
  late final _format_set_align = _format_set_alignPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Wrap text in a cell.
  ///
  /// Turn text wrapping on for text in a cell.
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_text_wrap(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Some long text to wrap in a cell", format);
  /// @endcode
  ///
  /// If you wish to control where the text is wrapped you can add newline characters
  /// to the string:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_text_wrap(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "It's\na bum\nwrap", format);
  /// @endcode
  ///
  /// @image html format_font_text_wrap.png
  ///
  /// Excel will adjust the height of the row to accommodate the wrapped text. A
  /// similar effect can be obtained without newlines using the
  /// format_set_align() function with #LXW_ALIGN_VERTICAL_JUSTIFY.
  void format_set_text_wrap(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_text_wrap(
      format,
    );
  }

  late final _format_set_text_wrapPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_text_wrap');
  late final _format_set_text_wrap = _format_set_text_wrapPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Set the rotation of the text in a cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param angle  Rotation angle in the range -90 to 90 and 270.
  ///
  /// Set the rotation of the text in a cell. The rotation can be any angle in the
  /// range -90 to 90 degrees:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_rotation(format, 30);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "This text is rotated", format);
  /// @endcode
  ///
  /// @image html format_font_text_rotated.png
  ///
  /// The angle 270 is also supported. This indicates text where the letters run from
  /// top to bottom.
  void format_set_rotation(
    ffi.Pointer<lxw_format> format,
    int angle,
  ) {
    return _format_set_rotation(
      format,
      angle,
    );
  }

  late final _format_set_rotationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Int16)>>('format_set_rotation');
  late final _format_set_rotation = _format_set_rotationPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell text indentation level.
  ///
  /// @param format Pointer to a Format instance.
  /// @param level  Indentation level.
  ///
  /// This method can be used to indent text in a cell. The argument, which should be
  /// an integer, is taken as the level of indentation:
  ///
  /// @code
  /// format1 = workbook_add_format(workbook);
  /// format2 = workbook_add_format(workbook);
  ///
  /// format_set_indent(format1, 1);
  /// format_set_indent(format2, 2);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "This text is indented 1 level",  format1);
  /// worksheet_write_string(worksheet, 1, 0, "This text is indented 2 levels", format2);
  /// @endcode
  ///
  /// @image html text_indent.png
  ///
  /// @note
  /// Indentation is a horizontal alignment property. It will override any other
  /// horizontal properties but it can be used in conjunction with vertical
  /// properties.
  void format_set_indent(
    ffi.Pointer<lxw_format> format,
    int level,
  ) {
    return _format_set_indent(
      format,
      level,
    );
  }

  late final _format_set_indentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_indent');
  late final _format_set_indent = _format_set_indentPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Turn on the text "shrink to fit" for a cell.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// This method can be used to shrink text so that it fits in a cell:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_shrink(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Honey, I shrunk the text!", format);
  /// @endcode
  void format_set_shrink(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_shrink(
      format,
    );
  }

  late final _format_set_shrinkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_shrink');
  late final _format_set_shrink = _format_set_shrinkPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// @brief Set the background fill pattern for a cell
  ///
  /// @param format Pointer to a Format instance.
  /// @param index  Pattern index.
  ///
  /// Set the background pattern for a cell.
  ///
  /// The most common pattern is a solid fill of the background color:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  ///
  /// format_set_pattern (format, LXW_PATTERN_SOLID);
  /// format_set_bg_color(format, LXW_COLOR_YELLOW);
  /// @endcode
  ///
  /// The available fill patterns are:
  ///
  /// Fill Type                     | Define
  /// ----------------------------- | -----------------------------
  /// Solid                         | #LXW_PATTERN_SOLID
  /// Medium gray                   | #LXW_PATTERN_MEDIUM_GRAY
  /// Dark gray                     | #LXW_PATTERN_DARK_GRAY
  /// Light gray                    | #LXW_PATTERN_LIGHT_GRAY
  /// Dark horizontal line          | #LXW_PATTERN_DARK_HORIZONTAL
  /// Dark vertical line            | #LXW_PATTERN_DARK_VERTICAL
  /// Dark diagonal stripe          | #LXW_PATTERN_DARK_DOWN
  /// Reverse dark diagonal stripe  | #LXW_PATTERN_DARK_UP
  /// Dark grid                     | #LXW_PATTERN_DARK_GRID
  /// Dark trellis                  | #LXW_PATTERN_DARK_TRELLIS
  /// Light horizontal line         | #LXW_PATTERN_LIGHT_HORIZONTAL
  /// Light vertical line           | #LXW_PATTERN_LIGHT_VERTICAL
  /// Light diagonal stripe         | #LXW_PATTERN_LIGHT_DOWN
  /// Reverse light diagonal stripe | #LXW_PATTERN_LIGHT_UP
  /// Light grid                    | #LXW_PATTERN_LIGHT_GRID
  /// Light trellis                 | #LXW_PATTERN_LIGHT_TRELLIS
  /// 12.5% gray                    | #LXW_PATTERN_GRAY_125
  /// 6.25% gray                    | #LXW_PATTERN_GRAY_0625
  void format_set_pattern(
    ffi.Pointer<lxw_format> format,
    int index,
  ) {
    return _format_set_pattern(
      format,
      index,
    );
  }

  late final _format_set_patternPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_pattern');
  late final _format_set_pattern = _format_set_patternPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the pattern background color for a cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell pattern background color.
  ///
  /// The format_set_bg_color() method can be used to set the background color of
  /// a pattern. Patterns are defined via the format_set_pattern() method. If a
  /// pattern hasn't been defined then a solid fill pattern is used as the
  /// default.
  ///
  /// Here is an example of how to set up a solid fill in a cell:
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  ///
  /// format_set_pattern (format, LXW_PATTERN_SOLID);
  /// format_set_bg_color(format, LXW_COLOR_GREEN);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "Ray", format);
  /// @endcode
  ///
  /// @image html formats_set_bg_color.png
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  void format_set_bg_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_bg_color(
      format,
      color,
    );
  }

  late final _format_set_bg_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_bg_color');
  late final _format_set_bg_color = _format_set_bg_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the pattern foreground color for a cell.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell pattern foreground  color.
  ///
  /// The format_set_fg_color() method can be used to set the foreground color of
  /// a pattern.
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  void format_set_fg_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_fg_color(
      format,
      color,
    );
  }

  late final _format_set_fg_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_fg_color');
  late final _format_set_fg_color = _format_set_fg_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Border style index.
  ///
  /// Set the cell border style:
  ///
  /// @code
  /// format_set_border(format, LXW_BORDER_THIN);
  /// @endcode
  ///
  /// Individual border elements can be configured using the following functions with
  /// the same parameters:
  ///
  /// - format_set_bottom()
  /// - format_set_top()
  /// - format_set_left()
  /// - format_set_right()
  ///
  /// A cell border is comprised of a border on the bottom, top, left and right.
  /// These can be set to the same value using format_set_border() or
  /// individually using the relevant method calls shown above.
  ///
  /// The following border styles are available:
  ///
  /// - #LXW_BORDER_THIN
  /// - #LXW_BORDER_MEDIUM
  /// - #LXW_BORDER_DASHED
  /// - #LXW_BORDER_DOTTED
  /// - #LXW_BORDER_THICK
  /// - #LXW_BORDER_DOUBLE
  /// - #LXW_BORDER_HAIR
  /// - #LXW_BORDER_MEDIUM_DASHED
  /// - #LXW_BORDER_DASH_DOT
  /// - #LXW_BORDER_MEDIUM_DASH_DOT
  /// - #LXW_BORDER_DASH_DOT_DOT
  /// - #LXW_BORDER_MEDIUM_DASH_DOT_DOT
  /// - #LXW_BORDER_SLANT_DASH_DOT
  ///
  /// The most commonly used style is the `thin` style.
  void format_set_border(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_border(
      format,
      style,
    );
  }

  late final _format_set_borderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_border');
  late final _format_set_border = _format_set_borderPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell bottom border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Border style index.
  ///
  /// Set the cell bottom border style. See format_set_border() for details on the
  /// border styles.
  void format_set_bottom(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_bottom(
      format,
      style,
    );
  }

  late final _format_set_bottomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_bottom');
  late final _format_set_bottom = _format_set_bottomPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell top border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Border style index.
  ///
  /// Set the cell top border style. See format_set_border() for details on the border
  /// styles.
  void format_set_top(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_top(
      format,
      style,
    );
  }

  late final _format_set_topPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_top');
  late final _format_set_top = _format_set_topPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell left border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Border style index.
  ///
  /// Set the cell left border style. See format_set_border() for details on the
  /// border styles.
  void format_set_left(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_left(
      format,
      style,
    );
  }

  late final _format_set_leftPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_left');
  late final _format_set_left = _format_set_leftPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the cell right border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  Border style index.
  ///
  /// Set the cell right border style. See format_set_border() for details on the
  /// border styles.
  void format_set_right(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_right(
      format,
      style,
    );
  }

  late final _format_set_rightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_right');
  late final _format_set_right = _format_set_rightPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the color of the cell border.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell border color.
  ///
  /// Individual border elements can be configured using the following methods with
  /// the same parameters:
  ///
  /// - format_set_bottom_color()
  /// - format_set_top_color()
  /// - format_set_left_color()
  /// - format_set_right_color()
  ///
  /// Set the color of the cell borders. A cell border is comprised of a border
  /// on the bottom, top, left and right. These can be set to the same color
  /// using format_set_border_color() or individually using the relevant method
  /// calls shown above.
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  void format_set_border_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_border_color(
      format,
      color,
    );
  }

  late final _format_set_border_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              lxw_color_t)>>('format_set_border_color');
  late final _format_set_border_color = _format_set_border_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the color of the bottom cell border.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell border color.
  ///
  /// See format_set_border_color() for details on the border colors.
  void format_set_bottom_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_bottom_color(
      format,
      color,
    );
  }

  late final _format_set_bottom_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              lxw_color_t)>>('format_set_bottom_color');
  late final _format_set_bottom_color = _format_set_bottom_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the color of the top cell border.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell border color.
  ///
  /// See format_set_border_color() for details on the border colors.
  void format_set_top_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_top_color(
      format,
      color,
    );
  }

  late final _format_set_top_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_top_color');
  late final _format_set_top_color = _format_set_top_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the color of the left cell border.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell border color.
  ///
  /// See format_set_border_color() for details on the border colors.
  void format_set_left_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_left_color(
      format,
      color,
    );
  }

  late final _format_set_left_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_left_color');
  late final _format_set_left_color = _format_set_left_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the color of the right cell border.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell border color.
  ///
  /// See format_set_border_color() for details on the border colors.
  void format_set_right_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_right_color(
      format,
      color,
    );
  }

  late final _format_set_right_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_right_color');
  late final _format_set_right_color = _format_set_right_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the diagonal cell border type.
  ///
  /// @param format Pointer to a Format instance.
  /// @param type   The #lxw_format_diagonal_types diagonal border type.
  ///
  /// Set the diagonal cell border type:
  ///
  /// @code
  /// lxw_format *format1 = workbook_add_format(workbook);
  /// format_set_diag_type(  format1, LXW_DIAGONAL_BORDER_UP);
  ///
  /// lxw_format *format2 = workbook_add_format(workbook);
  /// format_set_diag_type(  format2, LXW_DIAGONAL_BORDER_DOWN);
  ///
  /// lxw_format *format3 = workbook_add_format(workbook);
  /// format_set_diag_type(  format3, LXW_DIAGONAL_BORDER_UP_DOWN);
  ///
  /// lxw_format *format4 = workbook_add_format(workbook);
  /// format_set_diag_type(  format4, LXW_DIAGONAL_BORDER_UP_DOWN);
  /// format_set_diag_border(format4, LXW_BORDER_HAIR);
  /// format_set_diag_color( format4, LXW_COLOR_RED);
  ///
  /// worksheet_write_string(worksheet, CELL("B3"),  "Text", format1);
  /// worksheet_write_string(worksheet, CELL("B6"),  "Text", format2);
  /// worksheet_write_string(worksheet, CELL("B9"),  "Text", format3);
  /// worksheet_write_string(worksheet, CELL("B12"), "Text", format4);
  /// @endcode
  ///
  /// @image html diagonal_border.png
  ///
  /// The allowable border types are defined in #lxw_format_diagonal_types:
  ///
  /// - #LXW_DIAGONAL_BORDER_UP: Cell diagonal border from bottom left to top
  /// right.
  ///
  /// - #LXW_DIAGONAL_BORDER_DOWN: Cell diagonal border from top left to bottom
  /// right.
  ///
  /// - #LXW_DIAGONAL_BORDER_UP_DOWN: Cell diagonal border from top left to
  /// bottom right. A combination of the 2 previous types.
  ///
  /// If the border style isn't specified with `format_set_diag_border()` then it
  /// will default to #LXW_BORDER_THIN.
  void format_set_diag_type(
    ffi.Pointer<lxw_format> format,
    int type,
  ) {
    return _format_set_diag_type(
      format,
      type,
    );
  }

  late final _format_set_diag_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_diag_type');
  late final _format_set_diag_type = _format_set_diag_typePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the diagonal cell border style.
  ///
  /// @param format Pointer to a Format instance.
  /// @param style  The #lxw_format_borders style.
  ///
  /// Set the diagonal border style. This should be a #lxw_format_borders value.
  /// See the example above.
  void format_set_diag_border(
    ffi.Pointer<lxw_format> format,
    int style,
  ) {
    return _format_set_diag_border(
      format,
      style,
    );
  }

  late final _format_set_diag_borderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_diag_border');
  late final _format_set_diag_border = _format_set_diag_borderPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Set the diagonal cell border color.
  ///
  /// @param format Pointer to a Format instance.
  /// @param color  The cell diagonal border color.
  ///
  /// Set the diagonal border color. The color should be an RGB integer value,
  /// see @ref working_with_colors and the above example.
  void format_set_diag_color(
    ffi.Pointer<lxw_format> format,
    int color,
  ) {
    return _format_set_diag_color(
      format,
      color,
    );
  }

  late final _format_set_diag_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, lxw_color_t)>>('format_set_diag_color');
  late final _format_set_diag_color = _format_set_diag_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  /// @brief Turn on quote prefix for the format.
  ///
  /// @param format Pointer to a Format instance.
  ///
  /// Set the quote prefix property of a format to ensure a string is treated
  /// as a string after editing. This is the same as prefixing the string with
  /// a single quote in Excel. You don't need to add the quote to the
  /// string but you do need to add the format.
  ///
  /// @code
  /// format = workbook_add_format(workbook);
  /// format_set_quote_prefix(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "=Foo", format);
  /// @endcode
  void format_set_quote_prefix(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_quote_prefix(
      format,
    );
  }

  late final _format_set_quote_prefixPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_quote_prefix');
  late final _format_set_quote_prefix = _format_set_quote_prefixPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_font_outline(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_outline(
      format,
    );
  }

  late final _format_set_font_outlinePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_outline');
  late final _format_set_font_outline = _format_set_font_outlinePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_font_shadow(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_shadow(
      format,
    );
  }

  late final _format_set_font_shadowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_shadow');
  late final _format_set_font_shadow = _format_set_font_shadowPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_font_family(
    ffi.Pointer<lxw_format> format,
    int value,
  ) {
    return _format_set_font_family(
      format,
      value,
    );
  }

  late final _format_set_font_familyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_font_family');
  late final _format_set_font_family = _format_set_font_familyPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  void format_set_font_charset(
    ffi.Pointer<lxw_format> format,
    int value,
  ) {
    return _format_set_font_charset(
      format,
      value,
    );
  }

  late final _format_set_font_charsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_font_charset');
  late final _format_set_font_charset = _format_set_font_charsetPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  void format_set_font_scheme(
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<ffi.Char> font_scheme,
  ) {
    return _format_set_font_scheme(
      format,
      font_scheme,
    );
  }

  late final _format_set_font_schemePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>)>>('format_set_font_scheme');
  late final _format_set_font_scheme = _format_set_font_schemePtr.asFunction<
      void Function(ffi.Pointer<lxw_format>, ffi.Pointer<ffi.Char>)>();

  void format_set_font_condense(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_condense(
      format,
    );
  }

  late final _format_set_font_condensePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_condense');
  late final _format_set_font_condense = _format_set_font_condensePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_font_extend(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_extend(
      format,
    );
  }

  late final _format_set_font_extendPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_extend');
  late final _format_set_font_extend = _format_set_font_extendPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_reading_order(
    ffi.Pointer<lxw_format> format,
    int value,
  ) {
    return _format_set_reading_order(
      format,
      value,
    );
  }

  late final _format_set_reading_orderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_reading_order');
  late final _format_set_reading_order = _format_set_reading_orderPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  void format_set_theme(
    ffi.Pointer<lxw_format> format,
    int value,
  ) {
    return _format_set_theme(
      format,
      value,
    );
  }

  late final _format_set_themePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_theme');
  late final _format_set_theme = _format_set_themePtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  void format_set_hyperlink(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_hyperlink(
      format,
    );
  }

  late final _format_set_hyperlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_hyperlink');
  late final _format_set_hyperlink = _format_set_hyperlinkPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  void format_set_color_indexed(
    ffi.Pointer<lxw_format> format,
    int value,
  ) {
    return _format_set_color_indexed(
      format,
      value,
    );
  }

  late final _format_set_color_indexedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_format>, ffi.Uint8)>>('format_set_color_indexed');
  late final _format_set_color_indexed = _format_set_color_indexedPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>, int)>();

  void format_set_font_only(
    ffi.Pointer<lxw_format> format,
  ) {
    return _format_set_font_only(
      format,
    );
  }

  late final _format_set_font_onlyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_format>)>>(
          'format_set_font_only');
  late final _format_set_font_only = _format_set_font_onlyPtr
      .asFunction<void Function(ffi.Pointer<lxw_format>)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_chart> lxw_chart_new(
    int type,
  ) {
    return _lxw_chart_new(
      type,
    );
  }

  late final _lxw_chart_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_chart> Function(ffi.Uint8)>>(
          'lxw_chart_new');
  late final _lxw_chart_new =
      _lxw_chart_newPtr.asFunction<ffi.Pointer<lxw_chart> Function(int)>();

  void lxw_chart_free(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _lxw_chart_free(
      chart,
    );
  }

  late final _lxw_chart_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'lxw_chart_free');
  late final _lxw_chart_free =
      _lxw_chart_freePtr.asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  void lxw_chart_assemble_xml_file(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _lxw_chart_assemble_xml_file(
      chart,
    );
  }

  late final _lxw_chart_assemble_xml_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'lxw_chart_assemble_xml_file');
  late final _lxw_chart_assemble_xml_file = _lxw_chart_assemble_xml_filePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  /// @brief Add a data series to a chart.
  ///
  /// @param chart      Pointer to a lxw_chart instance to be configured.
  /// @param categories The range of categories in the data series.
  /// @param values     The range of values in the data series.
  ///
  /// @return A lxw_chart_series object pointer.
  ///
  /// In Excel a chart **series** is a collection of information that defines
  /// which data is plotted such as the categories and values. It is also used to
  /// define the formatting for the data.
  ///
  /// For an libxlsxwriter chart object the `%chart_add_series()` function is
  /// used to set the categories and values of the series:
  ///
  /// @code
  /// chart_add_series(chart, "=Sheet1!$A$2:$A$7", "=Sheet1!$C$2:$C$7");
  /// @endcode
  ///
  ///
  /// The series parameters are:
  ///
  /// - `categories`: This sets the chart category labels. The category is more
  /// or less the same as the X axis. In most Excel chart types the
  /// `categories` property is optional and the chart will just assume a
  /// sequential series from `1..n`:
  ///
  /// @code
  /// // The NULL category will default to 1 to 5 like in Excel.
  /// chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
  /// @endcode
  ///
  /// - `values`: This is the most important property of a series and is the
  /// only mandatory option for every chart object. This parameter links the
  /// chart with the worksheet data that it displays.
  ///
  /// The `categories` and `values` should be a string formula like
  /// `"=Sheet1!$A$2:$A$7"` in the same way it is represented in Excel. This is
  /// convenient when recreating a chart from an example in Excel but it is
  /// trickier to generate programmatically. For these cases you can set the
  /// `categories` and `values` to `NULL` and use the
  /// `chart_series_set_categories()` and `chart_series_set_values()` functions:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart, NULL, NULL);
  ///
  /// // Configure the series using a syntax that is easier to define programmatically.
  /// chart_series_set_categories(series, "Sheet1", 1, 0, 6, 0); // "=Sheet1!$A$2:$A$7"
  /// chart_series_set_values(    series, "Sheet1", 1, 2, 6, 2); // "=Sheet1!$C$2:$C$7"
  /// @endcode
  ///
  /// As shown in the previous example the return value from
  /// `%chart_add_series()` is a lxw_chart_series pointer. This can be used in
  /// other functions that configure a series.
  ///
  ///
  /// More than one series can be added to a chart. The series numbering and
  /// order in the Excel chart will be the same as the order in which they are
  /// added in libxlsxwriter:
  ///
  /// @code
  /// chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
  /// chart_add_series(chart, NULL, "Sheet1!$B$1:$B$5");
  /// chart_add_series(chart, NULL, "Sheet1!$C$1:$C$5");
  /// @endcode
  ///
  /// It is also possible to specify non-contiguous ranges:
  ///
  /// @code
  /// chart_add_series(
  /// chart,
  /// "=(Sheet1!$A$1:$A$9,Sheet1!$A$14:$A$25)",
  /// "=(Sheet1!$B$1:$B$9,Sheet1!$B$14:$B$25)"
  /// );
  /// @endcode
  ffi.Pointer<lxw_chart_series> chart_add_series(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<ffi.Char> categories,
    ffi.Pointer<ffi.Char> values,
  ) {
    return _chart_add_series(
      chart,
      categories,
      values,
    );
  }

  late final _chart_add_seriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chart_series> Function(
              ffi.Pointer<lxw_chart>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('chart_add_series');
  late final _chart_add_series = _chart_add_seriesPtr.asFunction<
      ffi.Pointer<lxw_chart_series> Function(ffi.Pointer<lxw_chart>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set a series "categories" range using row and column values.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param sheetname The name of the worksheet that contains the data range.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  ///
  /// The `categories` and `values` of a chart data series are generally set
  /// using the `chart_add_series()` function and Excel range formulas like
  /// `"=Sheet1!$A$2:$A$7"`.
  ///
  /// The `%chart_series_set_categories()` function is an alternative method that
  /// is easier to generate programmatically. It requires that you set the
  /// `categories` and `values` parameters in `chart_add_series()`to `NULL` and
  /// then set them using row and column values in
  /// `chart_series_set_categories()` and `chart_series_set_values()`:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart, NULL, NULL);
  ///
  /// // Configure the series ranges programmatically.
  /// chart_series_set_categories(series, "Sheet1", 1, 0, 6, 0); // "=Sheet1!$A$2:$A$7"
  /// chart_series_set_values(    series, "Sheet1", 1, 2, 6, 2); // "=Sheet1!$C$2:$C$7"
  /// @endcode
  void chart_series_set_categories(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> sheetname,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _chart_series_set_categories(
      series,
      sheetname,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _chart_series_set_categoriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t)>>('chart_series_set_categories');
  late final _chart_series_set_categories =
      _chart_series_set_categoriesPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>,
              int, int, int, int)>();

  /// @brief Set a series "values" range using row and column values.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param sheetname The name of the worksheet that contains the data range.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  ///
  /// The `categories` and `values` of a chart data series are generally set
  /// using the `chart_add_series()` function and Excel range formulas like
  /// `"=Sheet1!$A$2:$A$7"`.
  ///
  /// The `%chart_series_set_values()` function is an alternative method that is
  /// easier to generate programmatically. See the documentation for
  /// `chart_series_set_categories()` above.
  void chart_series_set_values(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> sheetname,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _chart_series_set_values(
      series,
      sheetname,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _chart_series_set_valuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t)>>('chart_series_set_values');
  late final _chart_series_set_values = _chart_series_set_valuesPtr.asFunction<
      void Function(ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>, int,
          int, int, int)>();

  /// @brief Set the name of a chart series range.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param name   The series name.
  ///
  /// The `%chart_series_set_name` function is used to set the name for a chart
  /// data series. The series name in Excel is displayed in the chart legend and
  /// in the formula bar. The name property is optional and if it isn't supplied
  /// it will default to `Series 1..n`.
  ///
  /// The function applies to a #lxw_chart_series object created using
  /// `chart_add_series()`:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
  ///
  /// chart_series_set_name(series, "Quarterly budget data");
  /// @endcode
  ///
  /// The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
  /// a cell in the workbook that contains the name:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
  ///
  /// chart_series_set_name(series, "=Sheet1!$B$1");
  /// @endcode
  ///
  /// See also the `chart_series_set_name_range()` function to see how to set the
  /// name formula programmatically.
  void chart_series_set_name(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _chart_series_set_name(
      series,
      name,
    );
  }

  late final _chart_series_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>)>>('chart_series_set_name');
  late final _chart_series_set_name = _chart_series_set_namePtr.asFunction<
      void Function(ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set a series name formula using row and column values.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param sheetname The name of the worksheet that contains the cell range.
  /// @param row       The zero indexed row number of the range.
  /// @param col       The zero indexed column number of the range.
  ///
  /// The `%chart_series_set_name_range()` function can be used to set a series
  /// name range and is an alternative to using `chart_series_set_name()` and a
  /// string formula:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
  ///
  /// chart_series_set_name_range(series, "Sheet1", 0, 2); // "=Sheet1!$C$1"
  /// @endcode
  void chart_series_set_name_range(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> sheetname,
    int row,
    int col,
  ) {
    return _chart_series_set_name_range(
      series,
      sheetname,
      row,
      col,
    );
  }

  late final _chart_series_set_name_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>,
              lxw_row_t,
              lxw_col_t)>>('chart_series_set_name_range');
  late final _chart_series_set_name_range =
      _chart_series_set_name_rangePtr.asFunction<
          void Function(ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>,
              int, int)>();

  /// @brief Set the line properties for a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param line   A #lxw_chart_line struct.
  ///
  /// Set the line/border properties of a chart series:
  ///
  /// @code
  /// lxw_chart_line line = {.color = LXW_COLOR_RED};
  ///
  /// chart_series_set_line(series1, &line);
  /// chart_series_set_line(series2, &line);
  /// chart_series_set_line(series3, &line);
  /// @endcode
  ///
  /// @image html chart_series_set_line.png
  ///
  /// For more information see @ref chart_lines.
  void chart_series_set_line(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_series_set_line(
      series,
      line,
    );
  }

  late final _chart_series_set_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_line>)>>('chart_series_set_line');
  late final _chart_series_set_line = _chart_series_set_linePtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param fill   A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of a chart series:
  ///
  /// @code
  /// lxw_chart_fill fill1 = {.color = LXW_COLOR_RED};
  /// lxw_chart_fill fill2 = {.color = LXW_COLOR_YELLOW};
  /// lxw_chart_fill fill3 = {.color = LXW_COLOR_GREEN};
  ///
  /// chart_series_set_fill(series1, &fill1);
  /// chart_series_set_fill(series2, &fill2);
  /// chart_series_set_fill(series3, &fill3);
  /// @endcode
  ///
  /// @image html chart_series_set_fill.png
  ///
  /// For more information see @ref chart_fills.
  void chart_series_set_fill(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_series_set_fill(
      series,
      fill,
    );
  }

  late final _chart_series_set_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_series_set_fill');
  late final _chart_series_set_fill = _chart_series_set_fillPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Invert the fill color for negative series values.
  ///
  /// @param series  A series object created via `chart_add_series()`.
  ///
  /// Invert the fill color for negative values. Usually only applicable to
  /// column and bar charts.
  ///
  /// @code
  /// chart_series_set_invert_if_negative(series);
  /// @endcode
  void chart_series_set_invert_if_negative(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_invert_if_negative(
      series,
    );
  }

  late final _chart_series_set_invert_if_negativePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_invert_if_negative');
  late final _chart_series_set_invert_if_negative =
      _chart_series_set_invert_if_negativePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the pattern properties for a chart series.
  ///
  /// @param series  A series object created via `chart_add_series()`.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of a chart series:
  ///
  /// @code
  /// lxw_chart_pattern pattern1 = {.type = LXW_CHART_PATTERN_SHINGLE,
  /// .fg_color = 0x804000,
  /// .bg_color = 0XC68C53};
  ///
  /// lxw_chart_pattern pattern2 = {.type = LXW_CHART_PATTERN_HORIZONTAL_BRICK,
  /// .fg_color = 0XB30000,
  /// .bg_color = 0XFF6666};
  ///
  /// chart_series_set_pattern(series1, &pattern1);
  /// chart_series_set_pattern(series2, &pattern2);
  ///
  /// @endcode
  ///
  /// @image html chart_pattern.png
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  void chart_series_set_pattern(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_series_set_pattern(
      series,
      pattern,
    );
  }

  late final _chart_series_set_patternPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_pattern>)>>('chart_series_set_pattern');
  late final _chart_series_set_pattern =
      _chart_series_set_patternPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Set the data marker type for a series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param type   The marker type, see #lxw_chart_marker_type.
  ///
  /// In Excel a chart marker is used to distinguish data points in a plotted
  /// series. In general only Line and Scatter and Radar chart types use
  /// markers. The libxlsxwriter chart types that can have markers are:
  ///
  /// - #LXW_CHART_LINE
  /// - #LXW_CHART_SCATTER
  /// - #LXW_CHART_SCATTER_STRAIGHT
  /// - #LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS
  /// - #LXW_CHART_SCATTER_SMOOTH
  /// - #LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS
  /// - #LXW_CHART_RADAR
  /// - #LXW_CHART_RADAR_WITH_MARKERS
  ///
  /// The chart types with `MARKERS` in the name have markers with default colors
  /// and shapes turned on by default but it is possible using the various
  /// `chart_series_set_marker_xxx()` functions below to change these defaults. It
  /// is also possible to turn on an off markers.
  ///
  /// The `%chart_series_set_marker_type()` function is used to specify the
  /// type of the series marker:
  ///
  /// @code
  /// chart_series_set_marker_type(series, LXW_CHART_MARKER_DIAMOND);
  /// @endcode
  ///
  /// @image html chart_marker1.png
  ///
  /// The available marker types defined by #lxw_chart_marker_type are:
  ///
  /// - #LXW_CHART_MARKER_AUTOMATIC
  /// - #LXW_CHART_MARKER_NONE
  /// - #LXW_CHART_MARKER_SQUARE
  /// - #LXW_CHART_MARKER_DIAMOND
  /// - #LXW_CHART_MARKER_TRIANGLE
  /// - #LXW_CHART_MARKER_X
  /// - #LXW_CHART_MARKER_STAR
  /// - #LXW_CHART_MARKER_SHORT_DASH
  /// - #LXW_CHART_MARKER_LONG_DASH
  /// - #LXW_CHART_MARKER_CIRCLE
  /// - #LXW_CHART_MARKER_PLUS
  ///
  /// The `#LXW_CHART_MARKER_NONE` type can be used to turn off default markers:
  ///
  /// @code
  /// chart_series_set_marker_type(series, LXW_CHART_MARKER_NONE);
  /// @endcode
  ///
  /// @image html chart_series_set_marker_none.png
  ///
  /// The `#LXW_CHART_MARKER_AUTOMATIC` type is a special case which turns on a
  /// marker using the default marker style for the particular series. If
  /// automatic is on then other marker properties such as size, line or fill
  /// cannot be set.
  void chart_series_set_marker_type(
    ffi.Pointer<lxw_chart_series> series,
    int type,
  ) {
    return _chart_series_set_marker_type(
      series,
      type,
    );
  }

  late final _chart_series_set_marker_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Uint8)>>('chart_series_set_marker_type');
  late final _chart_series_set_marker_type = _chart_series_set_marker_typePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int)>();

  /// @brief Set the size of a data marker for a series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param size   The size of the marker.
  ///
  /// The `%chart_series_set_marker_size()` function is used to specify the
  /// size of the series marker:
  ///
  /// @code
  /// chart_series_set_marker_type(series, LXW_CHART_MARKER_CIRCLE);
  /// chart_series_set_marker_size(series, 10);
  /// @endcode
  ///
  /// @image html chart_series_set_marker_size.png
  void chart_series_set_marker_size(
    ffi.Pointer<lxw_chart_series> series,
    int size,
  ) {
    return _chart_series_set_marker_size(
      series,
      size,
    );
  }

  late final _chart_series_set_marker_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Uint8)>>('chart_series_set_marker_size');
  late final _chart_series_set_marker_size = _chart_series_set_marker_sizePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int)>();

  /// @brief Set the line properties for a chart series marker.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param line   A #lxw_chart_line struct.
  ///
  /// Set the line/border properties of a chart marker:
  ///
  /// @code
  /// lxw_chart_line line = {.color = LXW_COLOR_BLACK};
  /// lxw_chart_fill fill = {.color = LXW_COLOR_RED};
  ///
  /// chart_series_set_marker_type(series, LXW_CHART_MARKER_SQUARE);
  /// chart_series_set_marker_size(series, 8);
  ///
  /// chart_series_set_marker_line(series, &line);
  /// chart_series_set_marker_fill(series, &fill);
  /// @endcode
  ///
  /// @image html chart_marker2.png
  ///
  /// For more information see @ref chart_lines.
  void chart_series_set_marker_line(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_series_set_marker_line(
      series,
      line,
    );
  }

  late final _chart_series_set_marker_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_line>)>>('chart_series_set_marker_line');
  late final _chart_series_set_marker_line =
      _chart_series_set_marker_linePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for a chart series marker.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param fill   A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of a chart marker:
  ///
  /// @code
  /// chart_series_set_marker_fill(series, &fill);
  /// @endcode
  ///
  /// See the example and image above and also see @ref chart_fills.
  void chart_series_set_marker_fill(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_series_set_marker_fill(
      series,
      fill,
    );
  }

  late final _chart_series_set_marker_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_series_set_marker_fill');
  late final _chart_series_set_marker_fill =
      _chart_series_set_marker_fillPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Set the pattern properties for a chart series marker.
  ///
  /// @param series  A series object created via `chart_add_series()`.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of a chart marker:
  ///
  /// @code
  /// chart_series_set_marker_pattern(series, &pattern);
  /// @endcode
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  void chart_series_set_marker_pattern(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_series_set_marker_pattern(
      series,
      pattern,
    );
  }

  late final _chart_series_set_marker_patternPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_chart_series>,
                  ffi.Pointer<lxw_chart_pattern>)>>(
      'chart_series_set_marker_pattern');
  late final _chart_series_set_marker_pattern =
      _chart_series_set_marker_patternPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Set the formatting for points in the series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param points An NULL terminated array of #lxw_chart_point pointers.
  ///
  /// @return A #lxw_error.
  ///
  /// In general formatting is applied to an entire series in a chart. However,
  /// it is occasionally required to format individual points in a series. In
  /// particular this is required for Pie/Doughnut charts where each segment is
  /// represented by a point.
  ///
  /// @dontinclude chart_pie_colors.c
  /// @skip Add the data series
  /// @until chart_series_set_points
  ///
  /// @image html chart_points1.png
  ///
  /// @note The array of #lxw_chart_point pointers should be NULL terminated
  /// as shown in the example.
  ///
  /// For more details see @ref chart_points
  int chart_series_set_points(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Pointer<lxw_chart_point>> points,
  ) {
    return _chart_series_set_points(
      series,
      points,
    );
  }

  late final _chart_series_set_pointsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<lxw_chart_series>,
                  ffi.Pointer<ffi.Pointer<lxw_chart_point>>)>>(
      'chart_series_set_points');
  late final _chart_series_set_points = _chart_series_set_pointsPtr.asFunction<
      int Function(ffi.Pointer<lxw_chart_series>,
          ffi.Pointer<ffi.Pointer<lxw_chart_point>>)>();

  /// @brief Smooth a line or scatter chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param smooth Turn off/on the line smoothing. (0/1)
  ///
  /// The `chart_series_set_smooth()` function is used to set the smooth property
  /// of a line series. It is only applicable to the line and scatter chart
  /// types:
  ///
  /// @code
  /// chart_series_set_smooth(series2, LXW_TRUE);
  /// @endcode
  ///
  /// @image html chart_smooth.png
  void chart_series_set_smooth(
    ffi.Pointer<lxw_chart_series> series,
    int smooth,
  ) {
    return _chart_series_set_smooth(
      series,
      smooth,
    );
  }

  late final _chart_series_set_smoothPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Uint8)>>('chart_series_set_smooth');
  late final _chart_series_set_smooth = _chart_series_set_smoothPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int)>();

  /// @brief Add data labels to a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_labels()` function is used to turn on data labels
  /// for a chart series. Data labels indicate the values of the plotted data
  /// points.
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// @endcode
  ///
  /// @image html chart_data_labels1.png
  ///
  /// By default data labels are displayed in Excel with only the values shown:
  ///
  /// @image html chart_data_labels2.png
  ///
  /// However, it is possible to configure other display options, as shown
  /// in the functions below.
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_labels(
      series,
    );
  }

  late final _chart_series_set_labelsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_labels');
  late final _chart_series_set_labels = _chart_series_set_labelsPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the display options for the labels of a data series.
  ///
  /// @param series        A series object created via `chart_add_series()`.
  /// @param show_name     Turn on/off the series name in the label caption.
  /// @param show_category Turn on/off the category name in the label caption.
  /// @param show_value    Turn on/off the value in the label caption.
  ///
  /// The `%chart_series_set_labels_options()` function is used to set the
  /// parameters that are displayed in the series data label:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_options(series, LXW_TRUE, LXW_TRUE, LXW_TRUE);
  /// @endcode
  ///
  /// @image html chart_data_labels3.png
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_options(
    ffi.Pointer<lxw_chart_series> series,
    int show_name,
    int show_category,
    int show_value,
  ) {
    return _chart_series_set_labels_options(
      series,
      show_name,
      show_category,
      show_value,
    );
  }

  late final _chart_series_set_labels_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>, ffi.Uint8, ffi.Uint8,
              ffi.Uint8)>>('chart_series_set_labels_options');
  late final _chart_series_set_labels_options =
      _chart_series_set_labels_optionsPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart_series>, int, int, int)>();

  /// @brief Set the properties for data labels in a series.
  ///
  /// @param series      A series object created via `chart_add_series()`.
  /// @param data_labels An NULL terminated array of #lxw_chart_data_label pointers.
  ///
  /// @return A #lxw_error.
  ///
  /// The `%chart_series_set_labels_custom()` function is used to set the properties
  /// for data labels in a series. It can also be used to delete individual data
  /// labels in a series.
  ///
  /// In general properties are set for all the data labels in a chart
  /// series. However, it is also possible to set properties for individual data
  /// labels in a series using `%chart_series_set_labels_custom()`.
  ///
  /// The `%chart_series_set_labels_custom()` function takes a pointer to an array
  /// of #lxw_chart_data_label pointers. The list should be `NULL` terminated:
  ///
  /// @code
  /// // Add the series data labels.
  /// chart_series_set_labels(series);
  ///
  /// // Create some custom labels.
  /// lxw_chart_data_label data_label1 = {.value = "Jan"};
  /// lxw_chart_data_label data_label2 = {.value = "Feb"};
  /// lxw_chart_data_label data_label3 = {.value = "Mar"};
  /// lxw_chart_data_label data_label4 = {.value = "Apr"};
  /// lxw_chart_data_label data_label5 = {.value = "May"};
  /// lxw_chart_data_label data_label6 = {.value = "Jun"};
  ///
  /// // Create an array of label pointers. NULL indicates the end of the array.
  /// lxw_chart_data_label *data_labels[] = {
  /// &data_label1,
  /// &data_label2,
  /// &data_label3,
  /// &data_label4,
  /// &data_label5,
  /// &data_label6,
  /// NULL
  /// };
  ///
  /// // Set the custom labels.
  /// chart_series_set_labels_custom(series, data_labels);
  /// @endcode
  ///
  /// @image html chart_data_labels18.png
  ///
  /// @note The array of #lxw_chart_point pointers should be NULL terminated as
  /// shown in the example. Any #lxw_chart_data_label items set to a default
  /// initialization or omitted from the list will be assigned the default data
  /// label value.
  ///
  /// For more details see @ref chart_custom_labels.
  int chart_series_set_labels_custom(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Pointer<lxw_chart_data_label>> data_labels,
  ) {
    return _chart_series_set_labels_custom(
      series,
      data_labels,
    );
  }

  late final _chart_series_set_labels_customPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<lxw_chart_series>,
                  ffi.Pointer<ffi.Pointer<lxw_chart_data_label>>)>>(
      'chart_series_set_labels_custom');
  late final _chart_series_set_labels_custom =
      _chart_series_set_labels_customPtr.asFunction<
          int Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Pointer<lxw_chart_data_label>>)>();

  /// @brief Set the separator for the data label captions.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param separator The separator for the data label options:
  /// #lxw_chart_label_separator.
  ///
  /// The `%chart_series_set_labels_separator()` function is used to change the
  /// separator between multiple data label items. The default options is a comma
  /// separator as shown in the previous example.
  ///
  /// The available options are:
  ///
  /// - #LXW_CHART_LABEL_SEPARATOR_SEMICOLON: semicolon separator.
  /// - #LXW_CHART_LABEL_SEPARATOR_PERIOD: a period (dot) separator.
  /// - #LXW_CHART_LABEL_SEPARATOR_NEWLINE: a newline separator.
  /// - #LXW_CHART_LABEL_SEPARATOR_SPACE: a space separator.
  ///
  /// For example:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_options(series, LXW_TRUE, LXW_TRUE, LXW_TRUE);
  /// chart_series_set_labels_separator(series, LXW_CHART_LABEL_SEPARATOR_NEWLINE);
  /// @endcode
  ///
  /// @image html chart_data_labels4.png
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_separator(
    ffi.Pointer<lxw_chart_series> series,
    int separator,
  ) {
    return _chart_series_set_labels_separator(
      series,
      separator,
    );
  }

  late final _chart_series_set_labels_separatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Uint8)>>('chart_series_set_labels_separator');
  late final _chart_series_set_labels_separator =
      _chart_series_set_labels_separatorPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int)>();

  /// @brief Set the data label position for a series.
  ///
  /// @param series   A series object created via `chart_add_series()`.
  /// @param position The data label position: #lxw_chart_label_position.
  ///
  /// The `%chart_series_set_labels_position()` function sets the position of
  /// the labels in the data series:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_position(series, LXW_CHART_LABEL_POSITION_ABOVE);
  /// @endcode
  ///
  /// @image html chart_data_labels5.png
  ///
  /// In Excel the allowable data label positions vary for different chart
  /// types. The allowable, and default, positions are:
  ///
  /// | Position                              | Line, Scatter | Bar, Column   | Pie, Doughnut | Area, Radar   |
  /// | :------------------------------------ | :------------ | :------------ | :------------ | :------------ |
  /// | #LXW_CHART_LABEL_POSITION_CENTER      | Yes           | Yes           | Yes           | Yes (default) |
  /// | #LXW_CHART_LABEL_POSITION_RIGHT       | Yes (default) |               |               |               |
  /// | #LXW_CHART_LABEL_POSITION_LEFT        | Yes           |               |               |               |
  /// | #LXW_CHART_LABEL_POSITION_ABOVE       | Yes           |               |               |               |
  /// | #LXW_CHART_LABEL_POSITION_BELOW       | Yes           |               |               |               |
  /// | #LXW_CHART_LABEL_POSITION_INSIDE_BASE |               | Yes           |               |               |
  /// | #LXW_CHART_LABEL_POSITION_INSIDE_END  |               | Yes           | Yes           |               |
  /// | #LXW_CHART_LABEL_POSITION_OUTSIDE_END |               | Yes (default) | Yes           |               |
  /// | #LXW_CHART_LABEL_POSITION_BEST_FIT    |               |               | Yes (default) |               |
  ///
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_position(
    ffi.Pointer<lxw_chart_series> series,
    int position,
  ) {
    return _chart_series_set_labels_position(
      series,
      position,
    );
  }

  late final _chart_series_set_labels_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Uint8)>>('chart_series_set_labels_position');
  late final _chart_series_set_labels_position =
      _chart_series_set_labels_positionPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int)>();

  /// @brief Set leader lines for Pie and Doughnut charts.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_labels_leader_line()` function  is used to turn on
  /// leader lines for the data label of a series. It is mainly used for pie
  /// or doughnut charts:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_leader_line(series);
  /// @endcode
  ///
  /// @note Even when leader lines are turned on they aren't automatically
  /// visible in Excel or XlsxWriter. Due to an Excel limitation
  /// (or design) leader lines only appear if the data label is moved
  /// manually or if the data labels are very close and need to be
  /// adjusted automatically.
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_leader_line(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_labels_leader_line(
      series,
    );
  }

  late final _chart_series_set_labels_leader_linePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_labels_leader_line');
  late final _chart_series_set_labels_leader_line =
      _chart_series_set_labels_leader_linePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the legend key for a data label in a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_labels_legend()` function is used to set the
  /// legend key for a data series:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_legend(series);
  /// @endcode
  ///
  /// @image html chart_data_labels6.png
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_legend(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_labels_legend(
      series,
    );
  }

  late final _chart_series_set_labels_legendPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_labels_legend');
  late final _chart_series_set_labels_legend =
      _chart_series_set_labels_legendPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the percentage for a Pie/Doughnut data point.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_labels_percentage()` function is used to turn on
  /// the display of data labels as a percentage for a series. It is mainly
  /// used for pie charts:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_options(series, LXW_FALSE, LXW_FALSE, LXW_FALSE);
  /// chart_series_set_labels_percentage(series);
  /// @endcode
  ///
  /// @image html chart_data_labels7.png
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_percentage(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_labels_percentage(
      series,
    );
  }

  late final _chart_series_set_labels_percentagePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_labels_percentage');
  late final _chart_series_set_labels_percentage =
      _chart_series_set_labels_percentagePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the number format for chart data labels in a series.
  ///
  /// @param series     A series object created via `chart_add_series()`.
  /// @param num_format The number format string.
  ///
  /// The `%chart_series_set_labels_num_format()` function is used to set the
  /// number format for data labels:
  ///
  /// @code
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_num_format(series, "$0.00");
  /// @endcode
  ///
  /// @image html chart_data_labels8.png
  ///
  /// The number format is similar to the Worksheet Cell Format num_format,
  /// see `format_set_num_format()`.
  ///
  /// For more information see @ref chart_labels.
  void chart_series_set_labels_num_format(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> num_format,
  ) {
    return _chart_series_set_labels_num_format(
      series,
      num_format,
    );
  }

  late final _chart_series_set_labels_num_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>)>>('chart_series_set_labels_num_format');
  late final _chart_series_set_labels_num_format =
      _chart_series_set_labels_num_formatPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the font properties for chart data labels in a series
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param font   A pointer to a chart #lxw_chart_font font struct.
  ///
  ///
  /// The `%chart_series_set_labels_font()` function is used to set the font
  /// for data labels:
  ///
  /// @code
  /// lxw_chart_font font = {.name = "Consolas", .color = LXW_COLOR_RED};
  ///
  /// chart_series_set_labels(series);
  /// chart_series_set_labels_font(series, &font);
  /// @endcode
  ///
  /// @image html chart_data_labels9.png
  ///
  /// For more information see @ref chart_fonts and @ref chart_labels.
  void chart_series_set_labels_font(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_series_set_labels_font(
      series,
      font,
    );
  }

  late final _chart_series_set_labels_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_font>)>>('chart_series_set_labels_font');
  late final _chart_series_set_labels_font =
      _chart_series_set_labels_fontPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Set the line properties for the data labels in a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param line   A #lxw_chart_line struct.
  ///
  /// Set the line/border properties of the data labels in a chart series:
  ///
  /// @code
  /// lxw_chart_line line = {.color = LXW_COLOR_RED};
  /// lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
  ///
  /// chart_series_set_labels_line(series, &line);
  /// chart_series_set_labels_fill(series, &fill);
  ///
  /// @endcode
  ///
  /// @image html chart_data_labels24.png
  ///
  /// For more information see @ref chart_lines and @ref chart_labels.
  void chart_series_set_labels_line(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_series_set_labels_line(
      series,
      line,
    );
  }

  late final _chart_series_set_labels_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_line>)>>('chart_series_set_labels_line');
  late final _chart_series_set_labels_line =
      _chart_series_set_labels_linePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for the data labels in a chart series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param fill   A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of the data labels in a chart series:
  ///
  /// @code
  /// lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
  ///
  /// chart_series_set_labels_fill(series, &fill);
  /// @endcode
  ///
  /// See the example and image above and also see @ref chart_fills and
  /// @ref chart_labels.
  void chart_series_set_labels_fill(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_series_set_labels_fill(
      series,
      fill,
    );
  }

  late final _chart_series_set_labels_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_series_set_labels_fill');
  late final _chart_series_set_labels_fill =
      _chart_series_set_labels_fillPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Set the pattern properties for the data labels in a chart series.
  ///
  /// @param series  A series object created via `chart_add_series()`.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of the data labels in a chart series:
  ///
  /// @code
  /// chart_series_set_labels_pattern(series, &pattern);
  /// @endcode
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  void chart_series_set_labels_pattern(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_series_set_labels_pattern(
      series,
      pattern,
    );
  }

  late final _chart_series_set_labels_patternPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_chart_series>,
                  ffi.Pointer<lxw_chart_pattern>)>>(
      'chart_series_set_labels_pattern');
  late final _chart_series_set_labels_pattern =
      _chart_series_set_labels_patternPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Turn on a trendline for a chart data series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param type   The type of trendline: #lxw_chart_trendline_type.
  /// @param value  The order/period value for polynomial and moving average
  /// trendlines.
  ///
  /// A trendline can be added to a chart series to indicate trends in the data
  /// such as a moving average or a polynomial fit. The trendlines types are
  /// shown in the following Excel dialog:
  ///
  /// @image html chart_trendline0.png
  ///
  /// The `%chart_series_set_trendline()` function turns on these trendlines for
  /// a data series:
  ///
  /// @code
  /// chart = workbook_add_chart(workbook, LXW_CHART_LINE);
  /// series = chart_add_series(chart, NULL, "Sheet1!$A$1:$A$6");
  ///
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// @endcode
  ///
  /// @image html chart_trendline2.png
  ///
  /// The `value` parameter corresponds to *order* for a polynomial trendline
  /// and *period* for a Moving Average trendline. It both cases it must be >= 2.
  /// The `value` parameter  is ignored for all other trendlines:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_AVERAGE, 2);
  /// @endcode
  ///
  /// @image html chart_trendline3.png
  ///
  /// The allowable values for the the trendline `type` are:
  ///
  /// - #LXW_CHART_TRENDLINE_TYPE_LINEAR: Linear trendline.
  /// - #LXW_CHART_TRENDLINE_TYPE_LOG: Logarithm trendline.
  /// - #LXW_CHART_TRENDLINE_TYPE_POLY: Polynomial trendline. The `value`
  /// parameter corresponds to *order*.
  /// - #LXW_CHART_TRENDLINE_TYPE_POWER: Power trendline.
  /// - #LXW_CHART_TRENDLINE_TYPE_EXP: Exponential trendline.
  /// - #LXW_CHART_TRENDLINE_TYPE_AVERAGE: Moving Average trendline. The `value`
  /// parameter corresponds to *period*.
  ///
  /// Other trendline options, such as those shown in the following Excel
  /// dialog, can be set using the functions below.
  ///
  /// @image html chart_trendline1.png
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline(
    ffi.Pointer<lxw_chart_series> series,
    int type,
    int value,
  ) {
    return _chart_series_set_trendline(
      series,
      type,
      value,
    );
  }

  late final _chart_series_set_trendlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>, ffi.Uint8,
              ffi.Uint8)>>('chart_series_set_trendline');
  late final _chart_series_set_trendline = _chart_series_set_trendlinePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_series>, int, int)>();

  /// @brief Set the trendline forecast for a chart data series.
  ///
  /// @param series   A series object created via `chart_add_series()`.
  /// @param forward  The forward period.
  /// @param backward The backwards period.
  ///
  /// The `%chart_series_set_trendline_forecast()` function sets the forward
  /// and backward forecast periods for the trendline:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_forecast(series, 0.5, 0.5);
  /// @endcode
  ///
  /// @image html chart_trendline4.png
  ///
  /// @note This feature isn't available for Moving Average in Excel.
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline_forecast(
    ffi.Pointer<lxw_chart_series> series,
    double forward,
    double backward,
  ) {
    return _chart_series_set_trendline_forecast(
      series,
      forward,
      backward,
    );
  }

  late final _chart_series_set_trendline_forecastPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>, ffi.Double,
              ffi.Double)>>('chart_series_set_trendline_forecast');
  late final _chart_series_set_trendline_forecast =
      _chart_series_set_trendline_forecastPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart_series>, double, double)>();

  /// @brief Display the equation of a trendline for a chart data series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_trendline_equation()` function displays the
  /// equation of the trendline on the chart:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_equation(series);
  /// @endcode
  ///
  /// @image html chart_trendline5.png
  ///
  /// @note This feature isn't available for Moving Average in Excel.
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline_equation(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_trendline_equation(
      series,
    );
  }

  late final _chart_series_set_trendline_equationPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_trendline_equation');
  late final _chart_series_set_trendline_equation =
      _chart_series_set_trendline_equationPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Display the R squared value of a trendline for a chart data series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  ///
  /// The `%chart_series_set_trendline_r_squared()` function displays the
  /// R-squared value for the trendline on the chart:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_r_squared(series);
  /// @endcode
  ///
  /// @image html chart_trendline6.png
  ///
  /// @note This feature isn't available for Moving Average in Excel.
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline_r_squared(
    ffi.Pointer<lxw_chart_series> series,
  ) {
    return _chart_series_set_trendline_r_squared(
      series,
    );
  }

  late final _chart_series_set_trendline_r_squaredPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_series>)>>(
      'chart_series_set_trendline_r_squared');
  late final _chart_series_set_trendline_r_squared =
      _chart_series_set_trendline_r_squaredPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>)>();

  /// @brief Set the trendline Y-axis intercept for a chart data series.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param intercept Y-axis intercept value.
  ///
  /// The `%chart_series_set_trendline_intercept()` function sets the Y-axis
  /// intercept for the trendline:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_equation(series);
  /// chart_series_set_trendline_intercept(series, 0.8);
  /// @endcode
  ///
  /// @image html chart_trendline7.png
  ///
  /// As can be seen from the equation on the chart the intercept point
  /// (when X=0) is the same as the value set in the equation.
  ///
  /// @note The intercept feature is only available in Excel for Exponential,
  /// Linear and Polynomial trendline types.
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline_intercept(
    ffi.Pointer<lxw_chart_series> series,
    double intercept,
  ) {
    return _chart_series_set_trendline_intercept(
      series,
      intercept,
    );
  }

  late final _chart_series_set_trendline_interceptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Double)>>('chart_series_set_trendline_intercept');
  late final _chart_series_set_trendline_intercept =
      _chart_series_set_trendline_interceptPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_series>, double)>();

  /// @brief Set the trendline name for a chart data series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param name   The name of the trendline to display in the legend.
  ///
  /// The `%chart_series_set_trendline_name()` function sets the name of the
  /// trendline that is displayed in the chart legend. In the examples above
  /// the trendlines are displayed with default names like "Linear (Series 1)"
  /// and "2 per Mov. Avg. (Series 1)". If these names are too verbose or not
  /// descriptive enough you can set your own trendline name:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_name(series, "My trendline");
  /// @endcode
  ///
  /// @image html chart_trendline8.png
  ///
  /// It is often preferable to turn off the trendline caption in the legend.
  /// This is down in Excel by deleting the trendline name from the legend.
  /// In libxlsxwriter this is done using the `chart_legend_delete_series()`
  /// function to delete the zero based series numbers:
  ///
  /// @code
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  ///
  /// // Delete the series name for the second series (=1 in zero base).
  /// // The -1 value indicates the end of the array of values.
  /// int16_t names[] = {1, -1};
  /// chart_legend_delete_series(chart, names);
  /// @endcode
  ///
  /// @image html chart_trendline9.png
  ///
  /// For more information see @ref chart_trendlines.
  void chart_series_set_trendline_name(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _chart_series_set_trendline_name(
      series,
      name,
    );
  }

  late final _chart_series_set_trendline_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<ffi.Char>)>>('chart_series_set_trendline_name');
  late final _chart_series_set_trendline_name =
      _chart_series_set_trendline_namePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the trendline line properties for a chart data series.
  ///
  /// @param series A series object created via `chart_add_series()`.
  /// @param line   A #lxw_chart_line struct.
  ///
  /// The `%chart_series_set_trendline_line()` function is used to set the line
  /// properties of a trendline:
  ///
  /// @code
  /// lxw_chart_line line = {.color     = LXW_COLOR_RED,
  /// .dash_type = LXW_CHART_LINE_DASH_LONG_DASH};
  ///
  /// chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
  /// chart_series_set_trendline_line(series, &line);
  /// @endcode
  ///
  /// @image html chart_trendline10.png
  ///
  /// For more information see @ref chart_trendlines and @ref chart_lines.
  void chart_series_set_trendline_line(
    ffi.Pointer<lxw_chart_series> series,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_series_set_trendline_line(
      series,
      line,
    );
  }

  late final _chart_series_set_trendline_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_series>,
              ffi.Pointer<lxw_chart_line>)>>('chart_series_set_trendline_line');
  late final _chart_series_set_trendline_line =
      _chart_series_set_trendline_linePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_series>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief           Get a pointer to X or Y error bars from a chart series.
  ///
  /// @param series    A series object created via `chart_add_series()`.
  /// @param axis_type The axis type (X or Y): #lxw_chart_error_bar_axis.
  ///
  /// The `%chart_series_get_error_bars()` function returns a pointer to the
  /// error bars of a series based on the type of #lxw_chart_error_bar_axis:
  ///
  /// @code
  /// lxw_series_error_bars *x_error_bars;
  /// lxw_series_error_bars *y_error_bars;
  ///
  /// x_error_bars = chart_series_get_error_bars(series, LXW_CHART_ERROR_BAR_AXIS_X);
  /// y_error_bars = chart_series_get_error_bars(series, LXW_CHART_ERROR_BAR_AXIS_Y);
  ///
  /// // Use the error bar pointers.
  /// chart_series_set_error_bars(x_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
  ///
  /// chart_series_set_error_bars(y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  /// @endcode
  ///
  /// Note, the series error bars can also be accessed directly:
  ///
  /// @code
  /// // Equivalent to the above example, without function calls.
  /// chart_series_set_error_bars(series->x_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
  ///
  /// chart_series_set_error_bars(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  /// @endcode
  ///
  /// @return Pointer to the series error bars, or NULL if not found.
  ffi.Pointer<lxw_series_error_bars> chart_series_get_error_bars(
    ffi.Pointer<lxw_chart_series> series,
    int axis_type,
  ) {
    return _chart_series_get_error_bars(
      series,
      axis_type,
    );
  }

  late final _chart_series_get_error_barsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_series_error_bars> Function(
              ffi.Pointer<lxw_chart_series>,
              ffi.Int32)>>('chart_series_get_error_bars');
  late final _chart_series_get_error_bars =
      _chart_series_get_error_barsPtr.asFunction<
          ffi.Pointer<lxw_series_error_bars> Function(
              ffi.Pointer<lxw_chart_series>, int)>();

  /// Set the X or Y error bars for a chart series.
  ///
  /// @param error_bars A pointer to the series X or Y error bars.
  /// @param type       The type of error bar: #lxw_chart_error_bar_type.
  /// @param value      The error value.
  ///
  /// Error bars can be added to a chart series to indicate error bounds in the
  /// data. The error bars can be vertical `y_error_bars` (the most common type)
  /// or horizontal `x_error_bars` (for Bar and Scatter charts only).
  ///
  /// @image html chart_error_bars0.png
  ///
  /// The `%chart_series_set_error_bars()` function sets the error bar type
  /// and value associated with the type:
  ///
  /// @code
  /// lxw_chart_series *series = chart_add_series(chart,
  /// "=Sheet1!$A$1:$A$5",
  /// "=Sheet1!$B$1:$B$5");
  ///
  /// chart_series_set_error_bars(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  /// @endcode
  ///
  /// @image html chart_error_bars1.png
  ///
  /// The error bar types that be used are:
  ///
  /// - #LXW_CHART_ERROR_BAR_TYPE_STD_ERROR: Standard error.
  /// - #LXW_CHART_ERROR_BAR_TYPE_FIXED: Fixed value.
  /// - #LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE: Percentage.
  /// - #LXW_CHART_ERROR_BAR_TYPE_STD_DEV: Standard deviation(s).
  ///
  /// @note Custom error bars are not currently supported.
  ///
  /// All error bar types, apart from Standard error, should have a valid
  /// value to set the error range:
  ///
  /// @code
  /// chart_series_set_error_bars(series1->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_FIXED, 2);
  ///
  /// chart_series_set_error_bars(series2->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE, 5);
  ///
  /// chart_series_set_error_bars(series3->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
  /// @endcode
  ///
  /// For the Standard error type the value is ignored.
  ///
  /// For more information see @ref chart_error_bars.
  void chart_series_set_error_bars(
    ffi.Pointer<lxw_series_error_bars> error_bars,
    int type,
    double value,
  ) {
    return _chart_series_set_error_bars(
      error_bars,
      type,
      value,
    );
  }

  late final _chart_series_set_error_barsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_series_error_bars>, ffi.Uint8,
              ffi.Double)>>('chart_series_set_error_bars');
  late final _chart_series_set_error_bars =
      _chart_series_set_error_barsPtr.asFunction<
          void Function(ffi.Pointer<lxw_series_error_bars>, int, double)>();

  /// @brief Set the direction (up, down or both) of the error bars for a chart
  /// series.
  ///
  /// @param error_bars A pointer to the series X or Y error bars.
  /// @param direction  The bar direction: #lxw_chart_error_bar_direction.
  ///
  /// The `%chart_series_set_error_bars_direction()` function sets the
  /// direction of the error bars:
  ///
  /// @code
  /// chart_series_set_error_bars(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  ///
  /// chart_series_set_error_bars_direction(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_DIR_PLUS);
  /// @endcode
  ///
  /// @image html chart_error_bars2.png
  ///
  /// The valid directions are:
  ///
  /// - #LXW_CHART_ERROR_BAR_DIR_BOTH: Error bar extends in both directions.
  /// The default.
  /// - #LXW_CHART_ERROR_BAR_DIR_PLUS: Error bar extends in positive direction.
  /// - #LXW_CHART_ERROR_BAR_DIR_MINUS: Error bar extends in negative direction.
  ///
  /// For more information see @ref chart_error_bars.
  void chart_series_set_error_bars_direction(
    ffi.Pointer<lxw_series_error_bars> error_bars,
    int direction,
  ) {
    return _chart_series_set_error_bars_direction(
      error_bars,
      direction,
    );
  }

  late final _chart_series_set_error_bars_directionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_series_error_bars>,
              ffi.Uint8)>>('chart_series_set_error_bars_direction');
  late final _chart_series_set_error_bars_direction =
      _chart_series_set_error_bars_directionPtr
          .asFunction<void Function(ffi.Pointer<lxw_series_error_bars>, int)>();

  /// @brief Set the end cap type for the error bars of a chart series.
  ///
  /// @param error_bars A pointer to the series X or Y error bars.
  /// @param endcap     The error bar end cap type: #lxw_chart_error_bar_cap .
  ///
  /// The `%chart_series_set_error_bars_endcap()` function sets the end cap
  /// type for the error bars:
  ///
  /// @code
  /// chart_series_set_error_bars(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  ///
  /// chart_series_set_error_bars_endcap(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_NO_CAP);
  /// @endcode
  ///
  /// @image html chart_error_bars3.png
  ///
  /// The valid values are:
  ///
  /// - #LXW_CHART_ERROR_BAR_END_CAP: Flat end cap. The default.
  /// - #LXW_CHART_ERROR_BAR_NO_CAP: No end cap.
  ///
  /// For more information see @ref chart_error_bars.
  void chart_series_set_error_bars_endcap(
    ffi.Pointer<lxw_series_error_bars> error_bars,
    int endcap,
  ) {
    return _chart_series_set_error_bars_endcap(
      error_bars,
      endcap,
    );
  }

  late final _chart_series_set_error_bars_endcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_series_error_bars>,
              ffi.Uint8)>>('chart_series_set_error_bars_endcap');
  late final _chart_series_set_error_bars_endcap =
      _chart_series_set_error_bars_endcapPtr
          .asFunction<void Function(ffi.Pointer<lxw_series_error_bars>, int)>();

  /// @brief Set the line properties for a chart series error bars.
  ///
  /// @param error_bars A pointer to the series X or Y error bars.
  /// @param line       A #lxw_chart_line struct.
  ///
  /// The `%chart_series_set_error_bars_line()` function sets the line
  /// properties for the error bars:
  ///
  /// @code
  /// lxw_chart_line line = {.color     = LXW_COLOR_RED,
  /// .dash_type = LXW_CHART_LINE_DASH_ROUND_DOT};
  ///
  /// chart_series_set_error_bars(series->y_error_bars,
  /// LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
  ///
  /// chart_series_set_error_bars_line(series->y_error_bars, &line);
  /// @endcode
  ///
  /// @image html chart_error_bars4.png
  ///
  /// For more information see @ref chart_lines and @ref chart_error_bars.
  void chart_series_set_error_bars_line(
    ffi.Pointer<lxw_series_error_bars> error_bars,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_series_set_error_bars_line(
      error_bars,
      line,
    );
  }

  late final _chart_series_set_error_bars_linePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_series_error_bars>,
                  ffi.Pointer<lxw_chart_line>)>>(
      'chart_series_set_error_bars_line');
  late final _chart_series_set_error_bars_line =
      _chart_series_set_error_bars_linePtr.asFunction<
          void Function(ffi.Pointer<lxw_series_error_bars>,
              ffi.Pointer<lxw_chart_line>)>();

  /// @brief           Get an axis pointer from a chart.
  ///
  /// @param chart     Pointer to a lxw_chart instance to be configured.
  /// @param axis_type The axis type (X or Y): #lxw_chart_axis_type.
  ///
  /// The `%chart_axis_get()` function returns a pointer to a chart axis based
  /// on the  #lxw_chart_axis_type:
  ///
  /// @code
  /// lxw_chart_axis *x_axis = chart_axis_get(chart, LXW_CHART_AXIS_TYPE_X);
  /// lxw_chart_axis *y_axis = chart_axis_get(chart, LXW_CHART_AXIS_TYPE_Y);
  ///
  /// // Use the axis pointer in other functions.
  /// chart_axis_major_gridlines_set_visible(x_axis, LXW_TRUE);
  /// chart_axis_major_gridlines_set_visible(y_axis, LXW_TRUE);
  /// @endcode
  ///
  /// Note, the axis pointer can also be accessed directly:
  ///
  /// @code
  /// // Equivalent to the above example, without function calls.
  /// chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
  /// chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_TRUE);
  /// @endcode
  ///
  /// @return Pointer to the chart axis, or NULL if not found.
  ffi.Pointer<lxw_chart_axis> chart_axis_get(
    ffi.Pointer<lxw_chart> chart,
    int axis_type,
  ) {
    return _chart_axis_get(
      chart,
      axis_type,
    );
  }

  late final _chart_axis_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chart_axis> Function(
              ffi.Pointer<lxw_chart>, ffi.Int32)>>('chart_axis_get');
  late final _chart_axis_get = _chart_axis_getPtr.asFunction<
      ffi.Pointer<lxw_chart_axis> Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Set the name caption of the an axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param name The name caption of the axis.
  ///
  /// The `%chart_axis_set_name()` function sets the name (also known as title or
  /// caption) for an axis. It can be used for the X or Y axes. The name is
  /// displayed below an X axis and to the side of a Y axis.
  ///
  /// @code
  /// chart_axis_set_name(chart->x_axis, "Earnings per Quarter");
  /// chart_axis_set_name(chart->y_axis, "US Dollars (Millions)");
  /// @endcode
  ///
  /// @image html chart_axis_set_name.png
  ///
  /// The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
  /// a cell in the workbook that contains the name:
  ///
  /// @code
  /// chart_axis_set_name(chart->x_axis, "=Sheet1!$B$1");
  /// @endcode
  ///
  /// See also the `chart_axis_set_name_range()` function to see how to set the
  /// name formula programmatically.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_name(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _chart_axis_set_name(
      axis,
      name,
    );
  }

  late final _chart_axis_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<ffi.Char>)>>('chart_axis_set_name');
  late final _chart_axis_set_name = _chart_axis_set_namePtr.asFunction<
      void Function(ffi.Pointer<lxw_chart_axis>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set a chart axis name formula using row and column values.
  ///
  /// @param axis      A pointer to a chart #lxw_chart_axis object.
  /// @param sheetname The name of the worksheet that contains the cell range.
  /// @param row       The zero indexed row number of the range.
  /// @param col       The zero indexed column number of the range.
  ///
  /// The `%chart_axis_set_name_range()` function can be used to set an axis name
  /// range and is an alternative to using `chart_axis_set_name()` and a string
  /// formula:
  ///
  /// @code
  /// chart_axis_set_name_range(chart->x_axis, "Sheet1", 1, 0);
  /// chart_axis_set_name_range(chart->y_axis, "Sheet1", 2, 0);
  /// @endcode
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_name_range(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<ffi.Char> sheetname,
    int row,
    int col,
  ) {
    return _chart_axis_set_name_range(
      axis,
      sheetname,
      row,
      col,
    );
  }

  late final _chart_axis_set_name_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>, ffi.Pointer<ffi.Char>,
              lxw_row_t, lxw_col_t)>>('chart_axis_set_name_range');
  late final _chart_axis_set_name_range =
      _chart_axis_set_name_rangePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Pointer<ffi.Char>, int, int)>();

  /// @brief Set the font properties for a chart axis name.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param font A pointer to a chart #lxw_chart_font font struct.
  ///
  /// The `%chart_axis_set_name_font()` function is used to set the font of an
  /// axis name:
  ///
  /// @code
  /// lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
  ///
  /// chart_axis_set_name(chart->x_axis, "Yearly data");
  /// chart_axis_set_name_font(chart->x_axis, &font);
  /// @endcode
  ///
  /// @image html chart_axis_set_name_font.png
  ///
  /// For more information see @ref chart_fonts.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_name_font(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_axis_set_name_font(
      axis,
      font,
    );
  }

  late final _chart_axis_set_name_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<lxw_chart_font>)>>('chart_axis_set_name_font');
  late final _chart_axis_set_name_font =
      _chart_axis_set_name_fontPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Set the font properties for the numbers of a chart axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param font A pointer to a chart #lxw_chart_font font struct.
  ///
  /// The `%chart_axis_set_num_font()` function is used to set the font of the
  /// numbers on an axis:
  ///
  /// @code
  /// lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
  ///
  /// chart_axis_set_num_font(chart->x_axis, &font1);
  /// @endcode
  ///
  /// @image html chart_axis_set_num_font.png
  ///
  /// For more information see @ref chart_fonts.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_num_font(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_axis_set_num_font(
      axis,
      font,
    );
  }

  late final _chart_axis_set_num_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<lxw_chart_font>)>>('chart_axis_set_num_font');
  late final _chart_axis_set_num_font = _chart_axis_set_num_fontPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Set the number format for a chart axis.
  ///
  /// @param axis       A pointer to a chart #lxw_chart_axis object.
  /// @param num_format The number format string.
  ///
  /// The `%chart_axis_set_num_format()` function is used to set the format of
  /// the numbers on an axis:
  ///
  /// @code
  /// chart_axis_set_num_format(chart->x_axis, "0.00%");
  /// chart_axis_set_num_format(chart->y_axis, "$#,##0.00");
  /// @endcode
  ///
  /// The number format is similar to the Worksheet Cell Format num_format,
  /// see `format_set_num_format()`.
  ///
  /// @image html chart_axis_num_format.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_num_format(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<ffi.Char> num_format,
  ) {
    return _chart_axis_set_num_format(
      axis,
      num_format,
    );
  }

  late final _chart_axis_set_num_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<ffi.Char>)>>('chart_axis_set_num_format');
  late final _chart_axis_set_num_format =
      _chart_axis_set_num_formatPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart_axis>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the line properties for a chart axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param line A #lxw_chart_line struct.
  ///
  /// Set the line properties of a chart axis:
  ///
  /// @code
  /// // Hide the Y axis.
  /// lxw_chart_line line = {.none = LXW_TRUE};
  ///
  /// chart_axis_set_line(chart->y_axis, &line);
  /// @endcode
  ///
  /// @image html chart_axis_set_line.png
  ///
  /// For more information see @ref chart_lines.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_line(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_axis_set_line(
      axis,
      line,
    );
  }

  late final _chart_axis_set_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<lxw_chart_line>)>>('chart_axis_set_line');
  late final _chart_axis_set_line = _chart_axis_set_linePtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for a chart axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param fill A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of a chart axis:
  ///
  /// @code
  /// lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
  ///
  /// chart_axis_set_fill(chart->y_axis, &fill);
  /// @endcode
  ///
  /// @image html chart_axis_set_fill.png
  ///
  /// For more information see @ref chart_fills.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_fill(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_axis_set_fill(
      axis,
      fill,
    );
  }

  late final _chart_axis_set_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_axis_set_fill');
  late final _chart_axis_set_fill = _chart_axis_set_fillPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Set the pattern properties for a chart axis.
  ///
  /// @param axis    A pointer to a chart #lxw_chart_axis object.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of a chart axis:
  ///
  /// @code
  /// chart_axis_set_pattern(chart->y_axis, &pattern);
  /// @endcode
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_pattern(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_axis_set_pattern(
      axis,
      pattern,
    );
  }

  late final _chart_axis_set_patternPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Pointer<lxw_chart_pattern>)>>('chart_axis_set_pattern');
  late final _chart_axis_set_pattern = _chart_axis_set_patternPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Reverse the order of the axis categories or values.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  ///
  /// Reverse the order of the axis categories or values:
  ///
  /// @code
  /// chart_axis_set_reverse(chart->x_axis);
  /// @endcode
  ///
  /// @image html chart_reverse.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_reverse(
    ffi.Pointer<lxw_chart_axis> axis,
  ) {
    return _chart_axis_set_reverse(
      axis,
    );
  }

  late final _chart_axis_set_reversePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_axis>)>>(
      'chart_axis_set_reverse');
  late final _chart_axis_set_reverse = _chart_axis_set_reversePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>)>();

  /// @brief Set the position that the axis will cross the opposite axis.
  ///
  /// @param axis  A pointer to a chart #lxw_chart_axis object.
  /// @param value The category or value that the axis crosses at.
  ///
  /// Set the position that the axis will cross the opposite axis:
  ///
  /// @code
  /// chart_axis_set_crossing(chart->x_axis, 3);
  /// chart_axis_set_crossing(chart->y_axis, 8);
  /// @endcode
  ///
  /// @image html chart_crossing1.png
  ///
  /// If crossing is omitted (the default) the crossing will be set automatically
  /// by Excel based on the chart data.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_crossing(
    ffi.Pointer<lxw_chart_axis> axis,
    double value,
  ) {
    return _chart_axis_set_crossing(
      axis,
      value,
    );
  }

  late final _chart_axis_set_crossingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Double)>>('chart_axis_set_crossing');
  late final _chart_axis_set_crossing = _chart_axis_set_crossingPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, double)>();

  /// @brief Set the opposite axis crossing position as the axis maximum.
  ///
  /// @param axis  A pointer to a chart #lxw_chart_axis object.
  ///
  /// Set the position that the opposite axis will cross as the axis maximum.
  /// The default axis crossing position is generally the axis minimum so this
  /// function can be used to reverse the location of the axes without reversing
  /// the number sequence:
  ///
  /// @code
  /// chart_axis_set_crossing_max(chart->x_axis);
  /// chart_axis_set_crossing_max(chart->y_axis);
  /// @endcode
  ///
  /// @image html chart_crossing2.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_crossing_max(
    ffi.Pointer<lxw_chart_axis> axis,
  ) {
    return _chart_axis_set_crossing_max(
      axis,
    );
  }

  late final _chart_axis_set_crossing_maxPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_axis>)>>(
      'chart_axis_set_crossing_max');
  late final _chart_axis_set_crossing_max = _chart_axis_set_crossing_maxPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>)>();

  /// @brief Set the opposite axis crossing position as the axis minimum.
  ///
  /// @param axis  A pointer to a chart #lxw_chart_axis object.
  ///
  /// Set the position that the opposite axis will cross as the axis minimum.
  /// The default axis crossing position is generally the axis minimum so this
  /// function can be used to reverse the location of the axes without reversing
  /// the number sequence:
  ///
  /// @code
  /// chart_axis_set_crossing_min(chart->x_axis);
  /// chart_axis_set_crossing_min(chart->y_axis);
  /// @endcode
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_crossing_min(
    ffi.Pointer<lxw_chart_axis> axis,
  ) {
    return _chart_axis_set_crossing_min(
      axis,
    );
  }

  late final _chart_axis_set_crossing_minPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_axis>)>>(
      'chart_axis_set_crossing_min');
  late final _chart_axis_set_crossing_min = _chart_axis_set_crossing_minPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>)>();

  /// @brief Turn off/hide an axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  ///
  /// Turn off, hide, a chart axis:
  ///
  /// @code
  /// chart_axis_off(chart->x_axis);
  /// @endcode
  ///
  /// @image html chart_axis_off.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_off(
    ffi.Pointer<lxw_chart_axis> axis,
  ) {
    return _chart_axis_off(
      axis,
    );
  }

  late final _chart_axis_offPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart_axis>)>>(
      'chart_axis_off');
  late final _chart_axis_off = _chart_axis_offPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>)>();

  /// @brief Position a category axis on or between the axis tick marks.
  ///
  /// @param axis     A pointer to a chart #lxw_chart_axis object.
  /// @param position A #lxw_chart_axis_tick_position value.
  ///
  /// Position a category axis horizontally on, or between, the axis tick marks.
  ///
  /// There are two allowable values:
  ///
  /// - #LXW_CHART_AXIS_POSITION_ON_TICK
  /// - #LXW_CHART_AXIS_POSITION_BETWEEN
  ///
  /// @code
  /// chart_axis_set_position(chart->x_axis, LXW_CHART_AXIS_POSITION_BETWEEN);
  /// @endcode
  ///
  /// @image html chart_axis_set_position.png
  ///
  /// **Axis types**: This function is applicable to category axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_position(
    ffi.Pointer<lxw_chart_axis> axis,
    int position,
  ) {
    return _chart_axis_set_position(
      axis,
      position,
    );
  }

  late final _chart_axis_set_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_position');
  late final _chart_axis_set_position = _chart_axis_set_positionPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Position the axis labels.
  ///
  /// @param axis     A pointer to a chart #lxw_chart_axis object.
  /// @param position A #lxw_chart_axis_label_position value.
  ///
  /// Position the axis labels for the chart. The labels are the numbers, or
  /// strings or dates, on the axis that indicate the categories or values of
  /// the axis.
  ///
  /// For example:
  ///
  /// @code
  /// chart_axis_set_label_position(chart->x_axis, LXW_CHART_AXIS_LABEL_POSITION_HIGH);
  /// chart_axis_set_label_position(chart->y_axis, LXW_CHART_AXIS_LABEL_POSITION_HIGH);
  /// @endcode
  ///
  /// @image html chart_label_position2.png
  ///
  /// The allowable values:
  ///
  /// - #LXW_CHART_AXIS_LABEL_POSITION_NEXT_TO - The default.
  /// - #LXW_CHART_AXIS_LABEL_POSITION_HIGH - Also right for vertical axes.
  /// - #LXW_CHART_AXIS_LABEL_POSITION_LOW - Also left for vertical axes.
  /// - #LXW_CHART_AXIS_LABEL_POSITION_NONE
  ///
  /// @image html chart_label_position1.png
  ///
  /// The #LXW_CHART_AXIS_LABEL_POSITION_NONE turns off the axis labels. This
  /// is slightly different from `chart_axis_off()` which also turns off the
  /// labels but also turns off tick marks.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_label_position(
    ffi.Pointer<lxw_chart_axis> axis,
    int position,
  ) {
    return _chart_axis_set_label_position(
      axis,
      position,
    );
  }

  late final _chart_axis_set_label_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_label_position');
  late final _chart_axis_set_label_position = _chart_axis_set_label_positionPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the alignment of the axis labels.
  ///
  /// @param axis  A pointer to a chart #lxw_chart_axis object.
  /// @param align A #lxw_chart_axis_label_alignment value.
  ///
  /// Position the category axis labels for the chart. The labels are the
  /// numbers, or strings or dates, on the axis that indicate the categories
  /// of the axis.
  ///
  /// The allowable values:
  ///
  /// - #LXW_CHART_AXIS_LABEL_ALIGN_CENTER - Align label center (default).
  /// - #LXW_CHART_AXIS_LABEL_ALIGN_LEFT - Align label left.
  /// - #LXW_CHART_AXIS_LABEL_ALIGN_RIGHT - Align label right.
  ///
  /// @code
  /// chart_axis_set_label_align(chart->x_axis, LXW_CHART_AXIS_LABEL_ALIGN_RIGHT);
  /// @endcode
  ///
  /// **Axis types**: This function is applicable to category axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_label_align(
    ffi.Pointer<lxw_chart_axis> axis,
    int align,
  ) {
    return _chart_axis_set_label_align(
      axis,
      align,
    );
  }

  late final _chart_axis_set_label_alignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_label_align');
  late final _chart_axis_set_label_align = _chart_axis_set_label_alignPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the minimum value for a chart axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param min  Minimum value for chart axis. Value axes only.
  ///
  /// Set the minimum value for the axis range.
  ///
  /// @code
  /// chart_axis_set_min(chart->y_axis, -4);
  /// chart_axis_set_max(chart->y_axis, 21);
  /// @endcode
  ///
  /// @image html chart_max_min.png
  ///
  /// **Axis types**: This function is applicable to value and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_min(
    ffi.Pointer<lxw_chart_axis> axis,
    double min,
  ) {
    return _chart_axis_set_min(
      axis,
      min,
    );
  }

  late final _chart_axis_set_minPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Double)>>('chart_axis_set_min');
  late final _chart_axis_set_min = _chart_axis_set_minPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, double)>();

  /// @brief Set the maximum value for a chart axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param max  Maximum value for chart axis. Value axes only.
  ///
  /// Set the maximum value for the axis range.
  ///
  /// @code
  /// chart_axis_set_min(chart->y_axis, -4);
  /// chart_axis_set_max(chart->y_axis, 21);
  /// @endcode
  ///
  /// See the above image.
  ///
  /// **Axis types**: This function is applicable to value and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_max(
    ffi.Pointer<lxw_chart_axis> axis,
    double max,
  ) {
    return _chart_axis_set_max(
      axis,
      max,
    );
  }

  late final _chart_axis_set_maxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Double)>>('chart_axis_set_max');
  late final _chart_axis_set_max = _chart_axis_set_maxPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, double)>();

  /// @brief Set the log base of the axis range.
  ///
  /// @param axis     A pointer to a chart #lxw_chart_axis object.
  /// @param log_base The log base for value axis. Value axes only.
  ///
  /// Set the log base for the axis:
  ///
  /// @code
  /// chart_axis_set_log_base(chart->y_axis, 10);
  /// @endcode
  ///
  /// @image html chart_log_base.png
  ///
  /// The allowable range of values for the log base in Excel is between 2 and
  /// 1000.
  ///
  /// **Axis types**: This function is applicable to value axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_log_base(
    ffi.Pointer<lxw_chart_axis> axis,
    int log_base,
  ) {
    return _chart_axis_set_log_base(
      axis,
      log_base,
    );
  }

  late final _chart_axis_set_log_basePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint16)>>('chart_axis_set_log_base');
  late final _chart_axis_set_log_base = _chart_axis_set_log_basePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the major axis tick mark type.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param type The tick mark type, defined by #lxw_chart_tick_mark.
  ///
  /// Set the type of the major axis tick mark:
  ///
  /// @code
  /// chart_axis_set_major_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_CROSSING);
  /// chart_axis_set_minor_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
  ///
  /// chart_axis_set_major_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_OUTSIDE);
  /// chart_axis_set_minor_tick_mark(chart->y_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
  ///
  /// // Hide the default gridlines so the tick marks are visible.
  /// chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_FALSE);
  /// @endcode
  ///
  /// @image html chart_tick_marks.png
  ///
  /// The tick mark types are:
  ///
  /// - #LXW_CHART_AXIS_TICK_MARK_NONE
  /// - #LXW_CHART_AXIS_TICK_MARK_INSIDE
  /// - #LXW_CHART_AXIS_TICK_MARK_OUTSIDE
  /// - #LXW_CHART_AXIS_TICK_MARK_CROSSING
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_major_tick_mark(
    ffi.Pointer<lxw_chart_axis> axis,
    int type,
  ) {
    return _chart_axis_set_major_tick_mark(
      axis,
      type,
    );
  }

  late final _chart_axis_set_major_tick_markPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_major_tick_mark');
  late final _chart_axis_set_major_tick_mark =
      _chart_axis_set_major_tick_markPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the minor axis tick mark type.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param type The tick mark type, defined by #lxw_chart_tick_mark.
  ///
  /// Set the type of the minor axis tick mark:
  ///
  /// @code
  /// chart_axis_set_minor_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
  /// @endcode
  ///
  /// See the image and example above.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_set_minor_tick_mark(
    ffi.Pointer<lxw_chart_axis> axis,
    int type,
  ) {
    return _chart_axis_set_minor_tick_mark(
      axis,
      type,
    );
  }

  late final _chart_axis_set_minor_tick_markPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_minor_tick_mark');
  late final _chart_axis_set_minor_tick_mark =
      _chart_axis_set_minor_tick_markPtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the interval between category values.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param unit The interval between the categories.
  ///
  /// Set the interval between the category values. The default interval is 1
  /// which gives the intervals shown in the charts above:
  ///
  /// 1, 2, 3, 4, 5, etc.
  ///
  /// Setting it to 2 gives:
  ///
  /// 1, 3, 5, 7, etc.
  ///
  /// For example:
  ///
  /// @code
  /// chart_axis_set_interval_unit(chart->x_axis, 2);
  /// @endcode
  ///
  /// @image html chart_set_interval1.png
  ///
  /// **Axis types**: This function is applicable to category and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_interval_unit(
    ffi.Pointer<lxw_chart_axis> axis,
    int unit,
  ) {
    return _chart_axis_set_interval_unit(
      axis,
      unit,
    );
  }

  late final _chart_axis_set_interval_unitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint16)>>('chart_axis_set_interval_unit');
  late final _chart_axis_set_interval_unit = _chart_axis_set_interval_unitPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the interval between category tick marks.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param unit The interval between the category ticks.
  ///
  /// Set the interval between the category tick marks. The default interval is 1
  /// between each category but it can be set to other integer values:
  ///
  /// @code
  /// chart_axis_set_interval_tick(chart->x_axis, 2);
  /// @endcode
  ///
  /// @image html chart_set_interval2.png
  ///
  /// **Axis types**: This function is applicable to category and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_interval_tick(
    ffi.Pointer<lxw_chart_axis> axis,
    int unit,
  ) {
    return _chart_axis_set_interval_tick(
      axis,
      unit,
    );
  }

  late final _chart_axis_set_interval_tickPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint16)>>('chart_axis_set_interval_tick');
  late final _chart_axis_set_interval_tick = _chart_axis_set_interval_tickPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the increment of the major units in the axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param unit The increment of the major units.
  ///
  /// Set the increment of the major units in the axis range.
  ///
  /// @code
  /// // Turn on the minor gridline (it is off by default).
  /// chart_axis_minor_gridlines_set_visible(chart->y_axis, LXW_TRUE);
  ///
  /// chart_axis_set_major_unit(chart->y_axis, 4);
  /// chart_axis_set_minor_unit(chart->y_axis, 2);
  /// @endcode
  ///
  /// @image html chart_set_major_units.png
  ///
  /// **Axis types**: This function is applicable to value and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_major_unit(
    ffi.Pointer<lxw_chart_axis> axis,
    double unit,
  ) {
    return _chart_axis_set_major_unit(
      axis,
      unit,
    );
  }

  late final _chart_axis_set_major_unitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Double)>>('chart_axis_set_major_unit');
  late final _chart_axis_set_major_unit = _chart_axis_set_major_unitPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, double)>();

  /// @brief Set the increment of the minor units in the axis.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param unit The increment of the minor units.
  ///
  /// Set the increment of the minor units in the axis range.
  ///
  /// @code
  /// chart_axis_set_minor_unit(chart->y_axis, 2);
  /// @endcode
  ///
  /// See the image above
  ///
  /// **Axis types**: This function is applicable to value and date axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_minor_unit(
    ffi.Pointer<lxw_chart_axis> axis,
    double unit,
  ) {
    return _chart_axis_set_minor_unit(
      axis,
      unit,
    );
  }

  late final _chart_axis_set_minor_unitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Double)>>('chart_axis_set_minor_unit');
  late final _chart_axis_set_minor_unit = _chart_axis_set_minor_unitPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, double)>();

  /// @brief Set the display units for a value axis.
  ///
  /// @param axis  A pointer to a chart #lxw_chart_axis object.
  /// @param units The display units: #lxw_chart_axis_display_unit.
  ///
  /// Set the display units for the axis. This can be useful if the axis numbers
  /// are very large but you don't want to represent them in scientific notation:
  ///
  /// @code
  /// chart_axis_set_display_units(chart->x_axis, LXW_CHART_AXIS_UNITS_THOUSANDS);
  /// chart_axis_set_display_units(chart->y_axis, LXW_CHART_AXIS_UNITS_MILLIONS);
  /// @endcode
  ///
  /// @image html chart_display_units.png
  ///
  /// **Axis types**: This function is applicable to value axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_display_units(
    ffi.Pointer<lxw_chart_axis> axis,
    int units,
  ) {
    return _chart_axis_set_display_units(
      axis,
      units,
    );
  }

  late final _chart_axis_set_display_unitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_display_units');
  late final _chart_axis_set_display_units = _chart_axis_set_display_unitsPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Turn on/off the display units for a value axis.
  ///
  /// @param axis    A pointer to a chart #lxw_chart_axis object.
  /// @param visible Turn off/on the display units. (0/1)
  ///
  /// Turn on or off the display units for the axis. This option is set on
  /// automatically by `chart_axis_set_display_units()`.
  ///
  /// @code
  /// chart_axis_set_display_units_visible(chart->y_axis, LXW_TRUE);
  /// @endcode
  ///
  /// **Axis types**: This function is applicable to value axes only.
  /// See @ref ww_charts_axes.
  void chart_axis_set_display_units_visible(
    ffi.Pointer<lxw_chart_axis> axis,
    int visible,
  ) {
    return _chart_axis_set_display_units_visible(
      axis,
      visible,
    );
  }

  late final _chart_axis_set_display_units_visiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_set_display_units_visible');
  late final _chart_axis_set_display_units_visible =
      _chart_axis_set_display_units_visiblePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Turn on/off the major gridlines for an axis.
  ///
  /// @param axis    A pointer to a chart #lxw_chart_axis object.
  /// @param visible Turn off/on the major gridline. (0/1)
  ///
  /// Turn on or off the major gridlines for an X or Y axis. In most Excel charts
  /// the Y axis major gridlines are on by default and the X axis major
  /// gridlines are off by default.
  ///
  /// Example:
  ///
  /// @code
  /// // Reverse the normal visible/hidden gridlines for a column chart.
  /// chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
  /// chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_FALSE);
  /// @endcode
  ///
  /// @image html chart_gridline1.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_major_gridlines_set_visible(
    ffi.Pointer<lxw_chart_axis> axis,
    int visible,
  ) {
    return _chart_axis_major_gridlines_set_visible(
      axis,
      visible,
    );
  }

  late final _chart_axis_major_gridlines_set_visiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_major_gridlines_set_visible');
  late final _chart_axis_major_gridlines_set_visible =
      _chart_axis_major_gridlines_set_visiblePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Turn on/off the minor gridlines for an axis.
  ///
  /// @param axis    A pointer to a chart #lxw_chart_axis object.
  /// @param visible Turn off/on the minor gridline. (0/1)
  ///
  /// Turn on or off the minor gridlines for an X or Y axis. In most Excel charts
  /// the X and Y axis minor gridlines are off by default.
  ///
  /// Example, turn on all major and minor gridlines:
  ///
  /// @code
  /// chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
  /// chart_axis_minor_gridlines_set_visible(chart->x_axis, LXW_TRUE);
  /// chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_TRUE);
  /// chart_axis_minor_gridlines_set_visible(chart->y_axis, LXW_TRUE);
  /// @endcode
  ///
  /// @image html chart_gridline2.png
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_minor_gridlines_set_visible(
    ffi.Pointer<lxw_chart_axis> axis,
    int visible,
  ) {
    return _chart_axis_minor_gridlines_set_visible(
      axis,
      visible,
    );
  }

  late final _chart_axis_minor_gridlines_set_visiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart_axis>,
              ffi.Uint8)>>('chart_axis_minor_gridlines_set_visible');
  late final _chart_axis_minor_gridlines_set_visible =
      _chart_axis_minor_gridlines_set_visiblePtr
          .asFunction<void Function(ffi.Pointer<lxw_chart_axis>, int)>();

  /// @brief Set the line properties for the chart axis major gridlines.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param line A #lxw_chart_line struct.
  ///
  /// Format the line properties of the major gridlines of a chart:
  ///
  /// @code
  /// lxw_chart_line line1 = {.color = LXW_COLOR_RED,
  /// .width = 0.5,
  /// .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
  ///
  /// lxw_chart_line line2 = {.color = LXW_COLOR_YELLOW};
  ///
  /// lxw_chart_line line3 = {.width = 1.25,
  /// .dash_type = LXW_CHART_LINE_DASH_DASH};
  ///
  /// lxw_chart_line line4 = {.color =  0x00B050};
  ///
  /// chart_axis_major_gridlines_set_line(chart->x_axis, &line1);
  /// chart_axis_minor_gridlines_set_line(chart->x_axis, &line2);
  /// chart_axis_major_gridlines_set_line(chart->y_axis, &line3);
  /// chart_axis_minor_gridlines_set_line(chart->y_axis, &line4);
  /// @endcode
  ///
  /// @image html chart_gridline3.png
  ///
  /// For more information see @ref chart_lines.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_major_gridlines_set_line(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_axis_major_gridlines_set_line(
      axis,
      line,
    );
  }

  late final _chart_axis_major_gridlines_set_linePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_line>)>>(
      'chart_axis_major_gridlines_set_line');
  late final _chart_axis_major_gridlines_set_line =
      _chart_axis_major_gridlines_set_linePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the line properties for the chart axis minor gridlines.
  ///
  /// @param axis A pointer to a chart #lxw_chart_axis object.
  /// @param line A #lxw_chart_line struct.
  ///
  /// Format the line properties of the minor gridlines of a chart, see the
  /// example above.
  ///
  /// For more information see @ref chart_lines.
  ///
  /// **Axis types**: This function is applicable to to all axes types.
  /// See @ref ww_charts_axes.
  void chart_axis_minor_gridlines_set_line(
    ffi.Pointer<lxw_chart_axis> axis,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_axis_minor_gridlines_set_line(
      axis,
      line,
    );
  }

  late final _chart_axis_minor_gridlines_set_linePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_line>)>>(
      'chart_axis_minor_gridlines_set_line');
  late final _chart_axis_minor_gridlines_set_line =
      _chart_axis_minor_gridlines_set_linePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart_axis>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the title of the chart.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param name  The chart title name.
  ///
  /// The `%chart_title_set_name()` function sets the name (title) for the
  /// chart. The name is displayed above the chart.
  ///
  /// @code
  /// chart_title_set_name(chart, "Year End Results");
  /// @endcode
  ///
  /// @image html chart_title_set_name.png
  ///
  /// The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
  /// a cell in the workbook that contains the name:
  ///
  /// @code
  /// chart_title_set_name(chart, "=Sheet1!$B$1");
  /// @endcode
  ///
  /// See also the `chart_title_set_name_range()` function to see how to set the
  /// name formula programmatically.
  ///
  /// The Excel default is to have no chart title.
  void chart_title_set_name(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _chart_title_set_name(
      chart,
      name,
    );
  }

  late final _chart_title_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<ffi.Char>)>>('chart_title_set_name');
  late final _chart_title_set_name = _chart_title_set_namePtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set a chart title formula using row and column values.
  ///
  /// @param chart     Pointer to a lxw_chart instance to be configured.
  /// @param sheetname The name of the worksheet that contains the cell range.
  /// @param row       The zero indexed row number of the range.
  /// @param col       The zero indexed column number of the range.
  ///
  /// The `%chart_title_set_name_range()` function can be used to set a chart
  /// title range and is an alternative to using `chart_title_set_name()` and a
  /// string formula:
  ///
  /// @code
  /// chart_title_set_name_range(chart, "Sheet1", 1, 0);
  /// @endcode
  void chart_title_set_name_range(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<ffi.Char> sheetname,
    int row,
    int col,
  ) {
    return _chart_title_set_name_range(
      chart,
      sheetname,
      row,
      col,
    );
  }

  late final _chart_title_set_name_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<ffi.Char>,
              lxw_row_t, lxw_col_t)>>('chart_title_set_name_range');
  late final _chart_title_set_name_range =
      _chart_title_set_name_rangePtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart>, ffi.Pointer<ffi.Char>, int, int)>();

  /// @brief  Set the font properties for a chart title.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param font  A pointer to a chart #lxw_chart_font font struct.
  ///
  /// The `%chart_title_set_name_font()` function is used to set the font of a
  /// chart title:
  ///
  /// @code
  /// lxw_chart_font font = {.color = LXW_COLOR_BLUE};
  ///
  /// chart_title_set_name(chart, "Year End Results");
  /// chart_title_set_name_font(chart, &font);
  /// @endcode
  ///
  /// @image html chart_title_set_name_font.png
  ///
  /// In Excel a chart title font is bold by default (as shown in the image
  /// above). To turn off bold in the font you cannot use #LXW_FALSE (0) since
  /// that is indistinguishable from an uninitialized value. Instead you should
  /// use #LXW_EXPLICIT_FALSE:
  ///
  /// @code
  /// lxw_chart_font font = {.bold = LXW_EXPLICIT_FALSE, .color = LXW_COLOR_BLUE};
  ///
  /// chart_title_set_name(chart, "Year End Results");
  /// chart_title_set_name_font(chart, &font);
  /// @endcode
  ///
  /// @image html chart_title_set_name_font2.png
  ///
  /// For more information see @ref chart_fonts.
  void chart_title_set_name_font(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_title_set_name_font(
      chart,
      font,
    );
  }

  late final _chart_title_set_name_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_font>)>>('chart_title_set_name_font');
  late final _chart_title_set_name_font =
      _chart_title_set_name_fontPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Turn off an automatic chart title.
  ///
  /// @param chart  Pointer to a lxw_chart instance to be configured.
  ///
  /// In general in Excel a chart title isn't displayed unless the user
  /// explicitly adds one. However, Excel adds an automatic chart title to charts
  /// with a single series and a user defined series name. The
  /// `chart_title_off()` function allows you to turn off this automatic chart
  /// title:
  ///
  /// @code
  /// chart_title_off(chart);
  /// @endcode
  void chart_title_off(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _chart_title_off(
      chart,
    );
  }

  late final _chart_title_offPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'chart_title_off');
  late final _chart_title_off =
      _chart_title_offPtr.asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  /// @brief Set the position of the chart legend.
  ///
  /// @param chart    Pointer to a lxw_chart instance to be configured.
  /// @param position The #lxw_chart_legend_position value for the legend.
  ///
  /// The `%chart_legend_set_position()` function is used to set the chart
  /// legend to one of the #lxw_chart_legend_position values:
  ///
  /// LXW_CHART_LEGEND_NONE
  /// LXW_CHART_LEGEND_RIGHT
  /// LXW_CHART_LEGEND_LEFT
  /// LXW_CHART_LEGEND_TOP
  /// LXW_CHART_LEGEND_BOTTOM
  /// LXW_CHART_LEGEND_TOP_RIGHT
  /// LXW_CHART_LEGEND_OVERLAY_RIGHT
  /// LXW_CHART_LEGEND_OVERLAY_LEFT
  /// LXW_CHART_LEGEND_OVERLAY_TOP_RIGHT
  ///
  /// For example:
  ///
  /// @code
  /// chart_legend_set_position(chart, LXW_CHART_LEGEND_BOTTOM);
  /// @endcode
  ///
  /// @image html chart_legend_bottom.png
  ///
  /// This function can also be used to turn off a chart legend:
  ///
  /// @code
  /// chart_legend_set_position(chart, LXW_CHART_LEGEND_NONE);
  /// @endcode
  ///
  /// @image html chart_legend_none.png
  void chart_legend_set_position(
    ffi.Pointer<lxw_chart> chart,
    int position,
  ) {
    return _chart_legend_set_position(
      chart,
      position,
    );
  }

  late final _chart_legend_set_positionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint8)>>('chart_legend_set_position');
  late final _chart_legend_set_position = _chart_legend_set_positionPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Set the font properties for a chart legend.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param font  A pointer to a chart #lxw_chart_font font struct.
  ///
  /// The `%chart_legend_set_font()` function is used to set the font of a
  /// chart legend:
  ///
  /// @code
  /// lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
  ///
  /// chart_legend_set_font(chart, &font);
  /// @endcode
  ///
  /// @image html chart_legend_set_font.png
  ///
  /// For more information see @ref chart_fonts.
  void chart_legend_set_font(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_legend_set_font(
      chart,
      font,
    );
  }

  late final _chart_legend_set_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_font>)>>('chart_legend_set_font');
  late final _chart_legend_set_font = _chart_legend_set_fontPtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Remove one or more series from the the legend.
  ///
  /// @param chart         Pointer to a lxw_chart instance to be configured.
  /// @param delete_series An array of zero-indexed values to delete from series.
  ///
  /// @return A #lxw_error.
  ///
  /// The `%chart_legend_delete_series()` function allows you to remove/hide one
  /// or more series in a chart legend (the series will still display on the chart).
  ///
  /// This function takes an array of one or more zero indexed series
  /// numbers. The array should be terminated with -1.
  ///
  /// For example to remove the first and third zero-indexed series from the
  /// legend of a chart with 3 series:
  ///
  /// @code
  /// int16_t series[] = {0, 2, -1};
  ///
  /// chart_legend_delete_series(chart, series);
  /// @endcode
  ///
  /// @image html chart_legend_delete.png
  int chart_legend_delete_series(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<ffi.Int16> delete_series,
  ) {
    return _chart_legend_delete_series(
      chart,
      delete_series,
    );
  }

  late final _chart_legend_delete_seriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<ffi.Int16>)>>('chart_legend_delete_series');
  late final _chart_legend_delete_series =
      _chart_legend_delete_seriesPtr.asFunction<
          int Function(ffi.Pointer<lxw_chart>, ffi.Pointer<ffi.Int16>)>();

  /// @brief Set the line properties for a chartarea.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param line  A #lxw_chart_line struct.
  ///
  /// Set the line/border properties of a chartarea. In Excel the chartarea
  /// is the background area behind the chart:
  ///
  /// @code
  /// lxw_chart_line line = {.none  = LXW_TRUE};
  /// lxw_chart_fill fill = {.color = LXW_COLOR_RED};
  ///
  /// chart_chartarea_set_line(chart, &line);
  /// chart_chartarea_set_fill(chart, &fill);
  /// @endcode
  ///
  /// @image html chart_chartarea.png
  ///
  /// For more information see @ref chart_lines.
  void chart_chartarea_set_line(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_chartarea_set_line(
      chart,
      line,
    );
  }

  late final _chart_chartarea_set_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>)>>('chart_chartarea_set_line');
  late final _chart_chartarea_set_line =
      _chart_chartarea_set_linePtr.asFunction<
          void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for a chartarea.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param fill  A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of a chartarea:
  ///
  /// @code
  /// chart_chartarea_set_fill(chart, &fill);
  /// @endcode
  ///
  /// See the example and image above.
  ///
  /// For more information see @ref chart_fills.
  void chart_chartarea_set_fill(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_chartarea_set_fill(
      chart,
      fill,
    );
  }

  late final _chart_chartarea_set_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_chartarea_set_fill');
  late final _chart_chartarea_set_fill =
      _chart_chartarea_set_fillPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Set the pattern properties for a chartarea.
  ///
  /// @param chart   Pointer to a lxw_chart instance to be configured.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of a chartarea:
  ///
  /// @code
  /// chart_chartarea_set_pattern(series1, &pattern);
  /// @endcode
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  void chart_chartarea_set_pattern(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_chartarea_set_pattern(
      chart,
      pattern,
    );
  }

  late final _chart_chartarea_set_patternPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_pattern>)>>('chart_chartarea_set_pattern');
  late final _chart_chartarea_set_pattern =
      _chart_chartarea_set_patternPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Set the line properties for a plotarea.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param line  A #lxw_chart_line struct.
  ///
  /// Set the line/border properties of a plotarea. In Excel the plotarea is
  /// the area between the axes on which the chart series are plotted:
  ///
  /// @code
  /// lxw_chart_line line = {.color     = LXW_COLOR_RED,
  /// .width     = 2,
  /// .dash_type = LXW_CHART_LINE_DASH_DASH};
  /// lxw_chart_fill fill = {.color     = 0xFFFFC2};
  ///
  /// chart_plotarea_set_line(chart, &line);
  /// chart_plotarea_set_fill(chart, &fill);
  ///
  /// @endcode
  ///
  /// @image html chart_plotarea.png
  ///
  /// For more information see @ref chart_lines.
  void chart_plotarea_set_line(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_plotarea_set_line(
      chart,
      line,
    );
  }

  late final _chart_plotarea_set_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>)>>('chart_plotarea_set_line');
  late final _chart_plotarea_set_line = _chart_plotarea_set_linePtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the fill properties for a plotarea.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param fill  A #lxw_chart_fill struct.
  ///
  /// Set the fill properties of a plotarea:
  ///
  /// @code
  /// chart_plotarea_set_fill(chart, &fill);
  /// @endcode
  ///
  /// See the example and image above.
  ///
  /// For more information see @ref chart_fills.
  void chart_plotarea_set_fill(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_fill> fill,
  ) {
    return _chart_plotarea_set_fill(
      chart,
      fill,
    );
  }

  late final _chart_plotarea_set_fillPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_plotarea_set_fill');
  late final _chart_plotarea_set_fill = _chart_plotarea_set_fillPtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Set the pattern properties for a plotarea.
  ///
  /// @param chart   Pointer to a lxw_chart instance to be configured.
  /// @param pattern A #lxw_chart_pattern struct.
  ///
  /// Set the pattern properties of a plotarea:
  ///
  /// @code
  /// chart_plotarea_set_pattern(series1, &pattern);
  /// @endcode
  ///
  /// For more information see #lxw_chart_pattern_type and @ref chart_patterns.
  void chart_plotarea_set_pattern(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_pattern> pattern,
  ) {
    return _chart_plotarea_set_pattern(
      chart,
      pattern,
    );
  }

  late final _chart_plotarea_set_patternPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_pattern>)>>('chart_plotarea_set_pattern');
  late final _chart_plotarea_set_pattern =
      _chart_plotarea_set_patternPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_pattern>)>();

  /// @brief Set the chart style type.
  ///
  /// @param chart    Pointer to a lxw_chart instance to be configured.
  /// @param style_id An index representing the chart style, 1 - 48.
  ///
  /// The `%chart_set_style()` function is used to set the style of the chart to
  /// one of the 48 built-in styles available on the "Design" tab in Excel 2007:
  ///
  /// @code
  /// chart_set_style(chart, 37)
  /// @endcode
  ///
  /// @image html chart_style.png
  ///
  /// The style index number is counted from 1 on the top left in the Excel
  /// dialog. The default style is 2.
  ///
  /// **Note:**
  ///
  /// In Excel 2013 the Styles section of the "Design" tab in Excel shows what
  /// were referred to as "Layouts" in previous versions of Excel. These layouts
  /// are not defined in the file format. They are a collection of modifications
  /// to the base chart type. They can not be defined by the `chart_set_style()``
  /// function.
  void chart_set_style(
    ffi.Pointer<lxw_chart> chart,
    int style_id,
  ) {
    return _chart_set_style(
      chart,
      style_id,
    );
  }

  late final _chart_set_stylePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint8)>>('chart_set_style');
  late final _chart_set_style = _chart_set_stylePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Turn on a data table below the horizontal axis.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  ///
  /// The `%chart_set_table()` function adds a data table below the horizontal
  /// axis with the data used to plot the chart:
  ///
  /// @code
  /// // Turn on the data table with default options.
  /// chart_set_table(chart);
  /// @endcode
  ///
  /// @image html chart_data_table1.png
  ///
  /// The data table can only be shown with Bar, Column, Line and Area charts.
  void chart_set_table(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _chart_set_table(
      chart,
    );
  }

  late final _chart_set_tablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'chart_set_table');
  late final _chart_set_table =
      _chart_set_tablePtr.asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  /// @brief Turn on/off grid options for a chart data table.
  ///
  /// @param chart       Pointer to a lxw_chart instance to be configured.
  /// @param horizontal  Turn on/off the horizontal grid lines in the table.
  /// @param vertical    Turn on/off the vertical grid lines in the table.
  /// @param outline     Turn on/off the outline lines in the table.
  /// @param legend_keys Turn on/off the legend keys in the table.
  ///
  /// The `%chart_set_table_grid()` function turns on/off grid options for a
  /// chart data table. The data table grid options in Excel are shown in the
  /// dialog below:
  ///
  /// @image html chart_data_table3.png
  ///
  /// These options can be passed to the `%chart_set_table_grid()` function.
  /// The values for a default chart are:
  ///
  /// - `horizontal`: On.
  /// - `vertical`: On.
  /// - `outline`:  On.
  /// - `legend_keys`: Off.
  ///
  /// Example:
  ///
  /// @code
  /// // Turn on the data table with default options.
  /// chart_set_table(chart);
  ///
  /// // Turn on all grid lines and the grid legend.
  /// chart_set_table_grid(chart, LXW_TRUE, LXW_TRUE, LXW_TRUE, LXW_TRUE);
  ///
  /// // Turn off the legend since it is show in the table.
  /// chart_legend_set_position(chart, LXW_CHART_LEGEND_NONE);
  ///
  /// @endcode
  ///
  /// @image html chart_data_table2.png
  ///
  /// The data table can only be shown with Bar, Column, Line and Area charts.
  void chart_set_table_grid(
    ffi.Pointer<lxw_chart> chart,
    int horizontal,
    int vertical,
    int outline,
    int legend_keys,
  ) {
    return _chart_set_table_grid(
      chart,
      horizontal,
      vertical,
      outline,
      legend_keys,
    );
  }

  late final _chart_set_table_gridPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>, ffi.Uint8, ffi.Uint8,
              ffi.Uint8, ffi.Uint8)>>('chart_set_table_grid');
  late final _chart_set_table_grid = _chart_set_table_gridPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int, int, int, int)>();

  void chart_set_table_font(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_font> font,
  ) {
    return _chart_set_table_font(
      chart,
      font,
    );
  }

  late final _chart_set_table_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_font>)>>('chart_set_table_font');
  late final _chart_set_table_font = _chart_set_table_fontPtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_font>)>();

  /// @brief Turn on up-down bars for the chart.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  ///
  /// The `%chart_set_up_down_bars()` function adds Up-Down bars to Line charts
  /// to indicate the difference between the first and last data series:
  ///
  /// @code
  /// chart_set_up_down_bars(chart);
  /// @endcode
  ///
  /// @image html chart_data_tools4.png
  ///
  /// Up-Down bars are only available in Line charts. By default Up-Down bars are
  /// black and white like in the above example. To format the border or fill
  /// of the bars see the `chart_set_up_down_bars_format()` function below.
  void chart_set_up_down_bars(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _chart_set_up_down_bars(
      chart,
    );
  }

  late final _chart_set_up_down_barsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'chart_set_up_down_bars');
  late final _chart_set_up_down_bars = _chart_set_up_down_barsPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  /// @brief Turn on up-down bars for the chart, with formatting.
  ///
  /// @param chart         Pointer to a lxw_chart instance to be configured.
  /// @param up_bar_line   A #lxw_chart_line struct for the up-bar border.
  /// @param up_bar_fill   A #lxw_chart_fill struct for the up-bar fill.
  /// @param down_bar_line A #lxw_chart_line struct for the down-bar border.
  /// @param down_bar_fill A #lxw_chart_fill struct for the down-bar fill.
  ///
  /// The `%chart_set_up_down_bars_format()` function adds Up-Down bars to Line
  /// charts to indicate the difference between the first and last data series.
  /// It also allows the up and down bars to be formatted:
  ///
  /// @code
  /// lxw_chart_line line      = {.color = LXW_COLOR_BLACK};
  /// lxw_chart_fill up_fill   = {.color = 0x00B050};
  /// lxw_chart_fill down_fill = {.color = LXW_COLOR_RED};
  ///
  /// chart_set_up_down_bars_format(chart, &line, &up_fill, &line, &down_fill);
  /// @endcode
  ///
  /// @image html chart_up_down_bars.png
  ///
  /// Up-Down bars are only available in Line charts.
  /// For more format information  see @ref chart_lines and @ref chart_fills.
  void chart_set_up_down_bars_format(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_line> up_bar_line,
    ffi.Pointer<lxw_chart_fill> up_bar_fill,
    ffi.Pointer<lxw_chart_line> down_bar_line,
    ffi.Pointer<lxw_chart_fill> down_bar_fill,
  ) {
    return _chart_set_up_down_bars_format(
      chart,
      up_bar_line,
      up_bar_fill,
      down_bar_line,
      down_bar_fill,
    );
  }

  late final _chart_set_up_down_bars_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>,
              ffi.Pointer<lxw_chart_fill>,
              ffi.Pointer<lxw_chart_line>,
              ffi.Pointer<lxw_chart_fill>)>>('chart_set_up_down_bars_format');
  late final _chart_set_up_down_bars_format =
      _chart_set_up_down_bars_formatPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>,
              ffi.Pointer<lxw_chart_fill>,
              ffi.Pointer<lxw_chart_line>,
              ffi.Pointer<lxw_chart_fill>)>();

  /// @brief Turn on and format Drop Lines for a chart.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param line  A #lxw_chart_line struct.
  ///
  /// The `%chart_set_drop_lines()` function adds Drop Lines to charts to
  /// show the Category value of points in the data:
  ///
  /// @code
  /// chart_set_drop_lines(chart, NULL);
  /// @endcode
  ///
  /// @image html chart_data_tools6.png
  ///
  /// It is possible to format the Drop Line line properties if required:
  ///
  /// @code
  /// lxw_chart_line line = {.color     = LXW_COLOR_RED,
  /// .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
  ///
  /// chart_set_drop_lines(chart, &line);
  /// @endcode
  ///
  /// Drop Lines are only available in Line and Area charts.
  /// For more format information see @ref chart_lines.
  void chart_set_drop_lines(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_set_drop_lines(
      chart,
      line,
    );
  }

  late final _chart_set_drop_linesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>)>>('chart_set_drop_lines');
  late final _chart_set_drop_lines = _chart_set_drop_linesPtr.asFunction<
      void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Turn on and format high-low Lines for a chart.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param line  A #lxw_chart_line struct.
  ///
  /// The `%chart_set_high_low_lines()` function adds High-Low Lines to charts
  /// to show the Category value of points in the data:
  ///
  /// @code
  /// chart_set_high_low_lines(chart, NULL);
  /// @endcode
  ///
  /// @image html chart_data_tools5.png
  ///
  /// It is possible to format the High-Low Line line properties if required:
  ///
  /// @code
  /// lxw_chart_line line = {.color     = LXW_COLOR_RED,
  /// .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
  ///
  /// chart_set_high_low_lines(chart, &line);
  /// @endcode
  ///
  /// High-Low Lines are only available in Line charts.
  /// For more format information see @ref chart_lines.
  void chart_set_high_low_lines(
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_line> line,
  ) {
    return _chart_set_high_low_lines(
      chart,
      line,
    );
  }

  late final _chart_set_high_low_linesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_line>)>>('chart_set_high_low_lines');
  late final _chart_set_high_low_lines =
      _chart_set_high_low_linesPtr.asFunction<
          void Function(ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_line>)>();

  /// @brief Set the overlap between series in a Bar/Column chart.
  ///
  /// @param chart   Pointer to a lxw_chart instance to be configured.
  /// @param overlap The overlap between the series. -100 to 100.
  ///
  /// The `%chart_set_series_overlap()` function sets the overlap between series
  /// in Bar and Column charts.
  ///
  /// @code
  /// chart_set_series_overlap(chart, -50);
  /// @endcode
  ///
  /// @image html chart_overlap.png
  ///
  /// The overlap value must be in the range `0 <= overlap <= 500`.
  /// The default value is 0.
  ///
  /// This option is only available for Bar/Column charts.
  void chart_set_series_overlap(
    ffi.Pointer<lxw_chart> chart,
    int overlap,
  ) {
    return _chart_set_series_overlap(
      chart,
      overlap,
    );
  }

  late final _chart_set_series_overlapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Int8)>>('chart_set_series_overlap');
  late final _chart_set_series_overlap = _chart_set_series_overlapPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Set the gap between series in a Bar/Column chart.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param gap   The gap between the series.  0 to 500.
  ///
  /// The `%chart_set_series_gap()` function sets the gap between series in
  /// Bar and Column charts.
  ///
  /// @code
  /// chart_set_series_gap(chart, 400);
  /// @endcode
  ///
  /// @image html chart_gap.png
  ///
  /// The gap value must be in the range `0 <= gap <= 500`. The default value
  /// is 150.
  ///
  /// This option is only available for Bar/Column charts.
  void chart_set_series_gap(
    ffi.Pointer<lxw_chart> chart,
    int gap,
  ) {
    return _chart_set_series_gap(
      chart,
      gap,
    );
  }

  late final _chart_set_series_gapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint16)>>('chart_set_series_gap');
  late final _chart_set_series_gap = _chart_set_series_gapPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Set the option for displaying blank data in a chart.
  ///
  /// @param chart    Pointer to a lxw_chart instance to be configured.
  /// @param option The display option. A #lxw_chart_blank option.
  ///
  /// The `%chart_show_blanks_as()` function controls how blank data is displayed
  /// in a chart:
  ///
  /// @code
  /// chart_show_blanks_as(chart, LXW_CHART_BLANKS_AS_CONNECTED);
  /// @endcode
  ///
  /// The `option` parameter can have one of the following values:
  ///
  /// - #LXW_CHART_BLANKS_AS_GAP: Show empty chart cells as gaps in the data.
  /// This is the default option for Excel charts.
  /// - #LXW_CHART_BLANKS_AS_ZERO: Show empty chart cells as zeros.
  /// - #LXW_CHART_BLANKS_AS_CONNECTED: Show empty chart cells as connected.
  /// Only for charts with lines.
  void chart_show_blanks_as(
    ffi.Pointer<lxw_chart> chart,
    int option,
  ) {
    return _chart_show_blanks_as(
      chart,
      option,
    );
  }

  late final _chart_show_blanks_asPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint8)>>('chart_show_blanks_as');
  late final _chart_show_blanks_as = _chart_show_blanks_asPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Display data on charts from hidden rows or columns.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  ///
  /// Display data that is in hidden rows or columns on the chart:
  ///
  /// @code
  /// chart_show_hidden_data(chart);
  /// @endcode
  void chart_show_hidden_data(
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _chart_show_hidden_data(
      chart,
    );
  }

  late final _chart_show_hidden_dataPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>(
          'chart_show_hidden_data');
  late final _chart_show_hidden_data = _chart_show_hidden_dataPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>)>();

  /// @brief Set the Pie/Doughnut chart rotation.
  ///
  /// @param chart    Pointer to a lxw_chart instance to be configured.
  /// @param rotation The angle of rotation.
  ///
  /// The `chart_set_rotation()` function is used to set the rotation of the
  /// first segment of a Pie/Doughnut chart. This has the effect of rotating
  /// the entire chart:
  ///
  /// @code
  /// chart_set_rotation(chart, 28);
  /// @endcode
  ///
  /// The angle of rotation must be in the range `0 <= rotation <= 360`.
  ///
  /// This option is only available for Pie/Doughnut charts.
  void chart_set_rotation(
    ffi.Pointer<lxw_chart> chart,
    int rotation,
  ) {
    return _chart_set_rotation(
      chart,
      rotation,
    );
  }

  late final _chart_set_rotationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint16)>>('chart_set_rotation');
  late final _chart_set_rotation = _chart_set_rotationPtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  /// @brief Set the Doughnut chart hole size.
  ///
  /// @param chart Pointer to a lxw_chart instance to be configured.
  /// @param size  The hole size as a percentage.
  ///
  /// The `chart_set_hole_size()` function is used to set the hole size of a
  /// Doughnut chart:
  ///
  /// @code
  /// chart_set_hole_size(chart, 33);
  /// @endcode
  ///
  /// The hole size must be in the range `10 <= size <= 90`.
  ///
  /// This option is only available for Doughnut charts.
  void chart_set_hole_size(
    ffi.Pointer<lxw_chart> chart,
    int size,
  ) {
    return _chart_set_hole_size(
      chart,
      size,
    );
  }

  late final _chart_set_hole_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chart>, ffi.Uint8)>>('chart_set_hole_size');
  late final _chart_set_hole_size = _chart_set_hole_sizePtr
      .asFunction<void Function(ffi.Pointer<lxw_chart>, int)>();

  int lxw_chart_add_data_cache(
    ffi.Pointer<lxw_series_range> range,
    ffi.Pointer<ffi.Uint8> data,
    int rows,
    int cols,
    int col,
  ) {
    return _lxw_chart_add_data_cache(
      range,
      data,
      rows,
      cols,
      col,
    );
  }

  late final _lxw_chart_add_data_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_series_range>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Uint16,
              ffi.Uint8,
              ffi.Uint8)>>('lxw_chart_add_data_cache');
  late final _lxw_chart_add_data_cache =
      _lxw_chart_add_data_cachePtr.asFunction<
          int Function(ffi.Pointer<lxw_series_range>, ffi.Pointer<ffi.Uint8>,
              int, int, int)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_drawing> lxw_drawing_new() {
    return _lxw_drawing_new();
  }

  late final _lxw_drawing_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_drawing> Function()>>(
          'lxw_drawing_new');
  late final _lxw_drawing_new =
      _lxw_drawing_newPtr.asFunction<ffi.Pointer<lxw_drawing> Function()>();

  void lxw_drawing_free(
    ffi.Pointer<lxw_drawing> drawing,
  ) {
    return _lxw_drawing_free(
      drawing,
    );
  }

  late final _lxw_drawing_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_drawing>)>>(
          'lxw_drawing_free');
  late final _lxw_drawing_free = _lxw_drawing_freePtr
      .asFunction<void Function(ffi.Pointer<lxw_drawing>)>();

  void lxw_drawing_assemble_xml_file(
    ffi.Pointer<lxw_drawing> self,
  ) {
    return _lxw_drawing_assemble_xml_file(
      self,
    );
  }

  late final _lxw_drawing_assemble_xml_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_drawing>)>>(
          'lxw_drawing_assemble_xml_file');
  late final _lxw_drawing_assemble_xml_file = _lxw_drawing_assemble_xml_filePtr
      .asFunction<void Function(ffi.Pointer<lxw_drawing>)>();

  void lxw_free_drawing_object(
    ffi.Pointer<lxw_drawing_object> drawing_object,
  ) {
    return _lxw_free_drawing_object(
      drawing_object,
    );
  }

  late final _lxw_free_drawing_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_drawing_object>)>>('lxw_free_drawing_object');
  late final _lxw_free_drawing_object = _lxw_free_drawing_objectPtr
      .asFunction<void Function(ffi.Pointer<lxw_drawing_object>)>();

  void lxw_add_drawing_object(
    ffi.Pointer<lxw_drawing> drawing,
    ffi.Pointer<lxw_drawing_object> drawing_object,
  ) {
    return _lxw_add_drawing_object(
      drawing,
      drawing_object,
    );
  }

  late final _lxw_add_drawing_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_drawing>,
              ffi.Pointer<lxw_drawing_object>)>>('lxw_add_drawing_object');
  late final _lxw_add_drawing_object = _lxw_add_drawing_objectPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_drawing>, ffi.Pointer<lxw_drawing_object>)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_styles> lxw_styles_new() {
    return _lxw_styles_new();
  }

  late final _lxw_styles_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_styles> Function()>>(
          'lxw_styles_new');
  late final _lxw_styles_new =
      _lxw_styles_newPtr.asFunction<ffi.Pointer<lxw_styles> Function()>();

  void lxw_styles_free(
    ffi.Pointer<lxw_styles> styles,
  ) {
    return _lxw_styles_free(
      styles,
    );
  }

  late final _lxw_styles_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_styles>)>>(
          'lxw_styles_free');
  late final _lxw_styles_free =
      _lxw_styles_freePtr.asFunction<void Function(ffi.Pointer<lxw_styles>)>();

  void lxw_styles_assemble_xml_file(
    ffi.Pointer<lxw_styles> self,
  ) {
    return _lxw_styles_assemble_xml_file(
      self,
    );
  }

  late final _lxw_styles_assemble_xml_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_styles>)>>(
          'lxw_styles_assemble_xml_file');
  late final _lxw_styles_assemble_xml_file = _lxw_styles_assemble_xml_filePtr
      .asFunction<void Function(ffi.Pointer<lxw_styles>)>();

  void lxw_styles_write_string_fragment(
    ffi.Pointer<lxw_styles> self,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _lxw_styles_write_string_fragment(
      self,
      string,
    );
  }

  late final _lxw_styles_write_string_fragmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_styles>,
              ffi.Pointer<ffi.Char>)>>('lxw_styles_write_string_fragment');
  late final _lxw_styles_write_string_fragment =
      _lxw_styles_write_string_fragmentPtr.asFunction<
          void Function(ffi.Pointer<lxw_styles>, ffi.Pointer<ffi.Char>)>();

  void lxw_styles_write_rich_font(
    ffi.Pointer<lxw_styles> styles,
    ffi.Pointer<lxw_format> format,
  ) {
    return _lxw_styles_write_rich_font(
      styles,
      format,
    );
  }

  late final _lxw_styles_write_rich_fontPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_styles>,
              ffi.Pointer<lxw_format>)>>('lxw_styles_write_rich_font');
  late final _lxw_styles_write_rich_font =
      _lxw_styles_write_rich_fontPtr.asFunction<
          void Function(ffi.Pointer<lxw_styles>, ffi.Pointer<lxw_format>)>();

  /// Create a new attribute struct to add to a xml_attribute_list.
  ffi.Pointer<xml_attribute> lxw_new_attribute_str(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _lxw_new_attribute_str(
      key,
      value,
    );
  }

  late final _lxw_new_attribute_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<xml_attribute> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lxw_new_attribute_str');
  late final _lxw_new_attribute_str = _lxw_new_attribute_strPtr.asFunction<
      ffi.Pointer<xml_attribute> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<xml_attribute> lxw_new_attribute_int(
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _lxw_new_attribute_int(
      key,
      value,
    );
  }

  late final _lxw_new_attribute_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<xml_attribute> Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('lxw_new_attribute_int');
  late final _lxw_new_attribute_int = _lxw_new_attribute_intPtr.asFunction<
      ffi.Pointer<xml_attribute> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<xml_attribute> lxw_new_attribute_dbl(
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _lxw_new_attribute_dbl(
      key,
      value,
    );
  }

  late final _lxw_new_attribute_dblPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<xml_attribute> Function(
              ffi.Pointer<ffi.Char>, ffi.Double)>>('lxw_new_attribute_dbl');
  late final _lxw_new_attribute_dbl = _lxw_new_attribute_dblPtr.asFunction<
      ffi.Pointer<xml_attribute> Function(ffi.Pointer<ffi.Char>, double)>();

  /// Create the XML declaration in an XML file.
  ///
  /// @param xmlfile A FILE pointer to the output XML file.
  void lxw_xml_declaration(
    ffi.Pointer<FILE> xmlfile,
  ) {
    return _lxw_xml_declaration(
      xmlfile,
    );
  }

  late final _lxw_xml_declarationPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'lxw_xml_declaration');
  late final _lxw_xml_declaration =
      _lxw_xml_declarationPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  /// Write an XML start tag with optional attributes.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  /// @param attributes An optional list of attributes to add to the tag.
  void lxw_xml_start_tag(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
    ffi.Pointer<xml_attribute_list> attributes,
  ) {
    return _lxw_xml_start_tag(
      xmlfile,
      tag,
      attributes,
    );
  }

  late final _lxw_xml_start_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>>('lxw_xml_start_tag');
  late final _lxw_xml_start_tag = _lxw_xml_start_tagPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<xml_attribute_list>)>();

  /// Write an XML start tag with optional un-encoded attributes.
  /// This is a minor optimization for attributes that don't need encoding.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  /// @param attributes An optional list of attributes to add to the tag.
  void lxw_xml_start_tag_unencoded(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
    ffi.Pointer<xml_attribute_list> attributes,
  ) {
    return _lxw_xml_start_tag_unencoded(
      xmlfile,
      tag,
      attributes,
    );
  }

  late final _lxw_xml_start_tag_unencodedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>>('lxw_xml_start_tag_unencoded');
  late final _lxw_xml_start_tag_unencoded =
      _lxw_xml_start_tag_unencodedPtr.asFunction<
          void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>();

  /// Write an XML end tag.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  void lxw_xml_end_tag(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
  ) {
    return _lxw_xml_end_tag(
      xmlfile,
      tag,
    );
  }

  late final _lxw_xml_end_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('lxw_xml_end_tag');
  late final _lxw_xml_end_tag = _lxw_xml_end_tagPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  /// Write an XML empty tag with optional attributes.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  /// @param attributes An optional list of attributes to add to the tag.
  void lxw_xml_empty_tag(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
    ffi.Pointer<xml_attribute_list> attributes,
  ) {
    return _lxw_xml_empty_tag(
      xmlfile,
      tag,
      attributes,
    );
  }

  late final _lxw_xml_empty_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>>('lxw_xml_empty_tag');
  late final _lxw_xml_empty_tag = _lxw_xml_empty_tagPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<xml_attribute_list>)>();

  /// Write an XML empty tag with optional un-encoded attributes.
  /// This is a minor optimization for attributes that don't need encoding.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  /// @param attributes An optional list of attributes to add to the tag.
  void lxw_xml_empty_tag_unencoded(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
    ffi.Pointer<xml_attribute_list> attributes,
  ) {
    return _lxw_xml_empty_tag_unencoded(
      xmlfile,
      tag,
      attributes,
    );
  }

  late final _lxw_xml_empty_tag_unencodedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>>('lxw_xml_empty_tag_unencoded');
  late final _lxw_xml_empty_tag_unencoded =
      _lxw_xml_empty_tag_unencodedPtr.asFunction<
          void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>();

  /// Write an XML element containing data and optional attributes.
  ///
  /// @param xmlfile    A FILE pointer to the output XML file.
  /// @param tag        The XML tag to write.
  /// @param data       The data section of the XML element.
  /// @param attributes An optional list of attributes to add to the tag.
  void lxw_xml_data_element(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> tag,
    ffi.Pointer<ffi.Char> data,
    ffi.Pointer<xml_attribute_list> attributes,
  ) {
    return _lxw_xml_data_element(
      xmlfile,
      tag,
      data,
      attributes,
    );
  }

  late final _lxw_xml_data_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<xml_attribute_list>)>>('lxw_xml_data_element');
  late final _lxw_xml_data_element = _lxw_xml_data_elementPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<xml_attribute_list>)>();

  void lxw_xml_rich_si_element(
    ffi.Pointer<FILE> xmlfile,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _lxw_xml_rich_si_element(
      xmlfile,
      string,
    );
  }

  late final _lxw_xml_rich_si_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>)>>('lxw_xml_rich_si_element');
  late final _lxw_xml_rich_si_element = _lxw_xml_rich_si_elementPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int lxw_has_control_characters(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _lxw_has_control_characters(
      string,
    );
  }

  late final _lxw_has_control_charactersPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_has_control_characters');
  late final _lxw_has_control_characters = _lxw_has_control_charactersPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> lxw_escape_control_characters(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _lxw_escape_control_characters(
      string,
    );
  }

  late final _lxw_escape_control_charactersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('lxw_escape_control_characters');
  late final _lxw_escape_control_characters = _lxw_escape_control_charactersPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> lxw_escape_url_characters(
    ffi.Pointer<ffi.Char> string,
    int escape_hash,
  ) {
    return _lxw_escape_url_characters(
      string,
      escape_hash,
    );
  }

  late final _lxw_escape_url_charactersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Uint8)>>('lxw_escape_url_characters');
  late final _lxw_escape_url_characters = _lxw_escape_url_charactersPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> lxw_escape_data(
    ffi.Pointer<ffi.Char> data,
  ) {
    return _lxw_escape_data(
      data,
    );
  }

  late final _lxw_escape_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('lxw_escape_data');
  late final _lxw_escape_data = _lxw_escape_dataPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Retrieve the library version.
  ///
  /// @return The "X.Y.Z" version string.
  ///
  /// Get the library version as a "X.Y.Z" version string
  ///
  /// @code
  /// printf("Libxlsxwriter version = %s\n", lxw_version());
  /// @endcode
  ffi.Pointer<ffi.Char> lxw_version() {
    return _lxw_version();
  }

  late final _lxw_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'lxw_version');
  late final _lxw_version =
      _lxw_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// @brief Retrieve the library version ID.
  ///
  /// @return The version ID.
  ///
  /// Get the library version such as "X.Y.Z" as a XYZ integer.
  ///
  /// @code
  /// printf("Libxlsxwriter version id = %d\n", lxw_version_id());
  /// @endcode
  int lxw_version_id() {
    return _lxw_version_id();
  }

  late final _lxw_version_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function()>>('lxw_version_id');
  late final _lxw_version_id = _lxw_version_idPtr.asFunction<int Function()>();

  /// @brief Converts a libxlsxwriter error number to a string.
  ///
  /// The `%lxw_strerror` function converts a libxlsxwriter error number defined
  /// by #lxw_error to a pointer to a string description of the error.
  /// Similar to the standard library strerror(3) function.
  ///
  /// For example:
  ///
  /// @code
  /// lxw_error error = workbook_close(workbook);
  ///
  /// if (error)
  /// printf("Error in workbook_close().\n"
  /// "Error %d = %s\n", error, lxw_strerror(error));
  /// @endcode
  ///
  /// This would produce output like the following if the target file wasn't
  /// writable:
  ///
  /// Error in workbook_close().
  /// Error 2 = Error creating output xlsx file. Usually a permissions error.
  ///
  /// @param error_num The error number returned by a libxlsxwriter function.
  ///
  /// @return A pointer to a statically allocated string. Do not free.
  ffi.Pointer<ffi.Char> lxw_strerror(
    int error_num,
  ) {
    return _lxw_strerror(
      error_num,
    );
  }

  late final _lxw_strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'lxw_strerror');
  late final _lxw_strerror =
      _lxw_strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Create a quoted version of the worksheet name
  ffi.Pointer<ffi.Char> lxw_quote_sheetname(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _lxw_quote_sheetname(
      str,
    );
  }

  late final _lxw_quote_sheetnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('lxw_quote_sheetname');
  late final _lxw_quote_sheetname = _lxw_quote_sheetnamePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void lxw_col_to_name(
    ffi.Pointer<ffi.Char> col_name,
    int col_num,
    int absolute,
  ) {
    return _lxw_col_to_name(
      col_name,
      col_num,
      absolute,
    );
  }

  late final _lxw_col_to_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, lxw_col_t, ffi.Uint8)>>('lxw_col_to_name');
  late final _lxw_col_to_name = _lxw_col_to_namePtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int, int)>();

  void lxw_rowcol_to_cell(
    ffi.Pointer<ffi.Char> cell_name,
    int row,
    int col,
  ) {
    return _lxw_rowcol_to_cell(
      cell_name,
      row,
      col,
    );
  }

  late final _lxw_rowcol_to_cellPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, lxw_row_t,
              lxw_col_t)>>('lxw_rowcol_to_cell');
  late final _lxw_rowcol_to_cell = _lxw_rowcol_to_cellPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int, int)>();

  void lxw_rowcol_to_cell_abs(
    ffi.Pointer<ffi.Char> cell_name,
    int row,
    int col,
    int abs_row,
    int abs_col,
  ) {
    return _lxw_rowcol_to_cell_abs(
      cell_name,
      row,
      col,
      abs_row,
      abs_col,
    );
  }

  late final _lxw_rowcol_to_cell_absPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, lxw_row_t, lxw_col_t,
              ffi.Uint8, ffi.Uint8)>>('lxw_rowcol_to_cell_abs');
  late final _lxw_rowcol_to_cell_abs = _lxw_rowcol_to_cell_absPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int, int, int, int)>();

  void lxw_rowcol_to_range(
    ffi.Pointer<ffi.Char> range,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _lxw_rowcol_to_range(
      range,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _lxw_rowcol_to_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t)>>('lxw_rowcol_to_range');
  late final _lxw_rowcol_to_range = _lxw_rowcol_to_rangePtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int, int, int, int)>();

  void lxw_rowcol_to_range_abs(
    ffi.Pointer<ffi.Char> range,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _lxw_rowcol_to_range_abs(
      range,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _lxw_rowcol_to_range_absPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t)>>('lxw_rowcol_to_range_abs');
  late final _lxw_rowcol_to_range_abs = _lxw_rowcol_to_range_absPtr
      .asFunction<void Function(ffi.Pointer<ffi.Char>, int, int, int, int)>();

  void lxw_rowcol_to_formula_abs(
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<ffi.Char> sheetname,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _lxw_rowcol_to_formula_abs(
      formula,
      sheetname,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _lxw_rowcol_to_formula_absPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t)>>('lxw_rowcol_to_formula_abs');
  late final _lxw_rowcol_to_formula_abs =
      _lxw_rowcol_to_formula_absPtr.asFunction<
          void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int,
              int, int)>();

  int lxw_name_to_row(
    ffi.Pointer<ffi.Char> row_str,
  ) {
    return _lxw_name_to_row(
      row_str,
    );
  }

  late final _lxw_name_to_rowPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_name_to_row');
  late final _lxw_name_to_row =
      _lxw_name_to_rowPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int lxw_name_to_col(
    ffi.Pointer<ffi.Char> col_str,
  ) {
    return _lxw_name_to_col(
      col_str,
    );
  }

  late final _lxw_name_to_colPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_name_to_col');
  late final _lxw_name_to_col =
      _lxw_name_to_colPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int lxw_name_to_row_2(
    ffi.Pointer<ffi.Char> row_str,
  ) {
    return _lxw_name_to_row_2(
      row_str,
    );
  }

  late final _lxw_name_to_row_2Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_name_to_row_2');
  late final _lxw_name_to_row_2 =
      _lxw_name_to_row_2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int lxw_name_to_col_2(
    ffi.Pointer<ffi.Char> col_str,
  ) {
    return _lxw_name_to_col_2(
      col_str,
    );
  }

  late final _lxw_name_to_col_2Ptr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_name_to_col_2');
  late final _lxw_name_to_col_2 =
      _lxw_name_to_col_2Ptr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Converts a #lxw_datetime to an Excel datetime number.
  ///
  /// @param datetime A pointer to a #lxw_datetime struct.
  ///
  /// @return A double representing an Excel datetime.
  ///
  /// The `%lxw_datetime_to_excel_datetime()` function converts a datetime in
  /// #lxw_datetime to an Excel datetime number:
  ///
  /// @code
  /// lxw_datetime datetime = {2013, 2, 28, 12, 0, 0.0};
  ///
  /// double excel_datetime = lxw_datetime_to_excel_date(&datetime);
  /// @endcode
  ///
  /// See @ref working_with_dates for more details on the Excel datetime format.
  double lxw_datetime_to_excel_datetime(
    ffi.Pointer<lxw_datetime> datetime,
  ) {
    return _lxw_datetime_to_excel_datetime(
      datetime,
    );
  }

  late final _lxw_datetime_to_excel_datetimePtr = _lookup<
          ffi.NativeFunction<ffi.Double Function(ffi.Pointer<lxw_datetime>)>>(
      'lxw_datetime_to_excel_datetime');
  late final _lxw_datetime_to_excel_datetime =
      _lxw_datetime_to_excel_datetimePtr
          .asFunction<double Function(ffi.Pointer<lxw_datetime>)>();

  double lxw_datetime_to_excel_date_epoch(
    ffi.Pointer<lxw_datetime> datetime,
    int date_1904,
  ) {
    return _lxw_datetime_to_excel_date_epoch(
      datetime,
      date_1904,
    );
  }

  late final _lxw_datetime_to_excel_date_epochPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<lxw_datetime>,
              ffi.Uint8)>>('lxw_datetime_to_excel_date_epoch');
  late final _lxw_datetime_to_excel_date_epoch =
      _lxw_datetime_to_excel_date_epochPtr
          .asFunction<double Function(ffi.Pointer<lxw_datetime>, int)>();

  /// @brief Converts a unix datetime to an Excel datetime number.
  ///
  /// @param unixtime Unix time (seconds since 1970-01-01)
  ///
  /// @return A double representing an Excel datetime.
  ///
  /// The `%lxw_unixtime_to_excel_date()` function converts a unix datetime to
  /// an Excel datetime number:
  ///
  /// @code
  /// double excel_datetime = lxw_unixtime_to_excel_date(946684800);
  /// @endcode
  ///
  /// See @ref working_with_dates for more details.
  double lxw_unixtime_to_excel_date(
    int unixtime,
  ) {
    return _lxw_unixtime_to_excel_date(
      unixtime,
    );
  }

  late final _lxw_unixtime_to_excel_datePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int64)>>(
          'lxw_unixtime_to_excel_date');
  late final _lxw_unixtime_to_excel_date =
      _lxw_unixtime_to_excel_datePtr.asFunction<double Function(int)>();

  double lxw_unixtime_to_excel_date_epoch(
    int unixtime,
    int date_1904,
  ) {
    return _lxw_unixtime_to_excel_date_epoch(
      unixtime,
      date_1904,
    );
  }

  late final _lxw_unixtime_to_excel_date_epochPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int64, ffi.Uint8)>>(
          'lxw_unixtime_to_excel_date_epoch');
  late final _lxw_unixtime_to_excel_date_epoch =
      _lxw_unixtime_to_excel_date_epochPtr
          .asFunction<double Function(int, int)>();

  ffi.Pointer<ffi.Char> lxw_strdup(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _lxw_strdup(
      str,
    );
  }

  late final _lxw_strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('lxw_strdup');
  late final _lxw_strdup = _lxw_strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> lxw_strdup_formula(
    ffi.Pointer<ffi.Char> formula,
  ) {
    return _lxw_strdup_formula(
      formula,
    );
  }

  late final _lxw_strdup_formulaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('lxw_strdup_formula');
  late final _lxw_strdup_formula = _lxw_strdup_formulaPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int lxw_utf8_strlen(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _lxw_utf8_strlen(
      str,
    );
  }

  late final _lxw_utf8_strlenPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_utf8_strlen');
  late final _lxw_utf8_strlen =
      _lxw_utf8_strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void lxw_str_tolower(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _lxw_str_tolower(
      str,
    );
  }

  late final _lxw_str_tolowerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_str_tolower');
  late final _lxw_str_tolower =
      _lxw_str_tolowerPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> lxw_tmpfile(
    ffi.Pointer<ffi.Char> tmpdir,
  ) {
    return _lxw_tmpfile(
      tmpdir,
    );
  }

  late final _lxw_tmpfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>)>>('lxw_tmpfile');
  late final _lxw_tmpfile = _lxw_tmpfilePtr
      .asFunction<ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> lxw_get_filehandle(
    ffi.Pointer<ffi.Pointer<ffi.Char>> buf,
    ffi.Pointer<ffi.Size> size,
    ffi.Pointer<ffi.Char> tmpdir,
  ) {
    return _lxw_get_filehandle(
      buf,
      size,
      tmpdir,
    );
  }

  late final _lxw_get_filehandlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Char>)>>('lxw_get_filehandle');
  late final _lxw_get_filehandle = _lxw_get_filehandlePtr.asFunction<
      ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> lxw_fopen(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Char> mode,
  ) {
    return _lxw_fopen(
      filename,
      mode,
    );
  }

  late final _lxw_fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('lxw_fopen');
  late final _lxw_fopen = _lxw_fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int lxw_hash_password(
    ffi.Pointer<ffi.Char> password,
  ) {
    return _lxw_hash_password(
      password,
    );
  }

  late final _lxw_hash_passwordPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<ffi.Char>)>>(
          'lxw_hash_password');
  late final _lxw_hash_password =
      _lxw_hash_passwordPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// INDENT-ON*
  ffi.Pointer<lxw_relationships> lxw_relationships_new() {
    return _lxw_relationships_new();
  }

  late final _lxw_relationships_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lxw_relationships> Function()>>(
          'lxw_relationships_new');
  late final _lxw_relationships_new = _lxw_relationships_newPtr
      .asFunction<ffi.Pointer<lxw_relationships> Function()>();

  void lxw_free_relationships(
    ffi.Pointer<lxw_relationships> relationships,
  ) {
    return _lxw_free_relationships(
      relationships,
    );
  }

  late final _lxw_free_relationshipsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_relationships>)>>('lxw_free_relationships');
  late final _lxw_free_relationships = _lxw_free_relationshipsPtr
      .asFunction<void Function(ffi.Pointer<lxw_relationships>)>();

  void lxw_relationships_assemble_xml_file(
    ffi.Pointer<lxw_relationships> self,
  ) {
    return _lxw_relationships_assemble_xml_file(
      self,
    );
  }

  late final _lxw_relationships_assemble_xml_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_relationships>)>>(
      'lxw_relationships_assemble_xml_file');
  late final _lxw_relationships_assemble_xml_file =
      _lxw_relationships_assemble_xml_filePtr
          .asFunction<void Function(ffi.Pointer<lxw_relationships>)>();

  void lxw_add_document_relationship(
    ffi.Pointer<lxw_relationships> self,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Char> target,
  ) {
    return _lxw_add_document_relationship(
      self,
      type,
      target,
    );
  }

  late final _lxw_add_document_relationshipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_relationships>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lxw_add_document_relationship');
  late final _lxw_add_document_relationship =
      _lxw_add_document_relationshipPtr.asFunction<
          void Function(ffi.Pointer<lxw_relationships>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  void lxw_add_package_relationship(
    ffi.Pointer<lxw_relationships> self,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Char> target,
  ) {
    return _lxw_add_package_relationship(
      self,
      type,
      target,
    );
  }

  late final _lxw_add_package_relationshipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_relationships>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lxw_add_package_relationship');
  late final _lxw_add_package_relationship =
      _lxw_add_package_relationshipPtr.asFunction<
          void Function(ffi.Pointer<lxw_relationships>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  void lxw_add_ms_package_relationship(
    ffi.Pointer<lxw_relationships> self,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Char> target,
  ) {
    return _lxw_add_ms_package_relationship(
      self,
      type,
      target,
    );
  }

  late final _lxw_add_ms_package_relationshipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_relationships>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lxw_add_ms_package_relationship');
  late final _lxw_add_ms_package_relationship =
      _lxw_add_ms_package_relationshipPtr.asFunction<
          void Function(ffi.Pointer<lxw_relationships>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  void lxw_add_worksheet_relationship(
    ffi.Pointer<lxw_relationships> self,
    ffi.Pointer<ffi.Char> type,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> target_mode,
  ) {
    return _lxw_add_worksheet_relationship(
      self,
      type,
      target,
      target_mode,
    );
  }

  late final _lxw_add_worksheet_relationshipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_relationships>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('lxw_add_worksheet_relationship');
  late final _lxw_add_worksheet_relationship =
      _lxw_add_worksheet_relationshipPtr.asFunction<
          void Function(ffi.Pointer<lxw_relationships>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// @brief Write a number to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param number    The number to write to the cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `worksheet_write_number()` function writes numeric types to the cell
  /// specified by `row` and `column`:
  ///
  /// @code
  /// worksheet_write_number(worksheet, 0, 0, 123456, NULL);
  /// worksheet_write_number(worksheet, 1, 0, 2.3451, NULL);
  /// @endcode
  ///
  /// @image html write_number01.png
  ///
  /// The native data type for all numbers in Excel is a IEEE-754 64-bit
  /// double-precision floating point, which is also the default type used by
  /// `%worksheet_write_number`.
  ///
  /// The `format` parameter is used to apply formatting to the cell. This
  /// parameter can be `NULL` to indicate no formatting or it can be a
  /// @ref format.h "Format" object.
  ///
  /// @code
  /// lxw_format *format = workbook_add_format(workbook);
  /// format_set_num_format(format, "$#,##0.00");
  ///
  /// worksheet_write_number(worksheet, 0, 0, 1234.567, format);
  /// @endcode
  ///
  /// @image html write_number02.png
  ///
  /// @note Excel doesn't support `NaN`, `Inf` or `-Inf` as a number value. If
  /// you are writing data that contains these values then your application
  /// should convert them to a string or handle them in some other way.
  int worksheet_write_number(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    double number,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_number(
      worksheet,
      row,
      col,
      number,
      format,
    );
  }

  late final _worksheet_write_numberPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Double, ffi.Pointer<lxw_format>)>>('worksheet_write_number');
  late final _worksheet_write_number = _worksheet_write_numberPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, double,
          ffi.Pointer<lxw_format>)>();

  /// @brief Write a string to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param string    String to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_string()` function writes a string to the cell
  /// specified by `row` and `column`:
  ///
  /// @code
  /// worksheet_write_string(worksheet, 0, 0, "This phrase is English!", NULL);
  /// @endcode
  ///
  /// @image html write_string01.png
  ///
  /// The `format` parameter is used to apply formatting to the cell. This
  /// parameter can be `NULL` to indicate no formatting or it can be a
  /// @ref format.h "Format" object:
  ///
  /// @code
  /// lxw_format *format = workbook_add_format(workbook);
  /// format_set_bold(format);
  ///
  /// worksheet_write_string(worksheet, 0, 0, "This phrase is Bold!", format);
  /// @endcode
  ///
  /// @image html write_string02.png
  ///
  /// Unicode strings are supported in UTF-8 encoding. This generally requires
  /// that your source file is UTF-8 encoded or that the data has been read from
  /// a UTF-8 source:
  ///
  /// @code
  /// worksheet_write_string(worksheet, 0, 0, "   !", NULL);
  /// @endcode
  ///
  /// @image html write_string03.png
  int worksheet_write_string(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_string(
      worksheet,
      row,
      col,
      string,
      format,
    );
  }

  late final _worksheet_write_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_string');
  late final _worksheet_write_string = _worksheet_write_stringPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_format>)>();

  /// @brief Write a formula to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param formula   Formula string to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_formula()` function writes a formula or function to
  /// the cell specified by `row` and `column`:
  ///
  /// @code
  /// worksheet_write_formula(worksheet, 0, 0, "=B3 + 6",                    NULL);
  /// worksheet_write_formula(worksheet, 1, 0, "=SIN(PI()/4)",               NULL);
  /// worksheet_write_formula(worksheet, 2, 0, "=SUM(A1:A2)",                NULL);
  /// worksheet_write_formula(worksheet, 3, 0, "=IF(A3>1,\"Yes\", \"No\")",  NULL);
  /// worksheet_write_formula(worksheet, 4, 0, "=AVERAGE(1, 2, 3, 4)",       NULL);
  /// worksheet_write_formula(worksheet, 5, 0, "=DATEVALUE(\"1-Jan-2013\")", NULL);
  /// @endcode
  ///
  /// @image html write_formula01.png
  ///
  /// The `format` parameter is used to apply formatting to the cell. This
  /// parameter can be `NULL` to indicate no formatting or it can be a
  /// @ref format.h "Format" object.
  ///
  /// Libxlsxwriter doesn't calculate the value of a formula and instead stores a
  /// default value of `0`. The correct formula result is displayed in Excel, as
  /// shown in the example above, since it recalculates the formulas when it loads
  /// the file. For cases where this is an issue see the
  /// `worksheet_write_formula_num()` function and the discussion in that section.
  ///
  /// Formulas must be written with the US style separator/range operator which
  /// is a comma (not semi-colon). Therefore a formula with multiple values
  /// should be written as follows:
  ///
  /// @code
  /// // OK.
  /// worksheet_write_formula(worksheet, 0, 0, "=SUM(1, 2, 3)", NULL);
  ///
  /// // NO. Error on load.
  /// worksheet_write_formula(worksheet, 1, 0, "=SUM(1; 2; 3)", NULL);
  /// @endcode
  ///
  /// See also @ref working_with_formulas.
  int worksheet_write_formula(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_formula(
      worksheet,
      row,
      col,
      formula,
      format,
    );
  }

  late final _worksheet_write_formulaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_formula');
  late final _worksheet_write_formula = _worksheet_write_formulaPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_format>)>();

  /// @brief Write an array formula to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  /// @param formula   Array formula to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_array_formula()` function writes an array formula to
  /// a cell range. In Excel an array formula is a formula that performs a
  /// calculation on a set of values.
  ///
  /// In Excel an array formula is indicated by a pair of braces around the
  /// formula: `{=SUM(A1:B1*A2:B2)}`.
  ///
  /// Array formulas can return a single value or a range or values. For array
  /// formulas that return a range of values you must specify the range that the
  /// return values will be written to. This is why this function has `first_`
  /// and `last_` row/column parameters. The RANGE() macro can also be used to
  /// specify the range:
  ///
  /// @code
  /// worksheet_write_array_formula(worksheet, 4, 0, 6, 0,     "{=TREND(C5:C7,B5:B7)}", NULL);
  ///
  /// // Same as above using the RANGE() macro.
  /// worksheet_write_array_formula(worksheet, RANGE("A5:A7"), "{=TREND(C5:C7,B5:B7)}", NULL);
  /// @endcode
  ///
  /// If the array formula returns a single value then the `first_` and `last_`
  /// parameters should be the same:
  ///
  /// @code
  /// worksheet_write_array_formula(worksheet, 1, 0, 1, 0,     "{=SUM(B1:C1*B2:C2)}", NULL);
  /// worksheet_write_array_formula(worksheet, RANGE("A2:A2"), "{=SUM(B1:C1*B2:C2)}", NULL);
  /// @endcode
  int worksheet_write_array_formula(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_array_formula(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      formula,
      format,
    );
  }

  late final _worksheet_write_array_formulaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_array_formula');
  late final _worksheet_write_array_formula =
      _worksheet_write_array_formulaPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>)>();

  /// @brief Write an Excel 365 dynamic array formula to a worksheet range.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  /// @param formula   Dynamic Array formula to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  ///
  /// The `%worksheet_write_dynamic_array_formula()` function writes an Excel 365
  /// dynamic array formula to a cell range. Some examples of functions that
  /// return dynamic arrays are:
  ///
  /// - `FILTER`
  /// - `RANDARRAY`
  /// - `SEQUENCE`
  /// - `SORTBY`
  /// - `SORT`
  /// - `UNIQUE`
  /// - `XLOOKUP`
  /// - `XMATCH`
  ///
  /// Dynamic array formulas and their usage in libxlsxwriter is explained in
  /// detail @ref ww_formulas_dynamic_arrays. The following is a example usage:
  ///
  /// @code
  /// worksheet_write_dynamic_array_formula(worksheet, 1, 5, 1, 5,
  /// "=_xlfn._xlws.FILTER(A1:D17,C1:C17=K2)",
  /// NULL);
  /// @endcode
  ///
  /// This formula gives the results shown in the image below.
  ///
  /// @image html dynamic_arrays02.png
  ///
  /// The need for the `_xlfn._xlws.` prefix in the formula is explained in @ref
  /// ww_formulas_future.
  int worksheet_write_dynamic_array_formula(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_dynamic_array_formula(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      formula,
      format,
    );
  }

  late final _worksheet_write_dynamic_array_formulaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  lxw_col_t,
                  lxw_row_t,
                  lxw_col_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_format>)>>(
      'worksheet_write_dynamic_array_formula');
  late final _worksheet_write_dynamic_array_formula =
      _worksheet_write_dynamic_array_formulaPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>)>();

  /// @brief Write an Excel 365 dynamic array formula to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param formula   Formula string to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_dynamic_formula()` function is similar to the
  /// `worksheet_write_dynamic_array_formula()` function, shown above, except
  /// that it writes a dynamic array formula to a single cell, rather than a
  /// range. This is a syntactic shortcut since the array range isn't generally
  /// known for a dynamic range and specifying the initial cell is sufficient for
  /// Excel, as shown in the example below:
  ///
  /// @code
  /// worksheet_write_dynamic_formula(worksheet, 7, 1,
  /// "=_xlfn._xlws.SORT(_xlfn.UNIQUE(B2:B17))",
  /// NULL);
  /// @endcode
  ///
  /// This formula gives the following result:
  ///
  /// @image html dynamic_arrays01.png
  ///
  /// The need for the `_xlfn.` and `_xlfn._xlws.` prefixes in the formula is
  /// explained in @ref ww_formulas_future.
  int worksheet_write_dynamic_formula(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_dynamic_formula(
      worksheet,
      row,
      col,
      formula,
      format,
    );
  }

  late final _worksheet_write_dynamic_formulaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_dynamic_formula');
  late final _worksheet_write_dynamic_formula =
      _worksheet_write_dynamic_formulaPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>)>();

  int worksheet_write_array_formula_num(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
    double result,
  ) {
    return _worksheet_write_array_formula_num(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      formula,
      format,
      result,
    );
  }

  late final _worksheet_write_array_formula_numPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Double)>>('worksheet_write_array_formula_num');
  late final _worksheet_write_array_formula_num =
      _worksheet_write_array_formula_numPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>, double)>();

  int worksheet_write_dynamic_array_formula_num(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
    double result,
  ) {
    return _worksheet_write_dynamic_array_formula_num(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      formula,
      format,
      result,
    );
  }

  late final _worksheet_write_dynamic_array_formula_numPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Double)>>('worksheet_write_dynamic_array_formula_num');
  late final _worksheet_write_dynamic_array_formula_num =
      _worksheet_write_dynamic_array_formula_numPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>, double)>();

  int worksheet_write_dynamic_formula_num(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
    double result,
  ) {
    return _worksheet_write_dynamic_formula_num(
      worksheet,
      row,
      col,
      formula,
      format,
      result,
    );
  }

  late final _worksheet_write_dynamic_formula_numPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Double)>>('worksheet_write_dynamic_formula_num');
  late final _worksheet_write_dynamic_formula_num =
      _worksheet_write_dynamic_formula_numPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>, double)>();

  /// @brief Write a date or time to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param datetime  The datetime to write to the cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_datetime()` function can be used to write a date or
  /// time to the cell specified by `row` and `column`:
  ///
  /// @dontinclude dates_and_times02.c
  /// @skip include
  /// @until num_format
  /// @skip Feb
  /// @until }
  ///
  /// The `format` parameter should be used to apply formatting to the cell using
  /// a @ref format.h "Format" object as shown above. Without a date format the
  /// datetime will appear as a number only.
  ///
  /// See @ref working_with_dates for more information about handling dates and
  /// times in libxlsxwriter.
  int worksheet_write_datetime(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_datetime> datetime,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_datetime(
      worksheet,
      row,
      col,
      datetime,
      format,
    );
  }

  late final _worksheet_write_datetimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<lxw_datetime>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_datetime');
  late final _worksheet_write_datetime =
      _worksheet_write_datetimePtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_datetime>, ffi.Pointer<lxw_format>)>();

  /// @brief Write a Unix datetime to a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param unixtime  The Unix datetime to write to the cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_unixtime()` function can be used to write dates and
  /// times in Unix date format to the cell specified by `row` and
  /// `column`. [Unix Time](https://en.wikipedia.org/wiki/Unix_time) which is a
  /// common integer time format. It is defined as the number of seconds since
  /// the Unix epoch (1970-01-01 00:00 UTC). Negative values can also be used for
  /// dates prior to 1970:
  ///
  /// @dontinclude dates_and_times03.c
  /// @skip 1970
  /// @until 2208988800
  ///
  /// The `format` parameter should be used to apply formatting to the cell using
  /// a @ref format.h "Format" object as shown above. Without a date format the
  /// datetime will appear as a number only.
  ///
  /// The output from this code sample is:
  ///
  /// @image html date_example03.png
  ///
  /// Unixtime is generally represented with a 32 bit `time_t` type which has a
  /// range of approximately 1900-12-14 to 2038-01-19. To access the full Excel
  /// date range of 1900-01-01 to 9999-12-31 this function uses a 64 bit
  /// parameter.
  ///
  /// See @ref working_with_dates for more information about handling dates and
  /// times in libxlsxwriter.
  int worksheet_write_unixtime(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    int unixtime,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_unixtime(
      worksheet,
      row,
      col,
      unixtime,
      format,
    );
  }

  late final _worksheet_write_unixtimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Int64, ffi.Pointer<lxw_format>)>>('worksheet_write_unixtime');
  late final _worksheet_write_unixtime =
      _worksheet_write_unixtimePtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int,
              ffi.Pointer<lxw_format>)>();

  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param url       The url to write to the cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  ///
  /// The `%worksheet_write_url()` function is used to write a URL/hyperlink to a
  /// worksheet cell specified by `row` and `column`.
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "http://libxlsxwriter.github.io", NULL);
  /// @endcode
  ///
  /// @image html hyperlinks_short.png
  ///
  /// The `format` parameter is used to apply formatting to the cell. This
  /// parameter can be `NULL`, in which case the default Excel blue underlined
  /// hyperlink style will be used. If required a user defined @ref format.h
  /// "Format" object can be used:
  /// underline:
  ///
  /// @code
  /// lxw_format *url_format   = workbook_add_format(workbook);
  ///
  /// format_set_underline (url_format, LXW_UNDERLINE_SINGLE);
  /// format_set_font_color(url_format, LXW_COLOR_RED);
  ///
  /// @endcode
  ///
  /// The usual web style URI's are supported: `%http://`, `%https://`, `%ftp://`
  /// and `mailto:` :
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "ftp://www.python.org/",     NULL);
  /// worksheet_write_url(worksheet, 1, 0, "http://www.python.org/",    NULL);
  /// worksheet_write_url(worksheet, 2, 0, "https://www.python.org/",   NULL);
  /// worksheet_write_url(worksheet, 3, 0, "mailto:jmcnamara@cpan.org", NULL);
  ///
  /// @endcode
  ///
  /// An Excel hyperlink is comprised of two elements: the displayed string and
  /// the non-displayed link. By default the displayed string is the same as the
  /// link. However, it is possible to overwrite it with any other
  /// `libxlsxwriter` type using the appropriate `worksheet_write_*()`
  /// function. The most common case is to overwrite the displayed link text with
  /// another string. To do this we must also match the default URL format using
  /// `workbook_get_default_url_format()`:
  ///
  /// @code
  /// // Write a hyperlink with the default blue underline format.
  /// worksheet_write_url(worksheet, 2, 0, "http://libxlsxwriter.github.io", NULL);
  ///
  /// // Get the default url format.
  /// lxw_format *url_format = workbook_get_default_url_format(workbook);
  ///
  /// // Overwrite the hyperlink with a user defined string and default format.
  /// worksheet_write_string(worksheet, 2, 0, "Read the documentation.", url_format);
  /// @endcode
  ///
  /// @image html hyperlinks_short2.png
  ///
  /// Two local URIs are supported: `internal:` and `external:`. These are used
  /// for hyperlinks to internal worksheet references or external workbook and
  /// worksheet references:
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "internal:Sheet2!A1",                NULL);
  /// worksheet_write_url(worksheet, 1, 0, "internal:Sheet2!B2",                NULL);
  /// worksheet_write_url(worksheet, 2, 0, "internal:Sheet2!A1:B2",             NULL);
  /// worksheet_write_url(worksheet, 3, 0, "internal:'Sales Data'!A1",          NULL);
  /// worksheet_write_url(worksheet, 4, 0, "external:c:\\temp\\foo.xlsx",       NULL);
  /// worksheet_write_url(worksheet, 5, 0, "external:c:\\foo.xlsx#Sheet2!A1",   NULL);
  /// worksheet_write_url(worksheet, 6, 0, "external:..\\foo.xlsx",             NULL);
  /// worksheet_write_url(worksheet, 7, 0, "external:..\\foo.xlsx#Sheet2!A1",   NULL);
  /// worksheet_write_url(worksheet, 8, 0, "external:\\\\NET\\share\\foo.xlsx", NULL);
  ///
  /// @endcode
  ///
  /// Worksheet references are typically of the form `Sheet1!A1`. You can also
  /// link to a worksheet range using the standard Excel notation:
  /// `Sheet1!A1:B2`.
  ///
  /// In external links the workbook and worksheet name must be separated by the
  /// `#` character:
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "external:c:\\foo.xlsx#Sheet2!A1",   NULL);
  /// @endcode
  ///
  /// You can also link to a named range in the target worksheet: For example say
  /// you have a named range called `my_name` in the workbook `c:\temp\foo.xlsx`
  /// you could link to it as follows:
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "external:c:\\temp\\foo.xlsx#my_name", NULL);
  ///
  /// @endcode
  ///
  /// Excel requires that worksheet names containing spaces or non alphanumeric
  /// characters are single quoted as follows:
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "internal:'Sales Data'!A1", NULL);
  /// @endcode
  ///
  /// Links to network files are also supported. Network files normally begin
  /// with two back slashes as follows `\\NETWORK\etc`. In order to represent
  /// this in a C string literal the backslashes should be escaped:
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "external:\\\\NET\\share\\foo.xlsx", NULL);
  /// @endcode
  ///
  ///
  /// Alternatively, you can use Unix style forward slashes. These are
  /// translated internally to backslashes:
  ///
  /// @code
  /// worksheet_write_url(worksheet, 0, 0, "external:c:/temp/foo.xlsx",     NULL);
  /// worksheet_write_url(worksheet, 1, 0, "external://NET/share/foo.xlsx", NULL);
  ///
  /// @endcode
  ///
  ///
  /// **Note:**
  ///
  /// libxlsxwriter will escape the following characters in URLs as required
  /// by Excel: `\s " < > \ [ ]  ^ { }`. Existing URL `%%xx` style escapes in
  /// the string are ignored to allow for user-escaped strings.
  ///
  /// **Note:**
  ///
  /// The maximum allowable URL length in recent versions of Excel is 2079
  /// characters. In older versions of Excel (and libxlsxwriter <= 0.8.8) the
  /// limit was 255 characters.
  int worksheet_write_url(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_url(
      worksheet,
      row,
      col,
      url,
      format,
    );
  }

  late final _worksheet_write_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_url');
  late final _worksheet_write_url = _worksheet_write_urlPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_format>)>();

  /// Don't document for now since the string option can be achieved by a
  /// subsequent cell worksheet_write() as shown in the docs, and the
  /// tooltip option isn't very useful.
  int worksheet_write_url_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row_num,
    int col_num,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<ffi.Char> tooltip,
  ) {
    return _worksheet_write_url_opt(
      worksheet,
      row_num,
      col_num,
      url,
      format,
      string,
      tooltip,
    );
  }

  late final _worksheet_write_url_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('worksheet_write_url_opt');
  late final _worksheet_write_url_opt = _worksheet_write_url_optPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_format>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// @brief Write a formatted boolean worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param value     The boolean value to write to the cell.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// Write an Excel boolean to the cell specified by `row` and `column`:
  ///
  /// @code
  /// worksheet_write_boolean(worksheet, 2, 2, 0, my_format);
  /// @endcode
  int worksheet_write_boolean(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    int value,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_boolean(
      worksheet,
      row,
      col,
      value,
      format,
    );
  }

  late final _worksheet_write_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Int, ffi.Pointer<lxw_format>)>>('worksheet_write_boolean');
  late final _worksheet_write_boolean = _worksheet_write_booleanPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, int,
          ffi.Pointer<lxw_format>)>();

  /// @brief Write a formatted blank worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// Write a blank cell specified by `row` and `column`:
  ///
  /// @code
  /// worksheet_write_blank(worksheet, 1, 1, border_format);
  /// @endcode
  ///
  /// This function is used to add formatting to a cell which doesn't contain a
  /// string or number value.
  ///
  /// Excel differentiates between an "Empty" cell and a "Blank" cell. An Empty
  /// cell is a cell which doesn't contain data or formatting whilst a Blank cell
  /// doesn't contain data but does contain formatting. Excel stores Blank cells
  /// but ignores Empty cells.
  ///
  /// As such, if you write an empty cell without formatting it is ignored.
  int worksheet_write_blank(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_blank(
      worksheet,
      row,
      col,
      format,
    );
  }

  late final _worksheet_write_blankPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Pointer<lxw_format>)>>('worksheet_write_blank');
  late final _worksheet_write_blank = _worksheet_write_blankPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<lxw_format>)>();

  /// @brief Write a formula to a worksheet cell with a user defined numeric
  /// result.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param formula   Formula string to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  /// @param result    A user defined numeric result for the formula.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_formula_num()` function writes a formula or Excel
  /// function to the cell specified by `row` and `column` with a user defined
  /// numeric result:
  ///
  /// @code
  /// // Required as a workaround only.
  /// worksheet_write_formula_num(worksheet, 0, 0, "=1 + 2", NULL, 3);
  /// @endcode
  ///
  /// Libxlsxwriter doesn't calculate the value of a formula and instead stores
  /// the value `0` as the formula result. It then sets a global flag in the XLSX
  /// file to say that all formulas and functions should be recalculated when the
  /// file is opened.
  ///
  /// This is the method recommended in the Excel documentation and in general it
  /// works fine with spreadsheet applications.
  ///
  /// However, applications that don't have a facility to calculate formulas,
  /// such as Excel Viewer, or some mobile applications will only display the `0`
  /// results.
  ///
  /// If required, the `%worksheet_write_formula_num()` function can be used to
  /// specify a formula and its result.
  ///
  /// This function is rarely required and is only provided for compatibility
  /// with some third party applications. For most applications the
  /// worksheet_write_formula() function is the recommended way of writing
  /// formulas.
  ///
  /// See also @ref working_with_formulas.
  int worksheet_write_formula_num(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
    double result,
  ) {
    return _worksheet_write_formula_num(
      worksheet,
      row,
      col,
      formula,
      format,
      result,
    );
  }

  late final _worksheet_write_formula_numPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Double)>>('worksheet_write_formula_num');
  late final _worksheet_write_formula_num =
      _worksheet_write_formula_numPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>, double)>();

  /// @brief Write a formula to a worksheet cell with a user defined string
  /// result.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param formula   Formula string to write to cell.
  /// @param format    A pointer to a Format instance or NULL.
  /// @param result    A user defined string result for the formula.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_formula_str()` function writes a formula or Excel
  /// function to the cell specified by `row` and `column` with a user defined
  /// string result:
  ///
  /// @code
  /// // The example formula is A & B -> AB.
  /// worksheet_write_formula_str(worksheet, 0, 0, "=\"A\" & \"B\"", NULL, "AB");
  /// @endcode
  ///
  /// The `%worksheet_write_formula_str()` function is similar to the
  /// `%worksheet_write_formula_num()` function except it writes a string result
  /// instead or a numeric result. See `worksheet_write_formula_num()`  for more
  /// details on why/when these functions are required.
  ///
  /// One place where the `%worksheet_write_formula_str()` function may be required
  /// is to specify an empty result which will force a recalculation of the formula
  /// when loaded in LibreOffice.
  ///
  /// @code
  /// worksheet_write_formula_str(worksheet, 0, 0, "=Sheet1!$A$1", NULL, "");
  /// @endcode
  ///
  /// See the FAQ @ref faq_formula_zero.
  ///
  /// See also @ref working_with_formulas.
  int worksheet_write_formula_str(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> formula,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<ffi.Char> result,
  ) {
    return _worksheet_write_formula_str(
      worksheet,
      row,
      col,
      formula,
      format,
      result,
    );
  }

  late final _worksheet_write_formula_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>)>>('worksheet_write_formula_str');
  late final _worksheet_write_formula_str =
      _worksheet_write_formula_strPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_worksheet>,
              int,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>,
              ffi.Pointer<ffi.Char>)>();

  /// @brief Write a "Rich" multi-format string to a worksheet cell.
  ///
  /// @param worksheet   Pointer to a lxw_worksheet instance to be updated.
  /// @param row         The zero indexed row number.
  /// @param col         The zero indexed column number.
  /// @param rich_string An array of format/string lxw_rich_string_tuple fragments.
  /// @param format      A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_rich_string()` function is used to write strings with
  /// multiple formats. For example to write the string 'This is **bold**
  /// and this is *italic*' you would use the following:
  ///
  /// @code
  /// lxw_format *bold = workbook_add_format(workbook);
  /// format_set_bold(bold);
  ///
  /// lxw_format *italic = workbook_add_format(workbook);
  /// format_set_italic(italic);
  ///
  /// lxw_rich_string_tuple fragment11 = {.format = NULL,   .string = "This is "     };
  /// lxw_rich_string_tuple fragment12 = {.format = bold,   .string = "bold"         };
  /// lxw_rich_string_tuple fragment13 = {.format = NULL,   .string = " and this is "};
  /// lxw_rich_string_tuple fragment14 = {.format = italic, .string = "italic"       };
  ///
  /// lxw_rich_string_tuple *rich_string1[] = {&fragment11, &fragment12,
  /// &fragment13, &fragment14, NULL};
  ///
  /// worksheet_write_rich_string(worksheet, CELL("A1"), rich_string1, NULL);
  ///
  /// @endcode
  ///
  /// @image html rich_strings_small.png
  ///
  /// The basic rule is to break the string into fragments and put a lxw_format
  /// object before the fragment that you want to format. So if we look at the
  /// above example again:
  ///
  /// This is **bold** and this is *italic*
  ///
  /// The would be broken down into 4 fragments:
  ///
  /// default: |This is |
  /// bold:    |bold|
  /// default: | and this is |
  /// italic:  |italic|
  ///
  /// This in then converted to the lxw_rich_string_tuple fragments shown in the
  /// example above. For the default format we use `NULL`.
  ///
  /// The fragments are passed to `%worksheet_write_rich_string()` as a `NULL`
  /// terminated array:
  ///
  /// @code
  /// lxw_rich_string_tuple *rich_string1[] = {&fragment11, &fragment12,
  /// &fragment13, &fragment14, NULL};
  ///
  /// worksheet_write_rich_string(worksheet, CELL("A1"), rich_string1, NULL);
  ///
  /// @endcode
  ///
  /// **Note**:
  /// Excel doesn't allow the use of two consecutive formats in a rich string or
  /// an empty string fragment. For either of these conditions a warning is
  /// raised and the input to `%worksheet_write_rich_string()` is ignored.
  int worksheet_write_rich_string(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Pointer<lxw_rich_string_tuple>> rich_string,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_write_rich_string(
      worksheet,
      row,
      col,
      rich_string,
      format,
    );
  }

  late final _worksheet_write_rich_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Pointer<lxw_rich_string_tuple>>,
              ffi.Pointer<lxw_format>)>>('worksheet_write_rich_string');
  late final _worksheet_write_rich_string =
      _worksheet_write_rich_stringPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_worksheet>,
              int,
              int,
              ffi.Pointer<ffi.Pointer<lxw_rich_string_tuple>>,
              ffi.Pointer<lxw_format>)>();

  /// @brief Write a comment to a worksheet cell.
  ///
  /// @param worksheet   Pointer to a lxw_worksheet instance to be updated.
  /// @param row         The zero indexed row number.
  /// @param col         The zero indexed column number.
  /// @param string      The comment string to be written.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_comment()` function is used to add a comment to a
  /// cell. A comment is indicated in Excel by a small red triangle in the upper
  /// right-hand corner of the cell. Moving the cursor over the red triangle will
  /// reveal the comment.
  ///
  /// The following example shows how to add a comment to a cell:
  ///
  /// @code
  /// worksheet_write_comment(worksheet, 0, 0, "This is a comment");
  /// @endcode
  ///
  /// @image html comments1.png
  ///
  /// See also @ref working_with_comments
  int worksheet_write_comment(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _worksheet_write_comment(
      worksheet,
      row,
      col,
      string,
    );
  }

  late final _worksheet_write_commentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Pointer<ffi.Char>)>>('worksheet_write_comment');
  late final _worksheet_write_comment = _worksheet_write_commentPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<ffi.Char>)>();

  /// @brief Write a comment to a worksheet cell with options.
  ///
  /// @param worksheet   Pointer to a lxw_worksheet instance to be updated.
  /// @param row         The zero indexed row number.
  /// @param col         The zero indexed column number.
  /// @param string      The comment string to be written.
  /// @param options     #lxw_comment_options to control position and format
  /// of the comment.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_write_comment_opt()` function is used to add a comment to a
  /// cell with option that control the position, format and metadata of the
  /// comment. A comment is indicated in Excel by a small red triangle in the
  /// upper right-hand corner of the cell. Moving the cursor over the red
  /// triangle will reveal the comment.
  ///
  /// The following example shows how to add a comment to a cell with options:
  ///
  /// @code
  /// lxw_comment_options options = {.visible = LXW_COMMENT_DISPLAY_VISIBLE};
  ///
  /// worksheet_write_comment_opt(worksheet, CELL("C6"), "Hello.", &options);
  /// @endcode
  ///
  /// The following options are available in #lxw_comment_options:
  ///
  /// - `author`
  /// - `visible`
  /// - `width`
  /// - `height`
  /// - `x_scale`
  /// - `y_scale`
  /// - `color`
  /// - `font_name`
  /// - `font_size`
  /// - `start_row`
  /// - `start_col`
  /// - `x_offset`
  /// - `y_offset`
  ///
  /// @image html comments2.png
  ///
  /// Comment options are explained in detail in the @ref ww_comments_properties
  /// section of the docs.
  int worksheet_write_comment_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_comment_options> options,
  ) {
    return _worksheet_write_comment_opt(
      worksheet,
      row,
      col,
      string,
      options,
    );
  }

  late final _worksheet_write_comment_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  lxw_col_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_comment_options>)>>(
      'worksheet_write_comment_opt');
  late final _worksheet_write_comment_opt =
      _worksheet_write_comment_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_comment_options>)>();

  /// @brief Set the properties for a row of cells.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param height    The row height, in character units.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_row()` function is used to change the default
  /// properties of a row. The most common use for this function is to change the
  /// height of a row:
  ///
  /// @code
  /// // Set the height of Row 1 to 20.
  /// worksheet_set_row(worksheet, 0, 20, NULL);
  /// @endcode
  ///
  /// The height is specified in character units. To specify the height in pixels
  /// use the `worksheet_set_row_pixels()` function.
  ///
  /// The other common use for `%worksheet_set_row()` is to set the a @ref
  /// format.h "Format" for all cells in the row:
  ///
  /// @code
  /// lxw_format *bold = workbook_add_format(workbook);
  /// format_set_bold(bold);
  ///
  /// // Set the header row to bold.
  /// worksheet_set_row(worksheet, 0, 15, bold);
  /// @endcode
  ///
  /// If you wish to set the format of a row without changing the height you can
  /// pass the default row height of #LXW_DEF_ROW_HEIGHT = 15:
  ///
  /// @code
  /// worksheet_set_row(worksheet, 0, LXW_DEF_ROW_HEIGHT, format);
  /// worksheet_set_row(worksheet, 0, 15, format); // Same as above.
  /// @endcode
  ///
  /// The `format` parameter will be applied to any cells in the row that don't
  /// have a format. As with Excel the row format is overridden by an explicit
  /// cell format. For example:
  ///
  /// @code
  /// // Row 1 has format1.
  /// worksheet_set_row(worksheet, 0, 15, format1);
  ///
  /// // Cell A1 in Row 1 defaults to format1.
  /// worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
  ///
  /// // Cell B1 in Row 1 keeps format2.
  /// worksheet_write_string(worksheet, 0, 1, "Hello", format2);
  /// @endcode
  int worksheet_set_row(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    double height,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_set_row(
      worksheet,
      row,
      height,
      format,
    );
  }

  late final _worksheet_set_rowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, ffi.Double,
              ffi.Pointer<lxw_format>)>>('worksheet_set_row');
  late final _worksheet_set_row = _worksheet_set_rowPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, double, ffi.Pointer<lxw_format>)>();

  /// @brief Set the properties for a row of cells.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param height    The row height.
  /// @param format    A pointer to a Format instance or NULL.
  /// @param options   Optional row parameters: hidden, level, collapsed.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_row_opt()` function  is the same as
  /// `worksheet_set_row()` with an additional `options` parameter.
  ///
  /// The `options` parameter is a #lxw_row_col_options struct. It has the
  /// following members:
  ///
  /// - `hidden`
  /// - `level`
  /// - `collapsed`
  ///
  /// The `"hidden"` option is used to hide a row. This can be used, for
  /// example, to hide intermediary steps in a complicated calculation:
  ///
  /// @code
  /// lxw_row_col_options options1 = {.hidden = 1, .level = 0, .collapsed = 0};
  ///
  /// // Hide the fourth and fifth (zero indexed) rows.
  /// worksheet_set_row_opt(worksheet, 3,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 4,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  ///
  /// @endcode
  ///
  /// @image html hide_row_col2.png
  ///
  /// The `"hidden"`, `"level"`,  and `"collapsed"`, options can also be used to
  /// create Outlines and Grouping. See @ref working_with_outlines.
  ///
  /// @code
  /// // The option structs with the outline level set.
  /// lxw_row_col_options options1 = {.hidden = 0, .level = 2, .collapsed = 0};
  /// lxw_row_col_options options2 = {.hidden = 0, .level = 1, .collapsed = 0};
  ///
  ///
  /// // Set the row options with the outline level.
  /// worksheet_set_row_opt(worksheet, 1,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 2,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 3,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 4,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 5,  LXW_DEF_ROW_HEIGHT, NULL, &options2);
  ///
  /// worksheet_set_row_opt(worksheet, 6,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 7,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 8,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 9,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
  /// worksheet_set_row_opt(worksheet, 10, LXW_DEF_ROW_HEIGHT, NULL, &options2);
  /// @endcode
  ///
  /// @image html outline1.png
  int worksheet_set_row_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    double height,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<lxw_row_col_options> options,
  ) {
    return _worksheet_set_row_opt(
      worksheet,
      row,
      height,
      format,
      options,
    );
  }

  late final _worksheet_set_row_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              ffi.Double,
              ffi.Pointer<lxw_format>,
              ffi.Pointer<lxw_row_col_options>)>>('worksheet_set_row_opt');
  late final _worksheet_set_row_opt = _worksheet_set_row_optPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, double,
          ffi.Pointer<lxw_format>, ffi.Pointer<lxw_row_col_options>)>();

  /// @brief Set the properties for a row of cells, with the height in pixels.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param pixels    The row height in pixels.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_row_pixels()` function is the same as the
  /// `worksheet_set_row()` function except that the height can be set in pixels
  ///
  /// @code
  /// // Set the height of Row 1 to 20 pixels.
  /// worksheet_set_row_pixels(worksheet, 0, 20, NULL);
  /// @endcode
  ///
  /// If you wish to set the format of a row without changing the height you can
  /// pass the default row height in pixels: #LXW_DEF_ROW_HEIGHT_PIXELS.
  int worksheet_set_row_pixels(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int pixels,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_set_row_pixels(
      worksheet,
      row,
      pixels,
      format,
    );
  }

  late final _worksheet_set_row_pixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, ffi.Uint32,
              ffi.Pointer<lxw_format>)>>('worksheet_set_row_pixels');
  late final _worksheet_set_row_pixels =
      _worksheet_set_row_pixelsPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<lxw_format>)>();

  /// @brief Set the properties for a row of cells, with the height in pixels.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param pixels    The row height in pixels.
  /// @param format    A pointer to a Format instance or NULL.
  /// @param options   Optional row parameters: hidden, level, collapsed.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_row_pixels_opt()` function is the same as the
  /// `worksheet_set_row_opt()` function except that the height can be set in
  /// pixels.
  int worksheet_set_row_pixels_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int pixels,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<lxw_row_col_options> options,
  ) {
    return _worksheet_set_row_pixels_opt(
      worksheet,
      row,
      pixels,
      format,
      options,
    );
  }

  late final _worksheet_set_row_pixels_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  ffi.Uint32,
                  ffi.Pointer<lxw_format>,
                  ffi.Pointer<lxw_row_col_options>)>>(
      'worksheet_set_row_pixels_opt');
  late final _worksheet_set_row_pixels_opt =
      _worksheet_set_row_pixels_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_format>, ffi.Pointer<lxw_row_col_options>)>();

  /// @brief Set the properties for one or more columns of cells.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_col The zero indexed first column.
  /// @param last_col  The zero indexed last column.
  /// @param width     The width of the column(s).
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_column()` function can be used to change the default
  /// properties of a single column or a range of columns:
  ///
  /// @code
  /// // Width of columns B:D set to 30.
  /// worksheet_set_column(worksheet, 1, 3, 30, NULL);
  ///
  /// @endcode
  ///
  /// If `%worksheet_set_column()` is applied to a single column the value of
  /// `first_col` and `last_col` should be the same:
  ///
  /// @code
  /// // Width of column B set to 30.
  /// worksheet_set_column(worksheet, 1, 1, 30, NULL);
  ///
  /// @endcode
  ///
  /// It is also possible, and generally clearer, to specify a column range using
  /// the form of `COLS()` macro:
  ///
  /// @code
  /// worksheet_set_column(worksheet, 4, 4, 20, NULL);
  /// worksheet_set_column(worksheet, 5, 8, 30, NULL);
  ///
  /// // Same as the examples above but clearer.
  /// worksheet_set_column(worksheet, COLS("E:E"), 20, NULL);
  /// worksheet_set_column(worksheet, COLS("F:H"), 30, NULL);
  ///
  /// @endcode
  ///
  /// The `width` parameter sets the column width in the same units used by Excel
  /// which is: the number of characters in the default font. The default width
  /// is 8.43 in the default font of Calibri 11. The actual relationship between
  /// a string width and a column width in Excel is complex. See the
  /// [following explanation of column widths](https://support.microsoft.com/en-us/kb/214123)
  /// from the Microsoft support documentation for more details. To set the width
  /// in pixels use the `worksheet_set_column_pixels()` function.
  ///
  /// There is no way to specify "AutoFit" for a column in the Excel file
  /// format. This feature is only available at runtime from within Excel. It is
  /// possible to simulate "AutoFit" in your application by tracking the maximum
  /// width of the data in the column as your write it and then adjusting the
  /// column width at the end.
  ///
  /// As usual the @ref format.h `format` parameter is optional. If you wish to
  /// set the format without changing the width you can pass a default column
  /// width of #LXW_DEF_COL_WIDTH = 8.43:
  ///
  /// @code
  /// lxw_format *bold = workbook_add_format(workbook);
  /// format_set_bold(bold);
  ///
  /// // Set the first column to bold.
  /// worksheet_set_column(worksheet, 0, 0, LXW_DEF_COL_WIDTH, bold);
  /// @endcode
  ///
  /// The `format` parameter will be applied to any cells in the column that
  /// don't have a format. For example:
  ///
  /// @code
  /// // Column 1 has format1.
  /// worksheet_set_column(worksheet, COLS("A:A"), 8.43, format1);
  ///
  /// // Cell A1 in column 1 defaults to format1.
  /// worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
  ///
  /// // Cell A2 in column 1 keeps format2.
  /// worksheet_write_string(worksheet, 1, 0, "Hello", format2);
  /// @endcode
  ///
  /// As in Excel a row format takes precedence over a default column format:
  ///
  /// @code
  /// // Row 1 has format1.
  /// worksheet_set_row(worksheet, 0, 15, format1);
  ///
  /// // Col 1 has format2.
  /// worksheet_set_column(worksheet, COLS("A:A"), 8.43, format2);
  ///
  /// // Cell A1 defaults to format1, the row format.
  /// worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
  ///
  /// // Cell A2 keeps format2, the column format.
  /// worksheet_write_string(worksheet, 1, 0, "Hello", NULL);
  /// @endcode
  int worksheet_set_column(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_col,
    int last_col,
    double width,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_set_column(
      worksheet,
      first_col,
      last_col,
      width,
      format,
    );
  }

  late final _worksheet_set_columnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_col_t, lxw_col_t,
              ffi.Double, ffi.Pointer<lxw_format>)>>('worksheet_set_column');
  late final _worksheet_set_column = _worksheet_set_columnPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, double,
          ffi.Pointer<lxw_format>)>();

  /// @brief Set the properties for one or more columns of cells with options.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_col The zero indexed first column.
  /// @param last_col  The zero indexed last column.
  /// @param width     The width of the column(s).
  /// @param format    A pointer to a Format instance or NULL.
  /// @param options   Optional row parameters: hidden, level, collapsed.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_column_opt()` function  is the same as
  /// `worksheet_set_column()` with an additional `options` parameter.
  ///
  /// The `options` parameter is a #lxw_row_col_options struct. It has the
  /// following members:
  ///
  /// - `hidden`
  /// - `level`
  /// - `collapsed`
  ///
  /// The `"hidden"` option is used to hide a column. This can be used, for
  /// example, to hide intermediary steps in a complicated calculation:
  ///
  /// @code
  /// lxw_row_col_options options1 = {.hidden = 1, .level = 0, .collapsed = 0};
  ///
  /// worksheet_set_column_opt(worksheet, COLS("D:E"),  LXW_DEF_COL_WIDTH, NULL, &options1);
  /// @endcode
  ///
  /// @image html hide_row_col3.png
  ///
  /// The `"hidden"`, `"level"`,  and `"collapsed"`, options can also be used to
  /// create Outlines and Grouping. See @ref working_with_outlines.
  ///
  /// @code
  /// lxw_row_col_options options1 = {.hidden = 0, .level = 1, .collapsed = 0};
  ///
  /// worksheet_set_column_opt(worksheet, COLS("B:G"),  5, NULL, &options1);
  /// @endcode
  ///
  /// @image html outline8.png
  int worksheet_set_column_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_col,
    int last_col,
    double width,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<lxw_row_col_options> options,
  ) {
    return _worksheet_set_column_opt(
      worksheet,
      first_col,
      last_col,
      width,
      format,
      options,
    );
  }

  late final _worksheet_set_column_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_col_t,
              lxw_col_t,
              ffi.Double,
              ffi.Pointer<lxw_format>,
              ffi.Pointer<lxw_row_col_options>)>>('worksheet_set_column_opt');
  late final _worksheet_set_column_opt =
      _worksheet_set_column_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, double,
              ffi.Pointer<lxw_format>, ffi.Pointer<lxw_row_col_options>)>();

  /// @brief Set the properties for one or more columns of cells, with the width
  /// in pixels.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_col The zero indexed first column.
  /// @param last_col  The zero indexed last column.
  /// @param pixels    The width of the column(s) in pixels.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_column_pixels()` function is the same as
  /// `worksheet_set_column()` function except that the width can be set in
  /// pixels:
  ///
  /// @code
  /// // Column width set to 75 pixels, the same as 10 character units.
  /// worksheet_set_column(worksheet, 5, 5, 75, NULL);
  /// @endcode
  ///
  /// @image html set_column_pixels.png
  ///
  /// If you wish to set the format of a column without changing the width you can
  /// pass the default column width in pixels: #LXW_DEF_COL_WIDTH_PIXELS.
  int worksheet_set_column_pixels(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_col,
    int last_col,
    int pixels,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_set_column_pixels(
      worksheet,
      first_col,
      last_col,
      pixels,
      format,
    );
  }

  late final _worksheet_set_column_pixelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_col_t,
              lxw_col_t,
              ffi.Uint32,
              ffi.Pointer<lxw_format>)>>('worksheet_set_column_pixels');
  late final _worksheet_set_column_pixels =
      _worksheet_set_column_pixelsPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int,
              ffi.Pointer<lxw_format>)>();

  /// @brief Set the properties for one or more columns of cells with options,
  /// with the width in pixels.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_col The zero indexed first column.
  /// @param last_col  The zero indexed last column.
  /// @param pixels    The width of the column(s) in pixels.
  /// @param format    A pointer to a Format instance or NULL.
  /// @param options   Optional row parameters: hidden, level, collapsed.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_column_pixels_opt()` function is the same as the
  /// `worksheet_set_column_opt()` function except that the width can be set in
  /// pixels.
  int worksheet_set_column_pixels_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_col,
    int last_col,
    int pixels,
    ffi.Pointer<lxw_format> format,
    ffi.Pointer<lxw_row_col_options> options,
  ) {
    return _worksheet_set_column_pixels_opt(
      worksheet,
      first_col,
      last_col,
      pixels,
      format,
      options,
    );
  }

  late final _worksheet_set_column_pixels_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_col_t,
                  lxw_col_t,
                  ffi.Uint32,
                  ffi.Pointer<lxw_format>,
                  ffi.Pointer<lxw_row_col_options>)>>(
      'worksheet_set_column_pixels_opt');
  late final _worksheet_set_column_pixels_opt =
      _worksheet_set_column_pixels_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int,
              ffi.Pointer<lxw_format>, ffi.Pointer<lxw_row_col_options>)>();

  /// @brief Insert an image in a worksheet cell.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param filename  The image filename, with path if required.
  ///
  /// @return A #lxw_error code.
  ///
  /// This function can be used to insert a image into a worksheet. The image can
  /// be in PNG, JPEG, GIF or BMP format:
  ///
  /// @code
  /// worksheet_insert_image(worksheet, 2, 1, "logo.png");
  /// @endcode
  ///
  /// @image html insert_image.png
  ///
  /// The `worksheet_insert_image_opt()` function takes additional optional
  /// parameters to position and scale the image, see below.
  ///
  /// **Note**:
  /// The scaling of a image may be affected if is crosses a row that has its
  /// default height changed due to a font that is larger than the default font
  /// size or that has text wrapping turned on. To avoid this you should
  /// explicitly set the height of the row using `worksheet_set_row()` if it
  /// crosses an inserted image. See @ref working_with_object_positioning.
  ///
  /// BMP images are only supported for backward compatibility. In general it is
  /// best to avoid BMP images since they aren't compressed. If used, BMP images
  /// must be 24 bit, true color, bitmaps.
  int worksheet_insert_image(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _worksheet_insert_image(
      worksheet,
      row,
      col,
      filename,
    );
  }

  late final _worksheet_insert_imagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Pointer<ffi.Char>)>>('worksheet_insert_image');
  late final _worksheet_insert_image = _worksheet_insert_imagePtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<ffi.Char>)>();

  /// @brief Insert an image in a worksheet cell, with options.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param filename  The image filename, with path if required.
  /// @param options   Optional image parameters.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_insert_image_opt()` function is like
  /// `worksheet_insert_image()` function except that it takes an optional
  /// #lxw_image_options struct with the following members/options:
  ///
  /// - `x_offset`: Offset from the left of the cell in pixels.
  /// - `y_offset`: Offset from the top of the cell in pixels.
  /// - `x_scale`: X scale of the image as a decimal.
  /// - `y_scale`: Y scale of the image as a decimal.
  /// - `object_position`: See @ref working_with_object_positioning.
  /// - `description`: Optional description or "Alt text" for the image.
  /// - `decorative`: Optional parameter to mark image as decorative.
  /// - `url`: Add an optional hyperlink to the image.
  /// - `tip`: Add an optional mouseover tip for a hyperlink to the image.
  ///
  /// For example, to scale and position the image:
  ///
  /// @code
  /// lxw_image_options options = {.x_offset = 30,  .y_offset = 10,
  /// .x_scale  = 0.5, .y_scale  = 0.5};
  ///
  /// worksheet_insert_image_opt(worksheet, 2, 1, "logo.png", &options);
  ///
  /// @endcode
  ///
  /// @image html insert_image_opt.png
  ///
  /// The `url` field of lxw_image_options can be use to used to add a hyperlink
  /// to an image:
  ///
  /// @code
  /// lxw_image_options options = {.url = "https://github.com/jmcnamara"};
  ///
  /// worksheet_insert_image_opt(worksheet, 3, 1, "logo.png", &options);
  /// @endcode
  ///
  /// The supported URL formats are the same as those supported by the
  /// `worksheet_write_url()` method and the same rules/limits apply.
  ///
  /// The `tip` field of lxw_image_options can be use to used to add a mouseover
  /// tip to the hyperlink:
  ///
  /// @code
  /// lxw_image_options options = {.url = "https://github.com/jmcnamara",
  /// .tip = "GitHub"};
  ///
  /// worksheet_insert_image_opt(worksheet, 4, 1, "logo.png", &options);
  /// @endcode
  ///
  /// @note See the notes about row scaling and BMP images in
  /// `worksheet_insert_image()` above.
  int worksheet_insert_image_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<lxw_image_options> options,
  ) {
    return _worksheet_insert_image_opt(
      worksheet,
      row,
      col,
      filename,
      options,
    );
  }

  late final _worksheet_insert_image_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_image_options>)>>('worksheet_insert_image_opt');
  late final _worksheet_insert_image_opt =
      _worksheet_insert_image_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_image_options>)>();

  /// @brief Insert an image in a worksheet cell, from a memory buffer.
  ///
  /// @param worksheet    Pointer to a lxw_worksheet instance to be updated.
  /// @param row          The zero indexed row number.
  /// @param col          The zero indexed column number.
  /// @param image_buffer Pointer to an array of bytes that holds the image data.
  /// @param image_size   The size of the array of bytes.
  ///
  /// @return A #lxw_error code.
  ///
  /// This function can be used to insert a image into a worksheet from a memory
  /// buffer:
  ///
  /// @code
  /// worksheet_insert_image_buffer(worksheet, CELL("B3"), image_buffer, image_size);
  /// @endcode
  ///
  /// @image html image_buffer.png
  ///
  /// The buffer should be a pointer to an array of unsigned char data with a
  /// specified size.
  ///
  /// See `worksheet_insert_image()` for details about the supported image
  /// formats, and other image features.
  int worksheet_insert_image_buffer(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.UnsignedChar> image_buffer,
    int image_size,
  ) {
    return _worksheet_insert_image_buffer(
      worksheet,
      row,
      col,
      image_buffer,
      image_size,
    );
  }

  late final _worksheet_insert_image_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('worksheet_insert_image_buffer');
  late final _worksheet_insert_image_buffer =
      _worksheet_insert_image_bufferPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Insert an image in a worksheet cell, from a memory buffer.
  ///
  /// @param worksheet    Pointer to a lxw_worksheet instance to be updated.
  /// @param row          The zero indexed row number.
  /// @param col          The zero indexed column number.
  /// @param image_buffer Pointer to an array of bytes that holds the image data.
  /// @param image_size   The size of the array of bytes.
  /// @param options      Optional image parameters.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_insert_image_buffer_opt()` function is like
  /// `worksheet_insert_image_buffer()` function except that it takes an optional
  /// #lxw_image_options struct  * #lxw_image_options struct with the following members/options:
  ///
  /// - `x_offset`: Offset from the left of the cell in pixels.
  /// - `y_offset`: Offset from the top of the cell in pixels.
  /// - `x_scale`: X scale of the image as a decimal.
  /// - `y_scale`: Y scale of the image as a decimal.
  /// - `object_position`: See @ref working_with_object_positioning.
  /// - `description`: Optional description or "Alt text" for the image.
  /// - `decorative`: Optional parameter to mark image as decorative.
  /// - `url`: Add an optional hyperlink to the image.
  /// - `tip`: Add an optional mouseover tip for a hyperlink to the image.
  ///
  /// For example, to scale and position the image:
  ///
  /// @code
  /// lxw_image_options options = {.x_offset = 32, .y_offset = 4,
  /// .x_scale  = 2,  .y_scale  = 1};
  ///
  /// worksheet_insert_image_buffer_opt(worksheet, CELL("B3"), image_buffer, image_size, &options);
  /// @endcode
  ///
  /// @image html image_buffer_opt.png
  ///
  /// The buffer should be a pointer to an array of unsigned char data with a
  /// specified size.
  ///
  /// See `worksheet_insert_image_buffer_opt()` for details about the supported
  /// image formats, and other image options.
  int worksheet_insert_image_buffer_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<ffi.UnsignedChar> image_buffer,
    int image_size,
    ffi.Pointer<lxw_image_options> options,
  ) {
    return _worksheet_insert_image_buffer_opt(
      worksheet,
      row,
      col,
      image_buffer,
      image_size,
      options,
    );
  }

  late final _worksheet_insert_image_buffer_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  lxw_col_t,
                  ffi.Pointer<ffi.UnsignedChar>,
                  ffi.Size,
                  ffi.Pointer<lxw_image_options>)>>(
      'worksheet_insert_image_buffer_opt');
  late final _worksheet_insert_image_buffer_opt =
      _worksheet_insert_image_buffer_optPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_worksheet>,
              int,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<lxw_image_options>)>();

  /// @brief Set the background image for a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param filename  The image filename, with path if required.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_background()` function can be used to set the
  /// background image for a worksheet:
  ///
  /// @code
  /// worksheet_set_background(worksheet, "logo.png");
  /// @endcode
  ///
  /// @image html background.png
  ///
  /// The ``set_background()`` method supports all the image formats supported by
  /// `worksheet_insert_image()`.
  ///
  /// Some people use this method to add a watermark background to their
  /// document. However, Microsoft recommends using a header image [to set a
  /// watermark][watermark]. The choice of method depends on whether you want the
  /// watermark to be visible in normal viewing mode or just when the file is
  /// printed. In libxlsxwriter you can get the header watermark effect using
  /// `worksheet_set_header()`:
  ///
  /// @code
  /// lxw_header_footer_options header_options = {.image_center = "watermark.png"};
  /// worksheet_set_header_opt(worksheet, "&C&G", &header_options);
  /// @endcode
  ///
  /// [watermark]:https://support.microsoft.com/en-us/office/add-a-watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009
  int worksheet_set_background(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _worksheet_set_background(
      worksheet,
      filename,
    );
  }

  late final _worksheet_set_backgroundPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.Char>)>>('worksheet_set_background');
  late final _worksheet_set_background =
      _worksheet_set_backgroundPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the background image for a worksheet, from a buffer.
  ///
  /// @param worksheet    Pointer to a lxw_worksheet instance to be updated.
  /// @param image_buffer Pointer to an array of bytes that holds the image data.
  /// @param image_size   The size of the array of bytes.
  ///
  /// @return A #lxw_error code.
  ///
  /// This function can be used to insert a background image into a worksheet
  /// from a memory buffer:
  ///
  /// @code
  /// worksheet_set_background_buffer(worksheet, image_buffer, image_size);
  /// @endcode
  ///
  /// The buffer should be a pointer to an array of unsigned char data with a
  /// specified size.
  ///
  /// See `worksheet_set_background()` for more details.
  int worksheet_set_background_buffer(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.UnsignedChar> image_buffer,
    int image_size,
  ) {
    return _worksheet_set_background_buffer(
      worksheet,
      image_buffer,
      image_size,
    );
  }

  late final _worksheet_set_background_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('worksheet_set_background_buffer');
  late final _worksheet_set_background_buffer =
      _worksheet_set_background_bufferPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Insert a chart object into a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The zero indexed row number.
  /// @param col       The zero indexed column number.
  /// @param chart     A #lxw_chart object created via workbook_add_chart().
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_insert_chart()` function can be used to insert a chart into
  /// a worksheet. The chart object must be created first using the
  /// `workbook_add_chart()` function and configured using the @ref chart.h
  /// functions.
  ///
  /// @code
  /// // Create a chart object.
  /// lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_LINE);
  ///
  /// // Add a data series to the chart.
  /// chart_add_series(chart, NULL, "=Sheet1!$A$1:$A$6");
  ///
  /// // Insert the chart into the worksheet.
  /// worksheet_insert_chart(worksheet, 0, 2, chart);
  /// @endcode
  ///
  /// @image html chart_working.png
  ///
  /// **Note:**
  ///
  /// A chart may only be inserted into a worksheet once. If several similar
  /// charts are required then each one must be created separately with
  /// `%worksheet_insert_chart()`.
  int worksheet_insert_chart(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _worksheet_insert_chart(
      worksheet,
      row,
      col,
      chart,
    );
  }

  late final _worksheet_insert_chartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Pointer<lxw_chart>)>>('worksheet_insert_chart');
  late final _worksheet_insert_chart = _worksheet_insert_chartPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, int, ffi.Pointer<lxw_chart>)>();

  /// @brief Insert a chart object into a worksheet, with options.
  ///
  /// @param worksheet    Pointer to a lxw_worksheet instance to be updated.
  /// @param row          The zero indexed row number.
  /// @param col          The zero indexed column number.
  /// @param chart        A #lxw_chart object created via workbook_add_chart().
  /// @param user_options Optional chart parameters.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_insert_chart_opt()` function is like
  /// `worksheet_insert_chart()` function except that it takes an optional
  /// #lxw_chart_options struct to scale and position the chart:
  ///
  /// @code
  /// lxw_chart_options options = {.x_offset = 30,  .y_offset = 10,
  /// .x_scale  = 0.5, .y_scale  = 0.75};
  ///
  /// worksheet_insert_chart_opt(worksheet, 0, 2, chart, &options);
  ///
  /// @endcode
  ///
  /// @image html chart_line_opt.png
  int worksheet_insert_chart_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_options> user_options,
  ) {
    return _worksheet_insert_chart_opt(
      worksheet,
      row,
      col,
      chart,
      user_options,
    );
  }

  late final _worksheet_insert_chart_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_options>)>>('worksheet_insert_chart_opt');
  late final _worksheet_insert_chart_opt =
      _worksheet_insert_chart_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_chart>, ffi.Pointer<lxw_chart_options>)>();

  /// @brief Merge a range of cells.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  /// @param string    String to write to the merged range.
  /// @param format    A pointer to a Format instance or NULL.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_merge_range()` function allows cells to be merged together
  /// so that they act as a single area.
  ///
  /// Excel generally merges and centers cells at same time. To get similar
  /// behavior with libxlsxwriter you need to apply a @ref format.h "Format"
  /// object with the appropriate alignment:
  ///
  /// @code
  /// lxw_format *merge_format = workbook_add_format(workbook);
  /// format_set_align(merge_format, LXW_ALIGN_CENTER);
  ///
  /// worksheet_merge_range(worksheet, 1, 1, 1, 3, "Merged Range", merge_format);
  ///
  /// @endcode
  ///
  /// It is possible to apply other formatting to the merged cells as well:
  ///
  /// @code
  /// format_set_align   (merge_format, LXW_ALIGN_CENTER);
  /// format_set_align   (merge_format, LXW_ALIGN_VERTICAL_CENTER);
  /// format_set_border  (merge_format, LXW_BORDER_DOUBLE);
  /// format_set_bold    (merge_format);
  /// format_set_bg_color(merge_format, 0xD7E4BC);
  ///
  /// worksheet_merge_range(worksheet, 2, 1, 3, 3, "Merged Range", merge_format);
  ///
  /// @endcode
  ///
  /// @image html merge.png
  ///
  /// The `%worksheet_merge_range()` function writes a `char*` string using
  /// `worksheet_write_string()`. In order to write other data types, such as a
  /// number or a formula, you can overwrite the first cell with a call to one of
  /// the other write functions. The same Format should be used as was used in
  /// the merged range.
  ///
  /// @code
  /// // First write a range with a blank string.
  /// worksheet_merge_range (worksheet, 1, 1, 1, 3, "", format);
  ///
  /// // Then overwrite the first cell with a number.
  /// worksheet_write_number(worksheet, 1, 1, 123, format);
  /// @endcode
  ///
  /// @note Merged ranges generally don't work in libxlsxwriter when the Workbook
  /// #lxw_workbook_options `constant_memory` mode is enabled.
  int worksheet_merge_range(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_format> format,
  ) {
    return _worksheet_merge_range(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      string,
      format,
    );
  }

  late final _worksheet_merge_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_format>)>>('worksheet_merge_range');
  late final _worksheet_merge_range = _worksheet_merge_rangePtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
          ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_format>)>();

  /// @brief Set the autofilter area in the worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_autofilter()` function allows an autofilter to be added to
  /// a worksheet.
  ///
  /// An autofilter is a way of adding drop down lists to the headers of a 2D
  /// range of worksheet data. This allows users to filter the data based on
  /// simple criteria so that some data is shown and some is hidden.
  ///
  /// @image html autofilter3.png
  ///
  /// To add an autofilter to a worksheet:
  ///
  /// @code
  /// worksheet_autofilter(worksheet, 0, 0, 50, 3);
  ///
  /// // Same as above using the RANGE() macro.
  /// worksheet_autofilter(worksheet, RANGE("A1:D51"));
  /// @endcode
  ///
  /// In order to apply a filter condition it is necessary to add filter rules to
  /// the columns using either the `%worksheet_filter_column()`,
  /// `%worksheet_filter_column2()` or `%worksheet_filter_list()` functions:
  ///
  /// - `worksheet_filter_column()`: filter on a single criterion such as "Column ==
  /// East". More complex conditions such as "<=" or ">=" can also be use.
  ///
  /// - `worksheet_filter_column2()`: filter on two criteria such as "Column == East
  /// or Column == West". Complex conditions can also be used.
  ///
  /// - `worksheet_filter_list()`: filter on a list of values such as "Column in (East, West,
  /// North)".
  ///
  /// These functions are explained below. It isn't sufficient to just specify
  /// the filter condition. You must also hide any rows that don't match the
  /// filter condition. See @ref ww_autofilters_data for more details.
  int worksheet_autofilter(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _worksheet_autofilter(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _worksheet_autofilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t)>>('worksheet_autofilter');
  late final _worksheet_autofilter = _worksheet_autofilterPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int)>();

  /// @brief Write a filter rule to an autofilter column.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param col       The column in the autofilter that the rule applies to.
  /// @param rule      The lxw_filter_rule autofilter rule.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `worksheet_filter_column` function can be used to filter columns in a
  /// autofilter range based on single rule conditions:
  ///
  /// @code
  /// lxw_filter_rule filter_rule = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
  /// .value_string = "East"};
  ///
  /// worksheet_filter_column(worksheet, 0, &filter_rule);
  /// @endcode
  ///
  /// @image html autofilter4.png
  ///
  /// The rules and criteria are explained in more detail in @ref
  /// ww_autofilters_criteria in @ref working_with_autofilters.
  ///
  /// The `col` parameter is a zero indexed column number and must refer to a
  /// column in an existing autofilter created with `worksheet_autofilter()`.
  ///
  /// It isn't sufficient to just specify the filter condition. You must also
  /// hide any rows that don't match the filter condition. See @ref
  /// ww_autofilters_data for more details.
  int worksheet_filter_column(
    ffi.Pointer<lxw_worksheet> worksheet,
    int col,
    ffi.Pointer<lxw_filter_rule> rule,
  ) {
    return _worksheet_filter_column(
      worksheet,
      col,
      rule,
    );
  }

  late final _worksheet_filter_columnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_col_t,
              ffi.Pointer<lxw_filter_rule>)>>('worksheet_filter_column');
  late final _worksheet_filter_column = _worksheet_filter_columnPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_worksheet>, int, ffi.Pointer<lxw_filter_rule>)>();

  /// @brief Write two filter rules to an autofilter column.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param col       The column in the autofilter that the rules applies to.
  /// @param rule1     First lxw_filter_rule autofilter rule.
  /// @param rule2     Second lxw_filter_rule autofilter rule.
  /// @param and_or    A #lxw_filter_operator and/or operator.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `worksheet_filter_column2` function can be used to filter columns in a autofilter
  /// range based on two rule conditions:
  ///
  /// @code
  /// lxw_filter_rule filter_rule1 = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
  /// .value_string = "East"};
  ///
  /// lxw_filter_rule filter_rule2 = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
  /// .value_string = "South"};
  ///
  /// worksheet_filter_column2(worksheet, 0, &filter_rule1, &filter_rule2, LXW_FILTER_OR);
  /// @endcode
  ///
  /// @image html autofilter5.png
  ///
  /// The rules and criteria are explained in more detail in @ref
  /// ww_autofilters_criteria in @ref working_with_autofilters.
  ///
  /// The `col` parameter is a zero indexed column number and must refer to a
  /// column in an existing autofilter created with `worksheet_autofilter()`.
  ///
  /// The `and_or` parameter is either "and (LXW_FILTER_AND)" or "or  (LXW_FILTER_OR)".
  ///
  /// It isn't sufficient to just specify the filter condition. You must also
  /// hide any rows that don't match the filter condition. See @ref
  /// ww_autofilters_data for more details.
  int worksheet_filter_column2(
    ffi.Pointer<lxw_worksheet> worksheet,
    int col,
    ffi.Pointer<lxw_filter_rule> rule1,
    ffi.Pointer<lxw_filter_rule> rule2,
    int and_or,
  ) {
    return _worksheet_filter_column2(
      worksheet,
      col,
      rule1,
      rule2,
      and_or,
    );
  }

  late final _worksheet_filter_column2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_col_t,
              ffi.Pointer<lxw_filter_rule>,
              ffi.Pointer<lxw_filter_rule>,
              ffi.Uint8)>>('worksheet_filter_column2');
  late final _worksheet_filter_column2 =
      _worksheet_filter_column2Ptr.asFunction<
          int Function(
              ffi.Pointer<lxw_worksheet>,
              int,
              ffi.Pointer<lxw_filter_rule>,
              ffi.Pointer<lxw_filter_rule>,
              int)>();

  /// @brief Write multiple string filters to an autofilter column.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param col       The column in the autofilter that the rules applies to.
  /// @param list      A NULL terminated array of strings to filter on.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `worksheet_filter_column_list()` function can be used specify multiple
  /// string matching criteria. This is a newer type of filter introduced in
  /// Excel 2007. Prior to that it was only possible to have either 1 or 2 filter
  /// conditions, such as the ones used by `worksheet_filter_column()` and
  /// `worksheet_filter_column2()`.
  ///
  /// As an example, consider a column that contains data for the months of the
  /// year. The `%worksheet_filter_list()` function can be used to filter out
  /// data rows for different months:
  ///
  /// @code
  /// char* list[] = {"March", "April", "May", NULL};
  ///
  /// worksheet_filter_list(worksheet, 0, list);
  /// @endcode
  ///
  /// @image html autofilter2.png
  ///
  ///
  /// Note, the array must be NULL terminated to indicate the end of the array of
  /// strings. To filter blanks as part of the list use `Blanks` as a list item:
  ///
  /// @code
  /// char* list[] = {"March", "April", "May", "Blanks", NULL};
  ///
  /// worksheet_filter_list(worksheet, 0, list);
  /// @endcode
  ///
  /// It isn't sufficient to just specify the filter condition. You must also
  /// hide any rows that don't match the filter condition. See @ref
  /// ww_autofilters_data for more details.
  int worksheet_filter_list(
    ffi.Pointer<lxw_worksheet> worksheet,
    int col,
    ffi.Pointer<ffi.Pointer<ffi.Char>> list,
  ) {
    return _worksheet_filter_list(
      worksheet,
      col,
      list,
    );
  }

  late final _worksheet_filter_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_col_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('worksheet_filter_list');
  late final _worksheet_filter_list = _worksheet_filter_listPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// @brief Add a data validation to a cell.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param row        The zero indexed row number.
  /// @param col        The zero indexed column number.
  /// @param validation A #lxw_data_validation object to control the validation.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_data_validation_cell()` function is used to construct an
  /// Excel data validation or to limit the user input to a dropdown list of
  /// values:
  ///
  /// @code
  ///
  /// lxw_data_validation *data_validation = calloc(1, sizeof(lxw_data_validation));
  ///
  /// data_validation->validate       = LXW_VALIDATION_TYPE_INTEGER;
  /// data_validation->criteria       = LXW_VALIDATION_CRITERIA_BETWEEN;
  /// data_validation->minimum_number = 1;
  /// data_validation->maximum_number = 10;
  ///
  /// worksheet_data_validation_cell(worksheet, 2, 1, data_validation);
  ///
  /// // Same as above with the CELL() macro.
  /// worksheet_data_validation_cell(worksheet, CELL("B3"), data_validation);
  ///
  /// @endcode
  ///
  /// @image html data_validate4.png
  ///
  /// Data validation and the various options of #lxw_data_validation are
  /// described in more detail in @ref working_with_data_validation.
  int worksheet_data_validation_cell(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_data_validation> validation,
  ) {
    return _worksheet_data_validation_cell(
      worksheet,
      row,
      col,
      validation,
    );
  }

  late final _worksheet_data_validation_cellPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t,
                  lxw_col_t, ffi.Pointer<lxw_data_validation>)>>(
      'worksheet_data_validation_cell');
  late final _worksheet_data_validation_cell =
      _worksheet_data_validation_cellPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_data_validation>)>();

  /// @brief Add a data validation to a range.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row  The first row of the range. (All zero indexed.)
  /// @param first_col  The first column of the range.
  /// @param last_row   The last row of the range.
  /// @param last_col   The last col of the range.
  /// @param validation A #lxw_data_validation object to control the validation.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_data_validation_range()` function is the same as the
  /// `%worksheet_data_validation_cell()`, see above,  except the data validation
  /// is applied to a range of cells:
  ///
  /// @code
  ///
  /// lxw_data_validation *data_validation = calloc(1, sizeof(lxw_data_validation));
  ///
  /// data_validation->validate       = LXW_VALIDATION_TYPE_INTEGER;
  /// data_validation->criteria       = LXW_VALIDATION_CRITERIA_BETWEEN;
  /// data_validation->minimum_number = 1;
  /// data_validation->maximum_number = 10;
  ///
  /// worksheet_data_validation_range(worksheet, 2, 1, 4, 1, data_validation);
  ///
  /// // Same as above with the RANGE() macro.
  /// worksheet_data_validation_range(worksheet, RANGE("B3:B5"), data_validation);
  ///
  /// @endcode
  ///
  /// Data validation and the various options of #lxw_data_validation are
  /// described in more detail in @ref working_with_data_validation.
  int worksheet_data_validation_range(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<lxw_data_validation> validation,
  ) {
    return _worksheet_data_validation_range(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      validation,
    );
  }

  late final _worksheet_data_validation_rangePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  lxw_col_t,
                  lxw_row_t,
                  lxw_col_t,
                  ffi.Pointer<lxw_data_validation>)>>(
      'worksheet_data_validation_range');
  late final _worksheet_data_validation_range =
      _worksheet_data_validation_rangePtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<lxw_data_validation>)>();

  /// @brief Add a conditional format to a worksheet cell.
  ///
  /// @param worksheet           Pointer to a lxw_worksheet instance to be updated.
  /// @param row                 The zero indexed row number.
  /// @param col                 The zero indexed column number.
  /// @param conditional_format  A #lxw_conditional_format object to control the
  /// conditional format.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_conditional_format_cell()` function is used to set a
  /// conditional format for a cell in a worksheet:
  ///
  /// @code
  /// conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
  /// conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO;
  /// conditional_format->value    = 50;
  /// conditional_format->format   = format1;
  /// worksheet_conditional_format_cell(worksheet, CELL("A1"), conditional_format);
  /// @endcode
  ///
  /// The conditional format parameters is specified in #lxw_conditional_format.
  ///
  /// See @ref working_with_conditional_formatting for full details.
  int worksheet_conditional_format_cell(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_conditional_format> conditional_format,
  ) {
    return _worksheet_conditional_format_cell(
      worksheet,
      row,
      col,
      conditional_format,
    );
  }

  late final _worksheet_conditional_format_cellPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t,
                  lxw_col_t, ffi.Pointer<lxw_conditional_format>)>>(
      'worksheet_conditional_format_cell');
  late final _worksheet_conditional_format_cell =
      _worksheet_conditional_format_cellPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_conditional_format>)>();

  /// @brief Add a conditional format to a worksheet range.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row  The first row of the range. (All zero indexed.)
  /// @param first_col  The first column of the range.
  /// @param last_row   The last row of the range.
  /// @param last_col   The last col of the range.
  /// @param conditional_format  A #lxw_conditional_format object to control the
  /// conditional format.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_conditional_format_cell()` function is used to set a
  /// conditional format for a range of cells in a worksheet:
  ///
  /// @code
  /// conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
  /// conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO;
  /// conditional_format->value    = 50;
  /// conditional_format->format   = format1;
  /// worksheet_conditional_format_range(worksheet1, RANGE("B3:K12"), conditional_format);
  ///
  /// conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
  /// conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_LESS_THAN;
  /// conditional_format->value    = 50;
  /// conditional_format->format   = format2;
  /// worksheet_conditional_format_range(worksheet1, RANGE("B3:K12"), conditional_format);
  /// @endcode
  ///
  /// Output:
  ///
  /// @image html conditional_format1.png
  ///
  ///
  /// The conditional format parameters is specified in #lxw_conditional_format.
  ///
  /// See @ref working_with_conditional_formatting for full details.
  int worksheet_conditional_format_range(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<lxw_conditional_format> conditional_format,
  ) {
    return _worksheet_conditional_format_range(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      conditional_format,
    );
  }

  late final _worksheet_conditional_format_rangePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  lxw_row_t,
                  lxw_col_t,
                  lxw_row_t,
                  lxw_col_t,
                  ffi.Pointer<lxw_conditional_format>)>>(
      'worksheet_conditional_format_range');
  late final _worksheet_conditional_format_range =
      _worksheet_conditional_format_rangePtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
              ffi.Pointer<lxw_conditional_format>)>();

  /// @brief Insert a button object into a worksheet.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param row        The zero indexed row number.
  /// @param col        The zero indexed column number.
  /// @param options    A #lxw_button_options object to set the button properties.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_insert_button()` function can be used to insert an Excel
  /// form button into a worksheet. This function is generally only useful when
  /// used in conjunction with the `workbook_add_vba_project()` function to tie
  /// the button to a macro from an embedded VBA project:
  ///
  /// @code
  /// lxw_button_options options = {.caption = "Press Me",
  /// .macro   = "say_hello"};
  ///
  /// worksheet_insert_button(worksheet, 2, 1, &options);
  /// @endcode
  ///
  /// @image html macros.png
  ///
  /// The button properties are set using the lxw_button_options struct.
  ///
  /// See also @ref working_with_macros
  int worksheet_insert_button(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
    ffi.Pointer<lxw_button_options> options,
  ) {
    return _worksheet_insert_button(
      worksheet,
      row,
      col,
      options,
    );
  }

  late final _worksheet_insert_buttonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              ffi.Pointer<lxw_button_options>)>>('worksheet_insert_button');
  late final _worksheet_insert_button = _worksheet_insert_buttonPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int,
          ffi.Pointer<lxw_button_options>)>();

  /// @brief Add an Excel table to a worksheet.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row  The first row of the range. (All zero indexed.)
  /// @param first_col  The first column of the range.
  /// @param last_row   The last row of the range.
  /// @param last_col   The last col of the range.
  /// @param options    A #lxw_table_options struct to define the table options.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_add_table()` function is used to add a table to a
  /// worksheet. Tables in Excel are a way of grouping a range of cells into a
  /// single entity that has common formatting or that can be referenced from
  /// formulas. Tables can have column headers, autofilters, total rows, column
  /// formulas and default formatting.
  ///
  /// @code
  /// worksheet_add_table(worksheet, 2, 1, 6, 5, NULL);
  /// @endcode
  ///
  /// Output:
  ///
  /// @image html tables1.png
  ///
  /// See @ref working_with_tables for more detailed usage information and also
  /// @ref tables.c.
  int worksheet_add_table(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
    ffi.Pointer<lxw_table_options> options,
  ) {
    return _worksheet_add_table(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
      options,
    );
  }

  late final _worksheet_add_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_worksheet>,
              lxw_row_t,
              lxw_col_t,
              lxw_row_t,
              lxw_col_t,
              ffi.Pointer<lxw_table_options>)>>('worksheet_add_table');
  late final _worksheet_add_table = _worksheet_add_tablePtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int,
          ffi.Pointer<lxw_table_options>)>();

  /// @brief Make a worksheet the active, i.e., visible worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_activate()` function is used to specify which worksheet is
  /// initially visible in a multi-sheet workbook:
  ///
  /// @code
  /// lxw_worksheet *worksheet1 = workbook_add_worksheet(workbook, NULL);
  /// lxw_worksheet *worksheet2 = workbook_add_worksheet(workbook, NULL);
  /// lxw_worksheet *worksheet3 = workbook_add_worksheet(workbook, NULL);
  ///
  /// worksheet_activate(worksheet3);
  /// @endcode
  ///
  /// @image html worksheet_activate.png
  ///
  /// More than one worksheet can be selected via the `worksheet_select()`
  /// function, see below, however only one worksheet can be active.
  ///
  /// The default active worksheet is the first worksheet.
  void worksheet_activate(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_activate(
      worksheet,
    );
  }

  late final _worksheet_activatePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_activate');
  late final _worksheet_activate = _worksheet_activatePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set a worksheet tab as selected.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_select()` function is used to indicate that a worksheet is
  /// selected in a multi-sheet workbook:
  ///
  /// @code
  /// worksheet_activate(worksheet1);
  /// worksheet_select(worksheet2);
  /// worksheet_select(worksheet3);
  ///
  /// @endcode
  ///
  /// A selected worksheet has its tab highlighted. Selecting worksheets is a
  /// way of grouping them together so that, for example, several worksheets
  /// could be printed in one go. A worksheet that has been activated via the
  /// `worksheet_activate()` function will also appear as selected.
  void worksheet_select(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_select(
      worksheet,
    );
  }

  late final _worksheet_selectPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_select');
  late final _worksheet_select = _worksheet_selectPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Hide the current worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_hide()` function is used to hide a worksheet:
  ///
  /// @code
  /// worksheet_hide(worksheet2);
  /// @endcode
  ///
  /// You may wish to hide a worksheet in order to avoid confusing a user with
  /// intermediate data or calculations.
  ///
  /// @image html hide_sheet.png
  ///
  /// A hidden worksheet can not be activated or selected so this function is
  /// mutually exclusive with the `worksheet_activate()` and `worksheet_select()`
  /// functions. In addition, since the first worksheet will default to being the
  /// active worksheet, you cannot hide the first worksheet without activating
  /// another sheet:
  ///
  /// @code
  /// worksheet_activate(worksheet2);
  /// worksheet_hide(worksheet1);
  /// @endcode
  void worksheet_hide(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_hide(
      worksheet,
    );
  }

  late final _worksheet_hidePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_hide');
  late final _worksheet_hide = _worksheet_hidePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set current worksheet as the first visible sheet tab.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `worksheet_activate()` function determines which worksheet is initially
  /// selected.  However, if there are a large number of worksheets the selected
  /// worksheet may not appear on the screen. To avoid this you can select the
  /// leftmost visible worksheet tab using `%worksheet_set_first_sheet()`:
  ///
  /// @code
  /// worksheet_set_first_sheet(worksheet19); // First visible worksheet tab.
  /// worksheet_activate(worksheet20);        // First visible worksheet.
  /// @endcode
  ///
  /// This function is not required very often. The default value is the first
  /// worksheet.
  void worksheet_set_first_sheet(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_set_first_sheet(
      worksheet,
    );
  }

  late final _worksheet_set_first_sheetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_set_first_sheet');
  late final _worksheet_set_first_sheet = _worksheet_set_first_sheetPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Split and freeze a worksheet into panes.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The cell row (zero indexed).
  /// @param col       The cell column (zero indexed).
  ///
  /// The `%worksheet_freeze_panes()` function can be used to divide a worksheet
  /// into horizontal or vertical regions known as panes and to "freeze" these
  /// panes so that the splitter bars are not visible.
  ///
  /// The parameters `row` and `col` are used to specify the location of the
  /// split. It should be noted that the split is specified at the top or left of
  /// a cell and that the function uses zero based indexing. Therefore to freeze
  /// the first row of a worksheet it is necessary to specify the split at row 2
  /// (which is 1 as the zero-based index).
  ///
  /// You can set one of the `row` and `col` parameters as zero if you do not
  /// want either a vertical or horizontal split.
  ///
  /// Examples:
  ///
  /// @code
  /// worksheet_freeze_panes(worksheet1, 1, 0); // Freeze the first row.
  /// worksheet_freeze_panes(worksheet2, 0, 1); // Freeze the first column.
  /// worksheet_freeze_panes(worksheet3, 1, 1); // Freeze first row/column.
  ///
  /// @endcode
  void worksheet_freeze_panes(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
  ) {
    return _worksheet_freeze_panes(
      worksheet,
      row,
      col,
    );
  }

  late final _worksheet_freeze_panesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, lxw_row_t,
              lxw_col_t)>>('worksheet_freeze_panes');
  late final _worksheet_freeze_panes = _worksheet_freeze_panesPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  /// @brief Split a worksheet into panes.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param vertical   The position for the vertical split.
  /// @param horizontal The position for the horizontal split.
  ///
  /// The `%worksheet_split_panes()` function can be used to divide a worksheet
  /// into horizontal or vertical regions known as panes. This function is
  /// different from the `worksheet_freeze_panes()` function in that the splits
  /// between the panes will be visible to the user and each pane will have its
  /// own scroll bars.
  ///
  /// The parameters `vertical` and `horizontal` are used to specify the vertical
  /// and horizontal position of the split. The units for `vertical` and
  /// `horizontal` are the same as those used by Excel to specify row height and
  /// column width. However, the vertical and horizontal units are different from
  /// each other. Therefore you must specify the `vertical` and `horizontal`
  /// parameters in terms of the row heights and column widths that you have set
  /// or the default values which are 15 for a row and 8.43 for a column.
  ///
  /// Examples:
  ///
  /// @code
  /// worksheet_split_panes(worksheet1, 15, 0);    // First row.
  /// worksheet_split_panes(worksheet2, 0,  8.43); // First column.
  /// worksheet_split_panes(worksheet3, 15, 8.43); // First row and column.
  ///
  /// @endcode
  void worksheet_split_panes(
    ffi.Pointer<lxw_worksheet> worksheet,
    double vertical,
    double horizontal,
  ) {
    return _worksheet_split_panes(
      worksheet,
      vertical,
      horizontal,
    );
  }

  late final _worksheet_split_panesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Double,
              ffi.Double)>>('worksheet_split_panes');
  late final _worksheet_split_panes = _worksheet_split_panesPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, double, double)>();

  /// worksheet_freeze_panes() with infrequent options. Undocumented for now.
  void worksheet_freeze_panes_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int top_row,
    int left_col,
    int type,
  ) {
    return _worksheet_freeze_panes_opt(
      worksheet,
      first_row,
      first_col,
      top_row,
      left_col,
      type,
    );
  }

  late final _worksheet_freeze_panes_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t, ffi.Uint8)>>('worksheet_freeze_panes_opt');
  late final _worksheet_freeze_panes_opt =
      _worksheet_freeze_panes_optPtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int, int, int, int, int)>();

  /// worksheet_split_panes() with infrequent options. Undocumented for now.
  void worksheet_split_panes_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    double vertical,
    double horizontal,
    int top_row,
    int left_col,
  ) {
    return _worksheet_split_panes_opt(
      worksheet,
      vertical,
      horizontal,
      top_row,
      left_col,
    );
  }

  late final _worksheet_split_panes_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Double, ffi.Double,
              lxw_row_t, lxw_col_t)>>('worksheet_split_panes_opt');
  late final _worksheet_split_panes_opt =
      _worksheet_split_panes_optPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_worksheet>, double, double, int, int)>();

  /// @brief Set the selected cell or cells in a worksheet:
  ///
  /// @param worksheet   A pointer to a lxw_worksheet instance to be updated.
  /// @param first_row   The first row of the range. (All zero indexed.)
  /// @param first_col   The first column of the range.
  /// @param last_row    The last row of the range.
  /// @param last_col    The last col of the range.
  ///
  ///
  /// The `%worksheet_set_selection()` function can be used to specify which cell
  /// or range of cells is selected in a worksheet: The most common requirement
  /// is to select a single cell, in which case the `first_` and `last_`
  /// parameters should be the same.
  ///
  /// The active cell within a selected range is determined by the order in which
  /// `first_` and `last_` are specified.
  ///
  /// Examples:
  ///
  /// @code
  /// worksheet_set_selection(worksheet1, 3, 3, 3, 3);     // Cell D4.
  /// worksheet_set_selection(worksheet2, 3, 3, 6, 6);     // Cells D4 to G7.
  /// worksheet_set_selection(worksheet3, 6, 6, 3, 3);     // Cells G7 to D4.
  /// worksheet_set_selection(worksheet5, RANGE("D4:G7")); // Using the RANGE macro.
  ///
  /// @endcode
  void worksheet_set_selection(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _worksheet_set_selection(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _worksheet_set_selectionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t)>>('worksheet_set_selection');
  late final _worksheet_set_selection = _worksheet_set_selectionPtr.asFunction<
      void Function(ffi.Pointer<lxw_worksheet>, int, int, int, int)>();

  /// @brief Set the first visible cell at the top left of a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param row       The cell row (zero indexed).
  /// @param col       The cell column (zero indexed).
  ///
  /// The `%worksheet_set_top_left_cell()` function can be used to set the
  /// top leftmost visible cell in the worksheet:
  ///
  /// @code
  /// worksheet_set_top_left_cell(worksheet, 31, 26);
  /// worksheet_set_top_left_cell(worksheet, CELL("AA32")); // Same as above.
  /// @endcode
  ///
  /// @image html top_left_cell.png
  void worksheet_set_top_left_cell(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row,
    int col,
  ) {
    return _worksheet_set_top_left_cell(
      worksheet,
      row,
      col,
    );
  }

  late final _worksheet_set_top_left_cellPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, lxw_row_t,
              lxw_col_t)>>('worksheet_set_top_left_cell');
  late final _worksheet_set_top_left_cell = _worksheet_set_top_left_cellPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  /// @brief Set the page orientation as landscape.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// This function is used to set the orientation of a worksheet's printed page
  /// to landscape:
  ///
  /// @code
  /// worksheet_set_landscape(worksheet);
  /// @endcode
  void worksheet_set_landscape(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_set_landscape(
      worksheet,
    );
  }

  late final _worksheet_set_landscapePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_set_landscape');
  late final _worksheet_set_landscape = _worksheet_set_landscapePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the page orientation as portrait.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// This function is used to set the orientation of a worksheet's printed page
  /// to portrait. The default worksheet orientation is portrait, so this
  /// function isn't generally required:
  ///
  /// @code
  /// worksheet_set_portrait(worksheet);
  /// @endcode
  void worksheet_set_portrait(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_set_portrait(
      worksheet,
    );
  }

  late final _worksheet_set_portraitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_set_portrait');
  late final _worksheet_set_portrait = _worksheet_set_portraitPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the page layout to page view mode.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// This function is used to display the worksheet in "Page View/Layout" mode:
  ///
  /// @code
  /// worksheet_set_page_view(worksheet);
  /// @endcode
  void worksheet_set_page_view(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_set_page_view(
      worksheet,
    );
  }

  late final _worksheet_set_page_viewPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_set_page_view');
  late final _worksheet_set_page_view = _worksheet_set_page_viewPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the paper type for printing.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param paper_type The Excel paper format type.
  ///
  /// This function is used to set the paper format for the printed output of a
  /// worksheet. The following paper styles are available:
  ///
  ///
  /// Index    | Paper format            | Paper size
  /// :------- | :---------------------- | :-------------------
  /// 0        | Printer default         | Printer default
  /// 1        | Letter                  | 8 1/2 x 11 in
  /// 2        | Letter Small            | 8 1/2 x 11 in
  /// 3        | Tabloid                 | 11 x 17 in
  /// 4        | Ledger                  | 17 x 11 in
  /// 5        | Legal                   | 8 1/2 x 14 in
  /// 6        | Statement               | 5 1/2 x 8 1/2 in
  /// 7        | Executive               | 7 1/4 x 10 1/2 in
  /// 8        | A3                      | 297 x 420 mm
  /// 9        | A4                      | 210 x 297 mm
  /// 10       | A4 Small                | 210 x 297 mm
  /// 11       | A5                      | 148 x 210 mm
  /// 12       | B4                      | 250 x 354 mm
  /// 13       | B5                      | 182 x 257 mm
  /// 14       | Folio                   | 8 1/2 x 13 in
  /// 15       | Quarto                  | 215 x 275 mm
  /// 16       | ---                     | 10x14 in
  /// 17       | ---                     | 11x17 in
  /// 18       | Note                    | 8 1/2 x 11 in
  /// 19       | Envelope 9              | 3 7/8 x 8 7/8
  /// 20       | Envelope 10             | 4 1/8 x 9 1/2
  /// 21       | Envelope 11             | 4 1/2 x 10 3/8
  /// 22       | Envelope 12             | 4 3/4 x 11
  /// 23       | Envelope 14             | 5 x 11 1/2
  /// 24       | C size sheet            | ---
  /// 25       | D size sheet            | ---
  /// 26       | E size sheet            | ---
  /// 27       | Envelope DL             | 110 x 220 mm
  /// 28       | Envelope C3             | 324 x 458 mm
  /// 29       | Envelope C4             | 229 x 324 mm
  /// 30       | Envelope C5             | 162 x 229 mm
  /// 31       | Envelope C6             | 114 x 162 mm
  /// 32       | Envelope C65            | 114 x 229 mm
  /// 33       | Envelope B4             | 250 x 353 mm
  /// 34       | Envelope B5             | 176 x 250 mm
  /// 35       | Envelope B6             | 176 x 125 mm
  /// 36       | Envelope                | 110 x 230 mm
  /// 37       | Monarch                 | 3.875 x 7.5 in
  /// 38       | Envelope                | 3 5/8 x 6 1/2 in
  /// 39       | Fanfold                 | 14 7/8 x 11 in
  /// 40       | German Std Fanfold      | 8 1/2 x 12 in
  /// 41       | German Legal Fanfold    | 8 1/2 x 13 in
  ///
  /// Note, it is likely that not all of these paper types will be available to
  /// the end user since it will depend on the paper formats that the user's
  /// printer supports. Therefore, it is best to stick to standard paper types:
  ///
  /// @code
  /// worksheet_set_paper(worksheet1, 1);  // US Letter
  /// worksheet_set_paper(worksheet2, 9);  // A4
  /// @endcode
  ///
  /// If you do not specify a paper type the worksheet will print using the
  /// printer's default paper style.
  void worksheet_set_paper(
    ffi.Pointer<lxw_worksheet> worksheet,
    int paper_type,
  ) {
    return _worksheet_set_paper(
      worksheet,
      paper_type,
    );
  }

  late final _worksheet_set_paperPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_worksheet>, ffi.Uint8)>>('worksheet_set_paper');
  late final _worksheet_set_paper = _worksheet_set_paperPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Set the worksheet margins for the printed page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param left    Left margin in inches.   Excel default is 0.7.
  /// @param right   Right margin in inches.  Excel default is 0.7.
  /// @param top     Top margin in inches.    Excel default is 0.75.
  /// @param bottom  Bottom margin in inches. Excel default is 0.75.
  ///
  /// The `%worksheet_set_margins()` function is used to set the margins of the
  /// worksheet when it is printed. The units are in inches. Specifying `-1` for
  /// any parameter will give the default Excel value as shown above.
  ///
  /// @code
  /// worksheet_set_margins(worksheet, 1.3, 1.2, -1, -1);
  /// @endcode
  void worksheet_set_margins(
    ffi.Pointer<lxw_worksheet> worksheet,
    double left,
    double right,
    double top,
    double bottom,
  ) {
    return _worksheet_set_margins(
      worksheet,
      left,
      right,
      top,
      bottom,
    );
  }

  late final _worksheet_set_marginsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Double, ffi.Double,
              ffi.Double, ffi.Double)>>('worksheet_set_margins');
  late final _worksheet_set_margins = _worksheet_set_marginsPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_worksheet>, double, double, double, double)>();

  /// @brief Set the printed page header caption.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param string    The header string.
  ///
  /// @return A #lxw_error code.
  ///
  /// Headers and footers are generated using a string which is a combination of
  /// plain text and control characters.
  ///
  /// The available control character are:
  ///
  ///
  /// | Control         | Category      | Description           |
  /// | --------------- | ------------- | --------------------- |
  /// | `&L`            | Justification | Left                  |
  /// | `&C`            |               | Center                |
  /// | `&R`            |               | Right                 |
  /// | `&P`            | Information   | Page number           |
  /// | `&N`            |               | Total number of pages |
  /// | `&D`            |               | Date                  |
  /// | `&T`            |               | Time                  |
  /// | `&F`            |               | File name             |
  /// | `&A`            |               | Worksheet name        |
  /// | `&Z`            |               | Workbook path         |
  /// | `&fontsize`     | Font          | Font size             |
  /// | `&"font,style"` |               | Font name and style   |
  /// | `&U`            |               | Single underline      |
  /// | `&E`            |               | Double underline      |
  /// | `&S`            |               | Strikethrough         |
  /// | `&X`            |               | Superscript           |
  /// | `&Y`            |               | Subscript             |
  /// | `&[Picture]`    | Images        | Image placeholder     |
  /// | `&G`            |               | Same as `&[Picture]`  |
  /// | `&&`            | Miscellaneous | Literal ampersand &   |
  ///
  /// Note: inserting images requires the `worksheet_set_header_opt()` function.
  ///
  /// Text in headers and footers can be justified (aligned) to the left, center
  /// and right by prefixing the text with the control characters `&L`, `&C` and
  /// `&R`.
  ///
  /// For example (with ASCII art representation of the results):
  ///
  /// @code
  /// worksheet_set_header(worksheet, "&LHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    | Hello                                                         |
  /// //    |                                                               |
  ///
  ///
  /// worksheet_set_header(worksheet, "&CHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                          Hello                                |
  /// //    |                                                               |
  ///
  ///
  /// worksheet_set_header(worksheet, "&RHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                                                         Hello |
  /// //    |                                                               |
  ///
  ///
  /// @endcode
  ///
  /// For simple text, if you do not specify any justification the text will be
  /// centered. However, you must prefix the text with `&C` if you specify a font
  /// name or any other formatting:
  ///
  /// @code
  /// worksheet_set_header(worksheet, "Hello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                          Hello                                |
  /// //    |                                                               |
  ///
  /// @endcode
  ///
  /// You can have text in each of the justification regions:
  ///
  /// @code
  /// worksheet_set_header(worksheet, "&LCiao&CBello&RCielo");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    | Ciao                     Bello                          Cielo |
  /// //    |                                                               |
  ///
  /// @endcode
  ///
  /// The information control characters act as variables that Excel will update
  /// as the workbook or worksheet changes. Times and dates are in the users
  /// default format:
  ///
  /// @code
  /// worksheet_set_header(worksheet, "&CPage &P of &N");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                        Page 1 of 6                            |
  /// //    |                                                               |
  ///
  /// worksheet_set_header(worksheet, "&CUpdated at &T");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                    Updated at 12:30 PM                        |
  /// //    |                                                               |
  ///
  /// @endcode
  ///
  /// You can specify the font size of a section of the text by prefixing it with
  /// the control character `&n` where `n` is the font size:
  ///
  /// @code
  /// worksheet_set_header(worksheet1, "&C&30Hello Big");
  /// worksheet_set_header(worksheet2, "&C&10Hello Small");
  ///
  /// @endcode
  ///
  /// You can specify the font of a section of the text by prefixing it with the
  /// control sequence `&"font,style"` where `fontname` is a font name such as
  /// Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic":
  /// "Courier New" or "Times New Roman" and `style` is one of the standard
  ///
  /// @code
  /// worksheet_set_header(worksheet1, "&C&\"Courier New,Italic\"Hello");
  /// worksheet_set_header(worksheet2, "&C&\"Courier New,Bold Italic\"Hello");
  /// worksheet_set_header(worksheet3, "&C&\"Times New Roman,Regular\"Hello");
  ///
  /// @endcode
  ///
  /// It is possible to combine all of these features together to create
  /// sophisticated headers and footers. As an aid to setting up complicated
  /// headers and footers you can record a page set-up as a macro in Excel and
  /// look at the format strings that VBA produces. Remember however that VBA
  /// uses two double quotes `""` to indicate a single double quote. For the last
  /// example above the equivalent VBA code looks like this:
  ///
  /// @code
  /// .LeftHeader = ""
  /// .CenterHeader = "&""Times New Roman,Regular""Hello"
  /// .RightHeader = ""
  ///
  /// @endcode
  ///
  /// Alternatively you can inspect the header and footer strings in an Excel
  /// file by unzipping it and grepping the XML sub-files. The following shows
  /// how to do that using libxml's xmllint to format the XML for clarity:
  ///
  /// @code
  ///
  /// $ unzip myfile.xlsm -d myfile
  /// $ xmllint --format `find myfile -name "*.xml" | xargs` | egrep "Header|Footer" | sed 's/&amp;/\&/g'
  ///
  /// <headerFooter scaleWithDoc="0">
  /// <oddHeader>&L&P</oddHeader>
  /// </headerFooter>
  ///
  /// @endcode
  ///
  /// To include a single literal ampersand `&` in a header or footer you should
  /// use a double ampersand `&&`:
  ///
  /// @code
  /// worksheet_set_header(worksheet, "&CCuriouser && Curiouser - Attorneys at Law");
  /// @endcode
  ///
  /// @note
  /// Excel requires that the header or footer string cannot be longer than 255
  /// characters, including the control characters. Strings longer than this will
  /// not be written.
  int worksheet_set_header(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _worksheet_set_header(
      worksheet,
      string,
    );
  }

  late final _worksheet_set_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.Char>)>>('worksheet_set_header');
  late final _worksheet_set_header = _worksheet_set_headerPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the printed page footer caption.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param string    The footer string.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as worksheet_set_header().
  int worksheet_set_footer(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _worksheet_set_footer(
      worksheet,
      string,
    );
  }

  late final _worksheet_set_footerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.Char>)>>('worksheet_set_footer');
  late final _worksheet_set_footer = _worksheet_set_footerPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the printed page header caption with additional options.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param string    The header string.
  /// @param options   Header options.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as `worksheet_set_header()` with an
  /// additional parameter to specify options for the header.
  ///
  /// The #lxw_header_footer_options options are:
  ///
  /// - `margin`: Header or footer margin in inches. The value must by larger
  /// than 0.0. The Excel default is 0.3.
  ///
  /// - `image_left`: The left header image filename, with path if required. This
  /// should have a corresponding `&G/&[Picture]` placeholder in the `&L`
  /// section of the header/footer string.
  ///
  /// - `image_center`: The center header image filename, with path if
  /// required. This should have a corresponding `&G/&[Picture]` placeholder in
  /// the `&C` section of the header/footer string.
  ///
  /// - `image_right`: The right header image filename, with path if
  /// required. This should have a corresponding `&G/&[Picture]` placeholder in
  /// the `&R` section of the header/footer string.
  ///
  /// @code
  /// lxw_header_footer_options header_options = { .margin = 0.2 };
  ///
  /// worksheet_set_header_opt(worksheet, "Some text", &header_options);
  /// @endcode
  ///
  /// Images can be inserted in the header by specifying the `&[Picture]`
  /// placeholder and a filename/path to the image:
  ///
  /// @code
  /// lxw_header_footer_options header_options = {.image_left = "logo.png"};
  ///
  /// worksheet_set_header_opt(worksheet, "&L&[Picture]", &header_options);
  /// @endcode
  ///
  /// @image html headers_footers.png
  int worksheet_set_header_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_header_footer_options> options,
  ) {
    return _worksheet_set_header_opt(
      worksheet,
      string,
      options,
    );
  }

  late final _worksheet_set_header_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_header_footer_options>)>>(
      'worksheet_set_header_opt');
  late final _worksheet_set_header_opt =
      _worksheet_set_header_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_header_footer_options>)>();

  /// @brief Set the printed page footer caption with additional options.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param string    The footer string.
  /// @param options   Footer options.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as `worksheet_set_header_opt()`.
  int worksheet_set_footer_opt(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_header_footer_options> options,
  ) {
    return _worksheet_set_footer_opt(
      worksheet,
      string,
      options,
    );
  }

  late final _worksheet_set_footer_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_worksheet>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_header_footer_options>)>>(
      'worksheet_set_footer_opt');
  late final _worksheet_set_footer_opt =
      _worksheet_set_footer_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_header_footer_options>)>();

  /// @brief Set the horizontal page breaks on a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param breaks    Array of page breaks.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_h_pagebreaks()` function adds horizontal page breaks to
  /// a worksheet. A page break causes all the data that follows it to be printed
  /// on the next page. Horizontal page breaks act between rows.
  ///
  /// The function takes an array of one or more page breaks. The type of the
  /// array data is @ref lxw_row_t and the last element of the array must be 0:
  ///
  /// @code
  /// lxw_row_t breaks1[] = {20, 0}; // 1 page break. Zero indicates the end.
  /// lxw_row_t breaks2[] = {20, 40, 60, 80, 0};
  ///
  /// worksheet_set_h_pagebreaks(worksheet1, breaks1);
  /// worksheet_set_h_pagebreaks(worksheet2, breaks2);
  /// @endcode
  ///
  /// To create a page break between rows 20 and 21 you must specify the break at
  /// row 21. However in zero index notation this is actually row 20:
  ///
  /// @code
  /// // Break between row 20 and 21.
  /// lxw_row_t breaks[] = {20, 0};
  ///
  /// worksheet_set_h_pagebreaks(worksheet, breaks);
  /// @endcode
  ///
  /// There is an Excel limitation of 1023 horizontal page breaks per worksheet.
  ///
  /// Note: If you specify the "fit to page" option via the
  /// `worksheet_fit_to_pages()` function it will override all manual page
  /// breaks.
  int worksheet_set_h_pagebreaks(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<lxw_row_t> breaks,
  ) {
    return _worksheet_set_h_pagebreaks(
      worksheet,
      breaks,
    );
  }

  late final _worksheet_set_h_pagebreaksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<lxw_row_t>)>>('worksheet_set_h_pagebreaks');
  late final _worksheet_set_h_pagebreaks =
      _worksheet_set_h_pagebreaksPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<lxw_row_t>)>();

  /// @brief Set the vertical page breaks on a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param breaks    Array of page breaks.
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%worksheet_set_v_pagebreaks()` function adds vertical page breaks to a
  /// worksheet. A page break causes all the data that follows it to be printed
  /// on the next page. Vertical page breaks act between columns.
  ///
  /// The function takes an array of one or more page breaks. The type of the
  /// array data is @ref lxw_col_t and the last element of the array must be 0:
  ///
  /// @code
  /// lxw_col_t breaks1[] = {20, 0}; // 1 page break. Zero indicates the end.
  /// lxw_col_t breaks2[] = {20, 40, 60, 80, 0};
  ///
  /// worksheet_set_v_pagebreaks(worksheet1, breaks1);
  /// worksheet_set_v_pagebreaks(worksheet2, breaks2);
  /// @endcode
  ///
  /// To create a page break between columns 20 and 21 you must specify the break
  /// at column 21. However in zero index notation this is actually column 20:
  ///
  /// @code
  /// // Break between column 20 and 21.
  /// lxw_col_t breaks[] = {20, 0};
  ///
  /// worksheet_set_v_pagebreaks(worksheet, breaks);
  /// @endcode
  ///
  /// There is an Excel limitation of 1023 vertical page breaks per worksheet.
  ///
  /// Note: If you specify the "fit to page" option via the
  /// `worksheet_fit_to_pages()` function it will override all manual page
  /// breaks.
  int worksheet_set_v_pagebreaks(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<lxw_col_t> breaks,
  ) {
    return _worksheet_set_v_pagebreaks(
      worksheet,
      breaks,
    );
  }

  late final _worksheet_set_v_pagebreaksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<lxw_col_t>)>>('worksheet_set_v_pagebreaks');
  late final _worksheet_set_v_pagebreaks =
      _worksheet_set_v_pagebreaksPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<lxw_col_t>)>();

  /// @brief Set the order in which pages are printed.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_print_across()` function is used to change the default
  /// print direction. This is referred to by Excel as the sheet "page order":
  ///
  /// @code
  /// worksheet_print_across(worksheet);
  /// @endcode
  ///
  /// The default page order is shown below for a worksheet that extends over 4
  /// pages. The order is called "down then across":
  ///
  /// [1] [3]
  /// [2] [4]
  ///
  /// However, by using the `print_across` function the print order will be
  /// changed to "across then down":
  ///
  /// [1] [2]
  /// [3] [4]
  void worksheet_print_across(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_print_across(
      worksheet,
    );
  }

  late final _worksheet_print_acrossPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_print_across');
  late final _worksheet_print_across = _worksheet_print_acrossPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the worksheet zoom factor.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param scale     Worksheet zoom factor.
  ///
  /// Set the worksheet zoom factor in the range `10 <= zoom <= 400`:
  ///
  /// @code
  /// worksheet_set_zoom(worksheet1, 50);
  /// worksheet_set_zoom(worksheet2, 75);
  /// worksheet_set_zoom(worksheet3, 300);
  /// worksheet_set_zoom(worksheet4, 400);
  /// @endcode
  ///
  /// The default zoom factor is 100. It isn't possible to set the zoom to
  /// "Selection" because it is calculated by Excel at run-time.
  ///
  /// Note, `%worksheet_zoom()` does not affect the scale of the printed
  /// page. For that you should use `worksheet_set_print_scale()`.
  void worksheet_set_zoom(
    ffi.Pointer<lxw_worksheet> worksheet,
    int scale,
  ) {
    return _worksheet_set_zoom(
      worksheet,
      scale,
    );
  }

  late final _worksheet_set_zoomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_worksheet>, ffi.Uint16)>>('worksheet_set_zoom');
  late final _worksheet_set_zoom = _worksheet_set_zoomPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Set the option to display or hide gridlines on the screen and
  /// the printed page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param option    Gridline option.
  ///
  /// Display or hide screen and print gridlines using one of the values of
  /// @ref lxw_gridlines.
  ///
  /// @code
  /// worksheet_gridlines(worksheet1, LXW_HIDE_ALL_GRIDLINES);
  ///
  /// worksheet_gridlines(worksheet2, LXW_SHOW_PRINT_GRIDLINES);
  /// @endcode
  ///
  /// The Excel default is that the screen gridlines are on  and the printed
  /// worksheet is off.
  void worksheet_gridlines(
    ffi.Pointer<lxw_worksheet> worksheet,
    int option,
  ) {
    return _worksheet_gridlines(
      worksheet,
      option,
    );
  }

  late final _worksheet_gridlinesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_worksheet>, ffi.Uint8)>>('worksheet_gridlines');
  late final _worksheet_gridlines = _worksheet_gridlinesPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Center the printed page horizontally.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// Center the worksheet data horizontally between the margins on the printed
  /// page:
  ///
  /// @code
  /// worksheet_center_horizontally(worksheet);
  /// @endcode
  void worksheet_center_horizontally(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_center_horizontally(
      worksheet,
    );
  }

  late final _worksheet_center_horizontallyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_center_horizontally');
  late final _worksheet_center_horizontally = _worksheet_center_horizontallyPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Center the printed page vertically.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// Center the worksheet data vertically between the margins on the printed
  /// page:
  ///
  /// @code
  /// worksheet_center_vertically(worksheet);
  /// @endcode
  void worksheet_center_vertically(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_center_vertically(
      worksheet,
    );
  }

  late final _worksheet_center_verticallyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_center_vertically');
  late final _worksheet_center_vertically = _worksheet_center_verticallyPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the option to print the row and column headers on the printed
  /// page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// When printing a worksheet from Excel the row and column headers (the row
  /// numbers on the left and the column letters at the top) aren't printed by
  /// default.
  ///
  /// This function sets the printer option to print these headers:
  ///
  /// @code
  /// worksheet_print_row_col_headers(worksheet);
  /// @endcode
  void worksheet_print_row_col_headers(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_print_row_col_headers(
      worksheet,
    );
  }

  late final _worksheet_print_row_col_headersPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_print_row_col_headers');
  late final _worksheet_print_row_col_headers =
      _worksheet_print_row_col_headersPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the number of rows to repeat at the top of each printed page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row First row of repeat range.
  /// @param last_row  Last row of repeat range.
  ///
  /// @return A #lxw_error code.
  ///
  /// For large Excel documents it is often desirable to have the first row or
  /// rows of the worksheet print out at the top of each page.
  ///
  /// This can be achieved by using this function. The parameters `first_row`
  /// and `last_row` are zero based:
  ///
  /// @code
  /// worksheet_repeat_rows(worksheet, 0, 0); // Repeat the first row.
  /// worksheet_repeat_rows(worksheet, 0, 1); // Repeat the first two rows.
  /// @endcode
  int worksheet_repeat_rows(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int last_row,
  ) {
    return _worksheet_repeat_rows(
      worksheet,
      first_row,
      last_row,
    );
  }

  late final _worksheet_repeat_rowsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t,
              lxw_row_t)>>('worksheet_repeat_rows');
  late final _worksheet_repeat_rows = _worksheet_repeat_rowsPtr
      .asFunction<int Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  /// @brief Set the number of columns to repeat at the top of each printed page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_col First column of repeat range.
  /// @param last_col  Last column of repeat range.
  ///
  /// @return A #lxw_error code.
  ///
  /// For large Excel documents it is often desirable to have the first column or
  /// columns of the worksheet print out at the left of each page.
  ///
  /// This can be achieved by using this function. The parameters `first_col`
  /// and `last_col` are zero based:
  ///
  /// @code
  /// worksheet_repeat_columns(worksheet, 0, 0); // Repeat the first col.
  /// worksheet_repeat_columns(worksheet, 0, 1); // Repeat the first two cols.
  /// @endcode
  int worksheet_repeat_columns(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_col,
    int last_col,
  ) {
    return _worksheet_repeat_columns(
      worksheet,
      first_col,
      last_col,
    );
  }

  late final _worksheet_repeat_columnsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_col_t,
              lxw_col_t)>>('worksheet_repeat_columns');
  late final _worksheet_repeat_columns = _worksheet_repeat_columnsPtr
      .asFunction<int Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  /// @brief Set the print area for a worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param first_row The first row of the range. (All zero indexed.)
  /// @param first_col The first column of the range.
  /// @param last_row  The last row of the range.
  /// @param last_col  The last col of the range.
  ///
  /// @return A #lxw_error code.
  ///
  /// This function is used to specify the area of the worksheet that will be
  /// printed. The RANGE() macro is often convenient for this.
  ///
  /// @code
  /// worksheet_print_area(worksheet, 0, 0, 41, 10); // A1:K42.
  ///
  /// // Same as:
  /// worksheet_print_area(worksheet, RANGE("A1:K42"));
  /// @endcode
  ///
  /// In order to set a row or column range you must specify the entire range:
  ///
  /// @code
  /// worksheet_print_area(worksheet, RANGE("A1:H1048576")); // Same as A:H.
  /// @endcode
  int worksheet_print_area(
    ffi.Pointer<lxw_worksheet> worksheet,
    int first_row,
    int first_col,
    int last_row,
    int last_col,
  ) {
    return _worksheet_print_area(
      worksheet,
      first_row,
      first_col,
      last_row,
      last_col,
    );
  }

  late final _worksheet_print_areaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, lxw_row_t, lxw_col_t,
              lxw_row_t, lxw_col_t)>>('worksheet_print_area');
  late final _worksheet_print_area = _worksheet_print_areaPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int)>();

  /// @brief Fit the printed area to a specific number of pages both vertically
  /// and horizontally.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param width     Number of pages horizontally.
  /// @param height    Number of pages vertically.
  ///
  /// The `%worksheet_fit_to_pages()` function is used to fit the printed area to
  /// a specific number of pages both vertically and horizontally. If the printed
  /// area exceeds the specified number of pages it will be scaled down to
  /// fit. This ensures that the printed area will always appear on the specified
  /// number of pages even if the page size or margins change:
  ///
  /// @code
  /// worksheet_fit_to_pages(worksheet1, 1, 1); // Fit to 1x1 pages.
  /// worksheet_fit_to_pages(worksheet2, 2, 1); // Fit to 2x1 pages.
  /// worksheet_fit_to_pages(worksheet3, 1, 2); // Fit to 1x2 pages.
  /// @endcode
  ///
  /// The print area can be defined using the `worksheet_print_area()` function
  /// as described above.
  ///
  /// A common requirement is to fit the printed output to `n` pages wide but
  /// have the height be as long as necessary. To achieve this set the `height`
  /// to zero:
  ///
  /// @code
  /// // 1 page wide and as long as necessary.
  /// worksheet_fit_to_pages(worksheet, 1, 0);
  /// @endcode
  ///
  /// **Note**:
  ///
  /// - Although it is valid to use both `%worksheet_fit_to_pages()` and
  /// `worksheet_set_print_scale()` on the same worksheet Excel only allows one
  /// of these options to be active at a time. The last function call made will
  /// set the active option.
  ///
  /// - The `%worksheet_fit_to_pages()` function will override any manual page
  /// breaks that are defined in the worksheet.
  ///
  /// - When using `%worksheet_fit_to_pages()` it may also be required to set the
  /// printer paper size using `worksheet_set_paper()` or else Excel will
  /// default to "US Letter".
  void worksheet_fit_to_pages(
    ffi.Pointer<lxw_worksheet> worksheet,
    int width,
    int height,
  ) {
    return _worksheet_fit_to_pages(
      worksheet,
      width,
      height,
    );
  }

  late final _worksheet_fit_to_pagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint16,
              ffi.Uint16)>>('worksheet_fit_to_pages');
  late final _worksheet_fit_to_pages = _worksheet_fit_to_pagesPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  /// @brief Set the start/first page number when printing.
  ///
  /// @param worksheet  Pointer to a lxw_worksheet instance to be updated.
  /// @param start_page Page number of the starting page when printing.
  ///
  /// The `%worksheet_set_start_page()` function is used to set the number number
  /// of the first page when the worksheet is printed out. It is the same as the
  /// "First Page Number" option in Excel:
  ///
  /// @code
  /// // Start print from page 2.
  /// worksheet_set_start_page(worksheet, 2);
  /// @endcode
  void worksheet_set_start_page(
    ffi.Pointer<lxw_worksheet> worksheet,
    int start_page,
  ) {
    return _worksheet_set_start_page(
      worksheet,
      start_page,
    );
  }

  late final _worksheet_set_start_pagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>,
              ffi.Uint16)>>('worksheet_set_start_page');
  late final _worksheet_set_start_page = _worksheet_set_start_pagePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Set the scale factor for the printed page.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param scale     Print scale of worksheet to be printed.
  ///
  /// This function sets the scale factor of the printed page. The Scale factor
  /// must be in the range `10 <= scale <= 400`:
  ///
  /// @code
  /// worksheet_set_print_scale(worksheet1, 75);
  /// worksheet_set_print_scale(worksheet2, 400);
  /// @endcode
  ///
  /// The default scale factor is 100. Note, `%worksheet_set_print_scale()` does
  /// not affect the scale of the visible page in Excel. For that you should use
  /// `worksheet_set_zoom()`.
  ///
  /// Note that although it is valid to use both `worksheet_fit_to_pages()` and
  /// `%worksheet_set_print_scale()` on the same worksheet Excel only allows one
  /// of these options to be active at a time. The last function call made will
  /// set the active option.
  void worksheet_set_print_scale(
    ffi.Pointer<lxw_worksheet> worksheet,
    int scale,
  ) {
    return _worksheet_set_print_scale(
      worksheet,
      scale,
    );
  }

  late final _worksheet_set_print_scalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>,
              ffi.Uint16)>>('worksheet_set_print_scale');
  late final _worksheet_set_print_scale = _worksheet_set_print_scalePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Set the worksheet to print in black and white
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// Set the option to print the worksheet in black and white:
  /// @code
  /// worksheet_print_black_and_white(worksheet);
  /// @endcode
  void worksheet_print_black_and_white(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_print_black_and_white(
      worksheet,
    );
  }

  late final _worksheet_print_black_and_whitePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_print_black_and_white');
  late final _worksheet_print_black_and_white =
      _worksheet_print_black_and_whitePtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Display the worksheet cells from right to left for some versions of
  /// Excel.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_right_to_left()` function is used to change the default
  /// direction of the worksheet from left-to-right, with the `A1` cell in the
  /// top left, to right-to-left, with the `A1` cell in the top right.
  ///
  /// @code
  /// worksheet_right_to_left(worksheet1);
  /// @endcode
  ///
  /// This is useful when creating Arabic, Hebrew or other near or far eastern
  /// worksheets that use right-to-left as the default direction.
  void worksheet_right_to_left(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_right_to_left(
      worksheet,
    );
  }

  late final _worksheet_right_to_leftPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_right_to_left');
  late final _worksheet_right_to_left = _worksheet_right_to_leftPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Hide zero values in worksheet cells.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  ///
  /// The `%worksheet_hide_zero()` function is used to hide any zero values that
  /// appear in cells:
  ///
  /// @code
  /// worksheet_hide_zero(worksheet1);
  /// @endcode
  void worksheet_hide_zero(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_hide_zero(
      worksheet,
    );
  }

  late final _worksheet_hide_zeroPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_hide_zero');
  late final _worksheet_hide_zero = _worksheet_hide_zeroPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the color of the worksheet tab.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param color     The tab color.
  ///
  /// The `%worksheet_set_tab_color()` function is used to change the color of
  /// the worksheet tab:
  ///
  /// @code
  /// worksheet_set_tab_color(worksheet1, LXW_COLOR_RED);
  /// worksheet_set_tab_color(worksheet2, LXW_COLOR_GREEN);
  /// worksheet_set_tab_color(worksheet3, 0xFF9900); // Orange.
  /// @endcode
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  void worksheet_set_tab_color(
    ffi.Pointer<lxw_worksheet> worksheet,
    int color,
  ) {
    return _worksheet_set_tab_color(
      worksheet,
      color,
    );
  }

  late final _worksheet_set_tab_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>,
              lxw_color_t)>>('worksheet_set_tab_color');
  late final _worksheet_set_tab_color = _worksheet_set_tab_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  /// @brief Protect elements of a worksheet from modification.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance to be updated.
  /// @param password  A worksheet password.
  /// @param options   Worksheet elements to protect.
  ///
  /// The `%worksheet_protect()` function protects worksheet elements from modification:
  ///
  /// @code
  /// worksheet_protect(worksheet, "Some Password", options);
  /// @endcode
  ///
  /// The `password` and lxw_protection pointer are both optional:
  ///
  /// @code
  /// worksheet_protect(worksheet1, NULL,       NULL);
  /// worksheet_protect(worksheet2, NULL,       my_options);
  /// worksheet_protect(worksheet3, "password", NULL);
  /// worksheet_protect(worksheet4, "password", my_options);
  /// @endcode
  ///
  /// Passing a `NULL` password is the same as turning on protection without a
  /// password. Passing a `NULL` password and `NULL` options, or any other
  /// combination has the effect of enabling a cell's `locked` and `hidden`
  /// properties if they have been set.
  ///
  /// A *locked* cell cannot be edited and this property is on by default for all
  /// cells. A *hidden* cell will display the results of a formula but not the
  /// formula itself. These properties can be set using the format_set_unlocked()
  /// and format_set_hidden() format functions.
  ///
  /// You can specify which worksheet elements you wish to protect by passing a
  /// lxw_protection pointer in the `options` argument with any or all of the
  /// following members set:
  ///
  /// no_select_locked_cells
  /// no_select_unlocked_cells
  /// format_cells
  /// format_columns
  /// format_rows
  /// insert_columns
  /// insert_rows
  /// insert_hyperlinks
  /// delete_columns
  /// delete_rows
  /// sort
  /// autofilter
  /// pivot_tables
  /// scenarios
  /// objects
  ///
  /// All parameters are off by default. Individual elements can be protected as
  /// follows:
  ///
  /// @code
  /// lxw_protection options = {
  /// .format_cells             = 1,
  /// .insert_hyperlinks        = 1,
  /// .insert_rows              = 1,
  /// .delete_rows              = 1,
  /// .insert_columns           = 1,
  /// .delete_columns           = 1,
  /// };
  ///
  /// worksheet_protect(worksheet, NULL, &options);
  ///
  /// @endcode
  ///
  /// See also the format_set_unlocked() and format_set_hidden() format functions.
  ///
  /// **Note:** Sheet level passwords in Excel offer **very** weak
  /// protection. They don't encrypt your data and are very easy to
  /// deactivate. Full workbook encryption is not supported by `libxlsxwriter`
  /// since it requires a completely different file format.
  void worksheet_protect(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<lxw_protection> options,
  ) {
    return _worksheet_protect(
      worksheet,
      password,
      options,
    );
  }

  late final _worksheet_protectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_protection>)>>('worksheet_protect');
  late final _worksheet_protect = _worksheet_protectPtr.asFunction<
      void Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_protection>)>();

  /// @brief Set the Outline and Grouping display properties.
  ///
  /// @param worksheet      Pointer to a lxw_worksheet instance to be updated.
  /// @param visible        Outlines are visible. Optional, defaults to True.
  /// @param symbols_below  Show row outline symbols below the outline bar.
  /// @param symbols_right  Show column outline symbols to the right of outline.
  /// @param auto_style     Use Automatic outline style.
  ///
  /// The `%worksheet_outline_settings()` method is used to control the
  /// appearance of outlines in Excel. Outlines are described the section on
  /// @ref working_with_outlines.
  ///
  /// The `visible` parameter is used to control whether or not outlines are
  /// visible. Setting this parameter to False will cause all outlines on the
  /// worksheet to be hidden. They can be un-hidden in Excel by means of the
  /// "Show Outline Symbols" command button. The default Excel setting is True
  /// for visible outlines.
  ///
  /// The `symbols_below` parameter is used to control whether the row outline
  /// symbol will appear above or below the outline level bar. The default Excel
  /// setting is True for symbols to appear below the outline level bar.
  ///
  /// The `symbols_right` parameter is used to control whether the column outline
  /// symbol will appear to the left or the right of the outline level bar. The
  /// default Excel setting is True for symbols to appear to the right of the
  /// outline level bar.
  ///
  /// The `auto_style` parameter is used to control whether the automatic outline
  /// generator in Excel uses automatic styles when creating an outline. This has
  /// no effect on a file generated by XlsxWriter but it does have an effect on
  /// how the worksheet behaves after it is created. The default Excel setting is
  /// False for "Automatic Styles" to be turned off.
  ///
  /// The default settings for all of these parameters in libxlsxwriter
  /// correspond to Excel's default parameters and are shown below:
  ///
  /// @code
  /// worksheet_outline_settings(worksheet1, LXW_TRUE, LXW_TRUE, LXW_TRUE, LXW_FALSE);
  /// @endcode
  ///
  /// The worksheet parameters controlled by `worksheet_outline_settings()` are
  /// rarely used.
  void worksheet_outline_settings(
    ffi.Pointer<lxw_worksheet> worksheet,
    int visible,
    int symbols_below,
    int symbols_right,
    int auto_style,
  ) {
    return _worksheet_outline_settings(
      worksheet,
      visible,
      symbols_below,
      symbols_right,
      auto_style,
    );
  }

  late final _worksheet_outline_settingsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint8, ffi.Uint8,
              ffi.Uint8, ffi.Uint8)>>('worksheet_outline_settings');
  late final _worksheet_outline_settings =
      _worksheet_outline_settingsPtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int, int, int, int)>();

  /// @brief Set the default row properties.
  ///
  /// @param worksheet        Pointer to a lxw_worksheet instance to be updated.
  /// @param height           Default row height.
  /// @param hide_unused_rows Hide unused cells.
  ///
  /// The `%worksheet_set_default_row()` function is used to set Excel default
  /// row properties such as the default height and the option to hide unused
  /// rows. These parameters are an optimization used by Excel to set row
  /// properties without generating a very large file with an entry for each row.
  ///
  /// To set the default row height:
  ///
  /// @code
  /// worksheet_set_default_row(worksheet, 24, LXW_FALSE);
  ///
  /// @endcode
  ///
  /// To hide unused rows:
  ///
  /// @code
  /// worksheet_set_default_row(worksheet, 15, LXW_TRUE);
  /// @endcode
  ///
  /// Note, in the previous case we use the default height #LXW_DEF_ROW_HEIGHT =
  /// 15 so the the height remains unchanged.
  void worksheet_set_default_row(
    ffi.Pointer<lxw_worksheet> worksheet,
    double height,
    int hide_unused_rows,
  ) {
    return _worksheet_set_default_row(
      worksheet,
      height,
      hide_unused_rows,
    );
  }

  late final _worksheet_set_default_rowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Double,
              ffi.Uint8)>>('worksheet_set_default_row');
  late final _worksheet_set_default_row = _worksheet_set_default_rowPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, double, int)>();

  /// @brief Set the VBA name for the worksheet.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance.
  /// @param name      Name of the worksheet used by VBA.
  ///
  /// @return A #lxw_error.
  ///
  /// The `worksheet_set_vba_name()` function can be used to set the VBA name for
  /// the worksheet. This is sometimes required when a vbaProject macro included
  /// via `workbook_add_vba_project()` refers to the worksheet by a name other
  /// than the worksheet name:
  ///
  /// @code
  /// workbook_set_vba_name (workbook,  "MyWorkbook");
  /// worksheet_set_vba_name(worksheet, "MySheet1");
  /// @endcode
  ///
  /// In general Excel uses the worksheet name such as "Sheet1" as the VBA name.
  /// However, this can be changed in the VBA environment or if the the macro was
  /// extracted from a foreign language version of Excel.
  ///
  /// See also @ref working_with_macros
  int worksheet_set_vba_name(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _worksheet_set_vba_name(
      worksheet,
      name,
    );
  }

  late final _worksheet_set_vba_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.Char>)>>('worksheet_set_vba_name');
  late final _worksheet_set_vba_name = _worksheet_set_vba_namePtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Make all comments in the worksheet visible.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance.
  ///
  /// This `%worksheet_show_comments()` function is used to make all cell
  /// comments visible when a worksheet is opened:
  ///
  /// @code
  /// worksheet_show_comments(worksheet);
  /// @endcode
  ///
  /// Individual comments can be made visible or hidden using the `visible`
  /// option of the #lxw_comment_options struct and the `worksheet_write_comment_opt()`
  /// function (see above and @ref ww_comments_visible).
  void worksheet_show_comments(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _worksheet_show_comments(
      worksheet,
    );
  }

  late final _worksheet_show_commentsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'worksheet_show_comments');
  late final _worksheet_show_comments = _worksheet_show_commentsPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Set the default author of the cell comments.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance.
  /// @param author    The name of the comment author.
  ///
  /// This `%worksheet_set_comments_author()` function is used to set the
  /// default author of all cell comments:
  ///
  /// @code
  /// worksheet_set_comments_author(worksheet, "Jane Gloriana Villanueva")
  /// @endcode
  ///
  /// Individual authors can be set using the `author` option of the
  /// #lxw_comment_options struct and the `worksheet_write_comment_opt()`
  /// function (see above and @ref ww_comments_author).
  void worksheet_set_comments_author(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<ffi.Char> author,
  ) {
    return _worksheet_set_comments_author(
      worksheet,
      author,
    );
  }

  late final _worksheet_set_comments_authorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>,
              ffi.Pointer<ffi.Char>)>>('worksheet_set_comments_author');
  late final _worksheet_set_comments_author =
      _worksheet_set_comments_authorPtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Ignore various Excel errors/warnings in a worksheet for user
  /// defined ranges.
  ///
  /// @param worksheet Pointer to a lxw_worksheet instance.
  /// @param type      The type of error/warning to ignore. See #lxw_ignore_errors.
  /// @param range     The range(s) for which the error/warning should be ignored.
  ///
  /// @return A #lxw_error.
  ///
  ///
  /// The `%worksheet_ignore_errors()` function can be used to ignore various
  /// worksheet cell errors/warnings. For example the following code writes a string
  /// that looks like a number:
  ///
  /// @code
  /// worksheet_write_string(worksheet, CELL("D2"), "123", NULL);
  /// @endcode
  ///
  /// This causes Excel to display a small green triangle in the top left hand
  /// corner of the cell to indicate an error/warning:
  ///
  /// @image html ignore_errors1.png
  ///
  /// Sometimes these warnings are useful indicators that there is an issue in
  /// the spreadsheet but sometimes it is preferable to turn them off. Warnings
  /// can be turned off at the Excel level for all workbooks and worksheets by
  /// using the using "Excel options -> Formulas -> Error checking
  /// rules". Alternatively you can turn them off for individual cells in a
  /// worksheet, or ranges of cells, using the `%worksheet_ignore_errors()`
  /// function with different #lxw_ignore_errors options and ranges like this:
  ///
  /// @code
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C3");
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_EVAL_ERROR,            "C6");
  /// @endcode
  ///
  /// The range can be a single cell, a range of cells, or multiple cells and ranges
  /// separated by spaces:
  ///
  /// @code
  /// // Single cell.
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6");
  ///
  /// // Or a single range:
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6:G8");
  ///
  /// // Or multiple cells and ranges:
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6 E6 G1:G20 J2:J6");
  /// @endcode
  ///
  /// @note Calling `%worksheet_ignore_errors()` more than once for the same
  /// #lxw_ignore_errors type will overwrite the previous range.
  ///
  /// You can turn off warnings for an entire column by specifying the range from
  /// the first cell in the column to the last cell in the column:
  ///
  /// @code
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "A1:A1048576");
  /// @endcode
  ///
  /// Or for the entire worksheet by specifying the range from the first cell in
  /// the worksheet to the last cell in the worksheet:
  ///
  /// @code
  /// worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "A1:XFD1048576");
  /// @endcode
  ///
  /// The worksheet errors/warnings that can be ignored are:
  ///
  /// - #LXW_IGNORE_NUMBER_STORED_AS_TEXT: Turn off errors/warnings for numbers
  /// stores as text.
  ///
  /// - #LXW_IGNORE_EVAL_ERROR: Turn off errors/warnings for formula errors (such
  /// as divide by zero).
  ///
  /// - #LXW_IGNORE_FORMULA_DIFFERS: Turn off errors/warnings for formulas that
  /// differ from surrounding formulas.
  ///
  /// - #LXW_IGNORE_FORMULA_RANGE: Turn off errors/warnings for formulas that
  /// omit cells in a range.
  ///
  /// - #LXW_IGNORE_FORMULA_UNLOCKED: Turn off errors/warnings for unlocked cells
  /// that contain formulas.
  ///
  /// - #LXW_IGNORE_EMPTY_CELL_REFERENCE: Turn off errors/warnings for formulas
  /// that refer to empty cells.
  ///
  /// - #LXW_IGNORE_LIST_DATA_VALIDATION: Turn off errors/warnings for cells in a
  /// table that do not comply with applicable data validation rules.
  ///
  /// - #LXW_IGNORE_CALCULATED_COLUMN: Turn off errors/warnings for cell formulas
  /// that differ from the column formula.
  ///
  /// - #LXW_IGNORE_TWO_DIGIT_TEXT_YEAR: Turn off errors/warnings for formulas
  /// that contain a two digit text representation of a year.
  int worksheet_ignore_errors(
    ffi.Pointer<lxw_worksheet> worksheet,
    int type,
    ffi.Pointer<ffi.Char> range,
  ) {
    return _worksheet_ignore_errors(
      worksheet,
      type,
      range,
    );
  }

  late final _worksheet_ignore_errorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_worksheet>, ffi.Uint8,
              ffi.Pointer<ffi.Char>)>>('worksheet_ignore_errors');
  late final _worksheet_ignore_errors = _worksheet_ignore_errorsPtr.asFunction<
      int Function(ffi.Pointer<lxw_worksheet>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<lxw_worksheet> lxw_worksheet_new(
    ffi.Pointer<lxw_worksheet_init_data> init_data,
  ) {
    return _lxw_worksheet_new(
      init_data,
    );
  }

  late final _lxw_worksheet_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_worksheet> Function(
              ffi.Pointer<lxw_worksheet_init_data>)>>('lxw_worksheet_new');
  late final _lxw_worksheet_new = _lxw_worksheet_newPtr.asFunction<
      ffi.Pointer<lxw_worksheet> Function(
          ffi.Pointer<lxw_worksheet_init_data>)>();

  void lxw_worksheet_free(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_free(
      worksheet,
    );
  }

  late final _lxw_worksheet_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_free');
  late final _lxw_worksheet_free = _lxw_worksheet_freePtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_assemble_xml_file(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_assemble_xml_file(
      worksheet,
    );
  }

  late final _lxw_worksheet_assemble_xml_filePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_assemble_xml_file');
  late final _lxw_worksheet_assemble_xml_file =
      _lxw_worksheet_assemble_xml_filePtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_single_row(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_single_row(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_single_rowPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_single_row');
  late final _lxw_worksheet_write_single_row =
      _lxw_worksheet_write_single_rowPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_prepare_image(
    ffi.Pointer<lxw_worksheet> worksheet,
    int image_ref_id,
    int drawing_id,
    ffi.Pointer<lxw_object_properties> object_props,
  ) {
    return _lxw_worksheet_prepare_image(
      worksheet,
      image_ref_id,
      drawing_id,
      object_props,
    );
  }

  late final _lxw_worksheet_prepare_imagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint32,
                  ffi.Uint32, ffi.Pointer<lxw_object_properties>)>>(
      'lxw_worksheet_prepare_image');
  late final _lxw_worksheet_prepare_image =
      _lxw_worksheet_prepare_imagePtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_object_properties>)>();

  void lxw_worksheet_prepare_header_image(
    ffi.Pointer<lxw_worksheet> worksheet,
    int image_ref_id,
    ffi.Pointer<lxw_object_properties> object_props,
  ) {
    return _lxw_worksheet_prepare_header_image(
      worksheet,
      image_ref_id,
      object_props,
    );
  }

  late final _lxw_worksheet_prepare_header_imagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint32,
                  ffi.Pointer<lxw_object_properties>)>>(
      'lxw_worksheet_prepare_header_image');
  late final _lxw_worksheet_prepare_header_image =
      _lxw_worksheet_prepare_header_imagePtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int,
              ffi.Pointer<lxw_object_properties>)>();

  void lxw_worksheet_prepare_background(
    ffi.Pointer<lxw_worksheet> worksheet,
    int image_ref_id,
    ffi.Pointer<lxw_object_properties> object_props,
  ) {
    return _lxw_worksheet_prepare_background(
      worksheet,
      image_ref_id,
      object_props,
    );
  }

  late final _lxw_worksheet_prepare_backgroundPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint32,
                  ffi.Pointer<lxw_object_properties>)>>(
      'lxw_worksheet_prepare_background');
  late final _lxw_worksheet_prepare_background =
      _lxw_worksheet_prepare_backgroundPtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int,
              ffi.Pointer<lxw_object_properties>)>();

  void lxw_worksheet_prepare_chart(
    ffi.Pointer<lxw_worksheet> worksheet,
    int chart_ref_id,
    int drawing_id,
    ffi.Pointer<lxw_object_properties> object_props,
    int is_chartsheet,
  ) {
    return _lxw_worksheet_prepare_chart(
      worksheet,
      chart_ref_id,
      drawing_id,
      object_props,
      is_chartsheet,
    );
  }

  late final _lxw_worksheet_prepare_chartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_worksheet>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<lxw_object_properties>,
              ffi.Uint8)>>('lxw_worksheet_prepare_chart');
  late final _lxw_worksheet_prepare_chart =
      _lxw_worksheet_prepare_chartPtr.asFunction<
          void Function(ffi.Pointer<lxw_worksheet>, int, int,
              ffi.Pointer<lxw_object_properties>, int)>();

  int lxw_worksheet_prepare_vml_objects(
    ffi.Pointer<lxw_worksheet> worksheet,
    int vml_data_id,
    int vml_shape_id,
    int vml_drawing_id,
    int comment_id,
  ) {
    return _lxw_worksheet_prepare_vml_objects(
      worksheet,
      vml_data_id,
      vml_shape_id,
      vml_drawing_id,
      comment_id,
    );
  }

  late final _lxw_worksheet_prepare_vml_objectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<lxw_worksheet>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint32)>>('lxw_worksheet_prepare_vml_objects');
  late final _lxw_worksheet_prepare_vml_objects =
      _lxw_worksheet_prepare_vml_objectsPtr.asFunction<
          int Function(ffi.Pointer<lxw_worksheet>, int, int, int, int)>();

  void lxw_worksheet_prepare_header_vml_objects(
    ffi.Pointer<lxw_worksheet> worksheet,
    int vml_header_id,
    int vml_drawing_id,
  ) {
    return _lxw_worksheet_prepare_header_vml_objects(
      worksheet,
      vml_header_id,
      vml_drawing_id,
    );
  }

  late final _lxw_worksheet_prepare_header_vml_objectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>, ffi.Uint32,
              ffi.Uint32)>>('lxw_worksheet_prepare_header_vml_objects');
  late final _lxw_worksheet_prepare_header_vml_objects =
      _lxw_worksheet_prepare_header_vml_objectsPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int, int)>();

  void lxw_worksheet_prepare_tables(
    ffi.Pointer<lxw_worksheet> worksheet,
    int table_id,
  ) {
    return _lxw_worksheet_prepare_tables(
      worksheet,
      table_id,
    );
  }

  late final _lxw_worksheet_prepare_tablesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_worksheet>,
              ffi.Uint32)>>('lxw_worksheet_prepare_tables');
  late final _lxw_worksheet_prepare_tables = _lxw_worksheet_prepare_tablesPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>, int)>();

  ffi.Pointer<lxw_row> lxw_worksheet_find_row(
    ffi.Pointer<lxw_worksheet> worksheet,
    int row_num,
  ) {
    return _lxw_worksheet_find_row(
      worksheet,
      row_num,
    );
  }

  late final _lxw_worksheet_find_rowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_row> Function(ffi.Pointer<lxw_worksheet>,
              lxw_row_t)>>('lxw_worksheet_find_row');
  late final _lxw_worksheet_find_row = _lxw_worksheet_find_rowPtr.asFunction<
      ffi.Pointer<lxw_row> Function(ffi.Pointer<lxw_worksheet>, int)>();

  ffi.Pointer<lxw_cell> lxw_worksheet_find_cell_in_row(
    ffi.Pointer<lxw_row> row,
    int col_num,
  ) {
    return _lxw_worksheet_find_cell_in_row(
      row,
      col_num,
    );
  }

  late final _lxw_worksheet_find_cell_in_rowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_cell> Function(ffi.Pointer<lxw_row>,
              lxw_col_t)>>('lxw_worksheet_find_cell_in_row');
  late final _lxw_worksheet_find_cell_in_row =
      _lxw_worksheet_find_cell_in_rowPtr.asFunction<
          ffi.Pointer<lxw_cell> Function(ffi.Pointer<lxw_row>, int)>();

  /// External functions to call intern XML functions shared with chartsheet.
  void lxw_worksheet_write_sheet_views(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_sheet_views(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_sheet_viewsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_sheet_views');
  late final _lxw_worksheet_write_sheet_views =
      _lxw_worksheet_write_sheet_viewsPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_page_margins(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_page_margins(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_page_marginsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_page_margins');
  late final _lxw_worksheet_write_page_margins =
      _lxw_worksheet_write_page_marginsPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_drawings(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_drawings(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_drawingsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_drawings');
  late final _lxw_worksheet_write_drawings = _lxw_worksheet_write_drawingsPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_sheet_protection(
    ffi.Pointer<lxw_worksheet> worksheet,
    ffi.Pointer<lxw_protection_obj> protect,
  ) {
    return _lxw_worksheet_write_sheet_protection(
      worksheet,
      protect,
    );
  }

  late final _lxw_worksheet_write_sheet_protectionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<lxw_worksheet>,
                  ffi.Pointer<lxw_protection_obj>)>>(
      'lxw_worksheet_write_sheet_protection');
  late final _lxw_worksheet_write_sheet_protection =
      _lxw_worksheet_write_sheet_protectionPtr.asFunction<
          void Function(
              ffi.Pointer<lxw_worksheet>, ffi.Pointer<lxw_protection_obj>)>();

  void lxw_worksheet_write_sheet_pr(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_sheet_pr(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_sheet_prPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_sheet_pr');
  late final _lxw_worksheet_write_sheet_pr = _lxw_worksheet_write_sheet_prPtr
      .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_page_setup(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_page_setup(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_page_setupPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_page_setup');
  late final _lxw_worksheet_write_page_setup =
      _lxw_worksheet_write_page_setupPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  void lxw_worksheet_write_header_footer(
    ffi.Pointer<lxw_worksheet> worksheet,
  ) {
    return _lxw_worksheet_write_header_footer(
      worksheet,
    );
  }

  late final _lxw_worksheet_write_header_footerPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_worksheet>)>>(
      'lxw_worksheet_write_header_footer');
  late final _lxw_worksheet_write_header_footer =
      _lxw_worksheet_write_header_footerPtr
          .asFunction<void Function(ffi.Pointer<lxw_worksheet>)>();

  /// @brief Insert a chart object into a chartsheet.
  ///
  /// @param chartsheet   Pointer to a lxw_chartsheet instance to be updated.
  /// @param chart        A #lxw_chart object created via workbook_add_chart().
  ///
  /// @return A #lxw_error code.
  ///
  /// The `%chartsheet_set_chart()` function can be used to insert a chart into a
  /// chartsheet. The chart object must be created first using the
  /// `workbook_add_chart()` function and configured using the @ref chart.h
  /// functions.
  ///
  /// @code
  /// // Create the chartsheet.
  /// lxw_chartsheet *chartsheet = workbook_add_chartsheet(workbook, NULL);
  ///
  /// // Create a chart object.
  /// lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_LINE);
  ///
  /// // Add a data series to the chart.
  /// chart_add_series(chart, NULL, "=Sheet1!$A$1:$A$6");
  ///
  /// // Insert the chart into the chartsheet.
  /// chartsheet_set_chart(chartsheet, chart);
  /// @endcode
  ///
  /// @image html chartsheet2.png
  ///
  /// **Note:**
  ///
  /// A chart may only be inserted once into a chartsheet or a worksheet. If
  /// several similar charts are required then each one must be created
  /// separately.
  int chartsheet_set_chart(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<lxw_chart> chart,
  ) {
    return _chartsheet_set_chart(
      chartsheet,
      chart,
    );
  }

  late final _chartsheet_set_chartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_chartsheet>,
              ffi.Pointer<lxw_chart>)>>('chartsheet_set_chart');
  late final _chartsheet_set_chart = _chartsheet_set_chartPtr.asFunction<
      int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<lxw_chart>)>();

  /// Not currently required since scale options aren't useful in a chartsheet.
  int chartsheet_set_chart_opt(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<lxw_chart> chart,
    ffi.Pointer<lxw_chart_options> user_options,
  ) {
    return _chartsheet_set_chart_opt(
      chartsheet,
      chart,
      user_options,
    );
  }

  late final _chartsheet_set_chart_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<lxw_chartsheet>,
              ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_options>)>>('chartsheet_set_chart_opt');
  late final _chartsheet_set_chart_opt =
      _chartsheet_set_chart_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<lxw_chart>,
              ffi.Pointer<lxw_chart_options>)>();

  /// @brief Make a chartsheet the active, i.e., visible chartsheet.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// The `%chartsheet_activate()` function is used to specify which chartsheet
  /// is initially visible in a multi-sheet workbook:
  ///
  /// @code
  /// lxw_worksheet  *worksheet1  = workbook_add_worksheet(workbook, NULL);
  /// lxw_chartsheet *chartsheet1 = workbook_add_chartsheet(workbook, NULL);
  /// lxw_chartsheet *chartsheet2 = workbook_add_chartsheet(workbook, NULL);
  /// lxw_chartsheet *chartsheet3 = workbook_add_chartsheet(workbook, NULL);
  ///
  /// chartsheet_activate(chartsheet3);
  /// @endcode
  ///
  /// @image html chartsheet_activate.png
  ///
  /// More than one chartsheet can be selected via the `chartsheet_select()`
  /// function, see below, however only one chartsheet can be active.
  ///
  /// The default active chartsheet is the first chartsheet.
  ///
  /// See also `worksheet_activate()`.
  void chartsheet_activate(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_activate(
      chartsheet,
    );
  }

  late final _chartsheet_activatePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_activate');
  late final _chartsheet_activate = _chartsheet_activatePtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Set a chartsheet tab as selected.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// The `%chartsheet_select()` function is used to indicate that a chartsheet
  /// is selected in a multi-sheet workbook:
  ///
  /// @code
  /// chartsheet_activate(chartsheet1);
  /// chartsheet_select(chartsheet2);
  /// chartsheet_select(chartsheet3);
  ///
  /// @endcode
  ///
  /// A selected chartsheet has its tab highlighted. Selecting chartsheets is a
  /// way of grouping them together so that, for example, several chartsheets
  /// could be printed in one go. A chartsheet that has been activated via the
  /// `chartsheet_activate()` function will also appear as selected.
  ///
  /// See also `worksheet_select()`.
  void chartsheet_select(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_select(
      chartsheet,
    );
  }

  late final _chartsheet_selectPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_select');
  late final _chartsheet_select = _chartsheet_selectPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Hide the current chartsheet.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// The `%chartsheet_hide()` function is used to hide a chartsheet:
  ///
  /// @code
  /// chartsheet_hide(chartsheet2);
  /// @endcode
  ///
  /// You may wish to hide a chartsheet in order to avoid confusing a user with
  /// intermediate data or calculations.
  ///
  /// @image html hide_sheet.png
  ///
  /// A hidden chartsheet can not be activated or selected so this function is
  /// mutually exclusive with the `chartsheet_activate()` and
  /// `chartsheet_select()` functions. In addition, since the first chartsheet
  /// will default to being the active chartsheet, you cannot hide the first
  /// chartsheet without activating another sheet:
  ///
  /// @code
  /// chartsheet_activate(chartsheet2);
  /// chartsheet_hide(chartsheet1);
  /// @endcode
  ///
  /// See also `worksheet_hide()`.
  void chartsheet_hide(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_hide(
      chartsheet,
    );
  }

  late final _chartsheet_hidePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_hide');
  late final _chartsheet_hide = _chartsheet_hidePtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Set current chartsheet as the first visible sheet tab.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// The `chartsheet_activate()` function determines which chartsheet is
  /// initially selected.  However, if there are a large number of chartsheets the
  /// selected chartsheet may not appear on the screen. To avoid this you can
  /// select the leftmost visible chartsheet tab using
  /// `%chartsheet_set_first_sheet()`:
  ///
  /// @code
  /// chartsheet_set_first_sheet(chartsheet19); // First visible chartsheet tab.
  /// chartsheet_activate(chartsheet20);        // First visible chartsheet.
  /// @endcode
  ///
  /// This function is not required very often. The default value is the first
  /// chartsheet.
  ///
  /// See also `worksheet_set_first_sheet()`.
  void chartsheet_set_first_sheet(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_set_first_sheet(
      chartsheet,
    );
  }

  late final _chartsheet_set_first_sheetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_set_first_sheet');
  late final _chartsheet_set_first_sheet = _chartsheet_set_first_sheetPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Set the color of the chartsheet tab.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param color      The tab color.
  ///
  /// The `%chartsheet_set_tab_color()` function is used to change the color of
  /// the chartsheet tab:
  ///
  /// @code
  /// chartsheet_set_tab_color(chartsheet1, LXW_COLOR_RED);
  /// chartsheet_set_tab_color(chartsheet2, LXW_COLOR_GREEN);
  /// chartsheet_set_tab_color(chartsheet3, 0xFF9900); // Orange.
  /// @endcode
  ///
  /// The color should be an RGB integer value, see @ref working_with_colors.
  ///
  /// See also `worksheet_set_tab_color()`.
  void chartsheet_set_tab_color(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    int color,
  ) {
    return _chartsheet_set_tab_color(
      chartsheet,
      color,
    );
  }

  late final _chartsheet_set_tab_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chartsheet>,
              lxw_color_t)>>('chartsheet_set_tab_color');
  late final _chartsheet_set_tab_color = _chartsheet_set_tab_colorPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>, int)>();

  /// @brief Protect elements of a chartsheet from modification.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param password   A chartsheet password.
  /// @param options    Chartsheet elements to protect.
  ///
  /// The `%chartsheet_protect()` function protects chartsheet elements from
  /// modification:
  ///
  /// @code
  /// chartsheet_protect(chartsheet, "Some Password", options);
  /// @endcode
  ///
  /// The `password` and lxw_protection pointer are both optional:
  ///
  /// @code
  /// chartsheet_protect(chartsheet2, NULL,       my_options);
  /// chartsheet_protect(chartsheet3, "password", NULL);
  /// chartsheet_protect(chartsheet4, "password", my_options);
  /// @endcode
  ///
  /// Passing a `NULL` password is the same as turning on protection without a
  /// password. Passing a `NULL` password and `NULL` options had no effect on
  /// chartsheets.
  ///
  /// You can specify which chartsheet elements you wish to protect by passing a
  /// lxw_protection pointer in the `options` argument. In Excel chartsheets only
  /// have two protection options:
  ///
  /// no_content
  /// no_objects
  ///
  /// All parameters are off by default. Individual elements can be protected as
  /// follows:
  ///
  /// @code
  /// lxw_protection options = {
  /// .no_content  = 1,
  /// .no_objects  = 1,
  /// };
  ///
  /// chartsheet_protect(chartsheet, NULL, &options);
  ///
  /// @endcode
  ///
  /// See also worksheet_protect().
  ///
  /// **Note:** Sheet level passwords in Excel offer **very** weak
  /// protection. They don't encrypt your data and are very easy to
  /// deactivate. Full workbook encryption is not supported by `libxlsxwriter`
  /// since it requires a completely different file format.
  void chartsheet_protect(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<lxw_protection> options,
  ) {
    return _chartsheet_protect(
      chartsheet,
      password,
      options,
    );
  }

  late final _chartsheet_protectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_protection>)>>('chartsheet_protect');
  late final _chartsheet_protect = _chartsheet_protectPtr.asFunction<
      void Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<lxw_protection>)>();

  /// @brief Set the chartsheet zoom factor.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param scale      Chartsheet zoom factor.
  ///
  /// Set the chartsheet zoom factor in the range `10 <= zoom <= 400`:
  ///
  /// @code
  /// chartsheet_set_zoom(chartsheet, 75);
  /// @endcode
  ///
  /// The default zoom factor is 100. It isn't possible to set the zoom to
  /// "Selection" because it is calculated by Excel at run-time.
  ///
  /// See also `worksheet_set_zoom()`.
  void chartsheet_set_zoom(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    int scale,
  ) {
    return _chartsheet_set_zoom(
      chartsheet,
      scale,
    );
  }

  late final _chartsheet_set_zoomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chartsheet>, ffi.Uint16)>>('chartsheet_set_zoom');
  late final _chartsheet_set_zoom = _chartsheet_set_zoomPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>, int)>();

  /// @brief Set the page orientation as landscape.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// This function is used to set the orientation of a chartsheet's printed page
  /// to landscape. The default chartsheet orientation is landscape, so this
  /// function isn't generally required:
  ///
  /// @code
  /// chartsheet_set_landscape(chartsheet);
  /// @endcode
  void chartsheet_set_landscape(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_set_landscape(
      chartsheet,
    );
  }

  late final _chartsheet_set_landscapePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_set_landscape');
  late final _chartsheet_set_landscape = _chartsheet_set_landscapePtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Set the page orientation as portrait.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  ///
  /// This function is used to set the orientation of a chartsheet's printed page
  /// to portrait:
  ///
  /// @code
  /// chartsheet_set_portrait(chartsheet);
  /// @endcode
  void chartsheet_set_portrait(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _chartsheet_set_portrait(
      chartsheet,
    );
  }

  late final _chartsheet_set_portraitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'chartsheet_set_portrait');
  late final _chartsheet_set_portrait = _chartsheet_set_portraitPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Set the paper type for printing.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param paper_type The Excel paper format type.
  ///
  /// This function is used to set the paper format for the printed output of a
  /// chartsheet:
  ///
  /// @code
  /// chartsheet_set_paper(chartsheet1, 1);  // US Letter
  /// chartsheet_set_paper(chartsheet2, 9);  // A4
  /// @endcode
  ///
  /// If you do not specify a paper type the chartsheet will print using the
  /// printer's default paper style.
  ///
  /// See `worksheet_set_paper()` for a full list of available paper sizes.
  void chartsheet_set_paper(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    int paper_type,
  ) {
    return _chartsheet_set_paper(
      chartsheet,
      paper_type,
    );
  }

  late final _chartsheet_set_paperPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<lxw_chartsheet>, ffi.Uint8)>>('chartsheet_set_paper');
  late final _chartsheet_set_paper = _chartsheet_set_paperPtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>, int)>();

  /// @brief Set the chartsheet margins for the printed page.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param left       Left margin in inches.   Excel default is 0.7.
  /// @param right      Right margin in inches.  Excel default is 0.7.
  /// @param top        Top margin in inches.    Excel default is 0.75.
  /// @param bottom     Bottom margin in inches. Excel default is 0.75.
  ///
  /// The `%chartsheet_set_margins()` function is used to set the margins of the
  /// chartsheet when it is printed. The units are in inches. Specifying `-1` for
  /// any parameter will give the default Excel value as shown above.
  ///
  /// @code
  /// chartsheet_set_margins(chartsheet, 1.3, 1.2, -1, -1);
  /// @endcode
  void chartsheet_set_margins(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    double left,
    double right,
    double top,
    double bottom,
  ) {
    return _chartsheet_set_margins(
      chartsheet,
      left,
      right,
      top,
      bottom,
    );
  }

  late final _chartsheet_set_marginsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<lxw_chartsheet>, ffi.Double, ffi.Double,
              ffi.Double, ffi.Double)>>('chartsheet_set_margins');
  late final _chartsheet_set_margins = _chartsheet_set_marginsPtr.asFunction<
      void Function(
          ffi.Pointer<lxw_chartsheet>, double, double, double, double)>();

  /// @brief Set the printed page header caption.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param string     The header string.
  ///
  /// @return A #lxw_error code.
  ///
  /// Headers and footers are generated using a string which is a combination of
  /// plain text and control characters
  ///
  /// @code
  /// chartsheet_set_header(chartsheet, "&LHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    | Hello                                                         |
  /// //    |                                                               |
  ///
  ///
  /// chartsheet_set_header(chartsheet, "&CHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                          Hello                                |
  /// //    |                                                               |
  ///
  ///
  /// chartsheet_set_header(chartsheet, "&RHello");
  ///
  /// //     ---------------------------------------------------------------
  /// //    |                                                               |
  /// //    |                                                         Hello |
  /// //    |                                                               |
  ///
  ///
  /// @endcode
  ///
  /// See `worksheet_set_header()` for a full explanation of the syntax of
  /// Excel's header formatting and control characters.
  int chartsheet_set_header(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _chartsheet_set_header(
      chartsheet,
      string,
    );
  }

  late final _chartsheet_set_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_chartsheet>,
              ffi.Pointer<ffi.Char>)>>('chartsheet_set_header');
  late final _chartsheet_set_header = _chartsheet_set_headerPtr.asFunction<
      int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the printed page footer caption.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param string     The footer string.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as chartsheet_set_header().
  int chartsheet_set_footer(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _chartsheet_set_footer(
      chartsheet,
      string,
    );
  }

  late final _chartsheet_set_footerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_chartsheet>,
              ffi.Pointer<ffi.Char>)>>('chartsheet_set_footer');
  late final _chartsheet_set_footer = _chartsheet_set_footerPtr.asFunction<
      int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the printed page header caption with additional options.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param string     The header string.
  /// @param options    Header options.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as chartsheet_set_header() with an
  /// additional parameter to specify options for the header.
  ///
  /// Currently, the only available option is the header margin:
  ///
  /// @code
  ///
  /// lxw_header_footer_options header_options = { 0.2 };
  ///
  /// chartsheet_set_header_opt(chartsheet, "Some text", &header_options);
  ///
  /// @endcode
  int chartsheet_set_header_opt(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_header_footer_options> options,
  ) {
    return _chartsheet_set_header_opt(
      chartsheet,
      string,
      options,
    );
  }

  late final _chartsheet_set_header_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_chartsheet>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_header_footer_options>)>>(
      'chartsheet_set_header_opt');
  late final _chartsheet_set_header_opt =
      _chartsheet_set_header_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_header_footer_options>)>();

  /// @brief Set the printed page footer caption with additional options.
  ///
  /// @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
  /// @param string     The footer string.
  /// @param options    Footer options.
  ///
  /// @return A #lxw_error code.
  ///
  /// The syntax of this function is the same as chartsheet_set_header_opt().
  int chartsheet_set_footer_opt(
    ffi.Pointer<lxw_chartsheet> chartsheet,
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<lxw_header_footer_options> options,
  ) {
    return _chartsheet_set_footer_opt(
      chartsheet,
      string,
      options,
    );
  }

  late final _chartsheet_set_footer_optPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<lxw_chartsheet>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<lxw_header_footer_options>)>>(
      'chartsheet_set_footer_opt');
  late final _chartsheet_set_footer_opt =
      _chartsheet_set_footer_optPtr.asFunction<
          int Function(ffi.Pointer<lxw_chartsheet>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_header_footer_options>)>();

  ffi.Pointer<lxw_chartsheet> lxw_chartsheet_new(
    ffi.Pointer<lxw_worksheet_init_data> init_data,
  ) {
    return _lxw_chartsheet_new(
      init_data,
    );
  }

  late final _lxw_chartsheet_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chartsheet> Function(
              ffi.Pointer<lxw_worksheet_init_data>)>>('lxw_chartsheet_new');
  late final _lxw_chartsheet_new = _lxw_chartsheet_newPtr.asFunction<
      ffi.Pointer<lxw_chartsheet> Function(
          ffi.Pointer<lxw_worksheet_init_data>)>();

  void lxw_chartsheet_free(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _lxw_chartsheet_free(
      chartsheet,
    );
  }

  late final _lxw_chartsheet_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'lxw_chartsheet_free');
  late final _lxw_chartsheet_free = _lxw_chartsheet_freePtr
      .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  void lxw_chartsheet_assemble_xml_file(
    ffi.Pointer<lxw_chartsheet> chartsheet,
  ) {
    return _lxw_chartsheet_assemble_xml_file(
      chartsheet,
    );
  }

  late final _lxw_chartsheet_assemble_xml_filePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chartsheet>)>>(
      'lxw_chartsheet_assemble_xml_file');
  late final _lxw_chartsheet_assemble_xml_file =
      _lxw_chartsheet_assemble_xml_filePtr
          .asFunction<void Function(ffi.Pointer<lxw_chartsheet>)>();

  /// @brief Create a new workbook object.
  ///
  /// @param filename The name of the new Excel file to create.
  ///
  /// @return A lxw_workbook instance.
  ///
  /// The `%workbook_new()` constructor is used to create a new Excel workbook
  /// with a given filename:
  ///
  /// @code
  /// lxw_workbook *workbook  = workbook_new("filename.xlsx");
  /// @endcode
  ///
  /// When specifying a filename it is recommended that you use an `.xlsx`
  /// extension or Excel will generate a warning when opening the file.
  ffi.Pointer<lxw_workbook> workbook_new(
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _workbook_new(
      filename,
    );
  }

  late final _workbook_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_workbook> Function(
              ffi.Pointer<ffi.Char>)>>('workbook_new');
  late final _workbook_new = _workbook_newPtr
      .asFunction<ffi.Pointer<lxw_workbook> Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Create a new workbook object, and set the workbook options.
  ///
  /// @param filename The name of the new Excel file to create.
  /// @param options  Workbook options.
  ///
  /// @return A lxw_workbook instance.
  ///
  /// This function is the same as the `workbook_new()` constructor but allows
  /// additional options to be set.
  ///
  /// @code
  /// lxw_workbook_options options = {.constant_memory = LXW_TRUE,
  /// .tmpdir = "C:\\Temp",
  /// .use_zip64 = LXW_FALSE,
  /// .output_buffer = NULL,
  /// .output_buffer_size = NULL};
  ///
  /// lxw_workbook  *workbook  = workbook_new_opt("filename.xlsx", &options);
  /// @endcode
  ///
  /// The options that can be set via #lxw_workbook_options are:
  ///
  /// - `constant_memory`: This option reduces the amount of data stored in
  /// memory so that large files can be written efficiently. This option is off
  /// by default. See the note below for limitations when this mode is on.
  ///
  /// - `tmpdir`: libxlsxwriter stores workbook data in temporary files prior to
  /// assembling the final XLSX file. The temporary files are created in the
  /// system's temp directory. If the default temporary directory isn't
  /// accessible to your application, or doesn't contain enough space, you can
  /// specify an alternative location using the `tmpdir` option.
  ///
  /// - `use_zip64`: Make the zip library use ZIP64 extensions when writing very
  /// large xlsx files to allow the zip container, or individual XML files
  /// within it, to be greater than 4 GB. See [ZIP64 on Wikipedia][zip64_wiki]
  /// for more information. This option is off by default.
  ///
  /// [zip64_wiki]: https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64
  ///
  /// - `output_buffer`: Output to a memory buffer instead of a file. The buffer
  /// must be freed manually by calling `free()`. This option can only be used if
  /// filename is NULL.
  ///
  /// - `output_buffer_size`: Used with output_buffer to get the size of the
  /// created buffer. This option can only be used if filename is `NULL`.
  ///
  /// @note In `constant_memory` mode each row of in-memory data is written to
  /// disk and then freed when a new row is started via one of the
  /// `worksheet_write_*()` functions. Therefore, once this option is active data
  /// should be written in sequential row by row order. For this reason
  /// `worksheet_merge_range()` and some other row based functionality doesn't
  /// work in this mode. See @ref ww_mem_constant for more details.
  ///
  /// @note Also, in `constant_memory` mode the library uses temp file storage
  /// for worksheet data. This can lead to an issue on OSes that map the `/tmp`
  /// directory into memory since it is possible to consume the "system" memory
  /// even though the "process" memory remains constant. In these cases you
  /// should use an alternative temp file location by using the `tmpdir` option
  /// shown above. See @ref ww_mem_temp for more details.
  ffi.Pointer<lxw_workbook> workbook_new_opt(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<lxw_workbook_options> options,
  ) {
    return _workbook_new_opt(
      filename,
      options,
    );
  }

  late final _workbook_new_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_workbook> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_workbook_options>)>>('workbook_new_opt');
  late final _workbook_new_opt = _workbook_new_optPtr.asFunction<
      ffi.Pointer<lxw_workbook> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_workbook_options>)>();

  /// @brief Add a new worksheet to a workbook.
  ///
  /// @param workbook  Pointer to a lxw_workbook instance.
  /// @param sheetname Optional worksheet name, defaults to Sheet1, etc.
  ///
  /// @return A lxw_worksheet object.
  ///
  /// The `%workbook_add_worksheet()` function adds a new worksheet to a workbook.
  ///
  /// At least one worksheet should be added to a new workbook: The @ref
  /// worksheet.h "Worksheet" object is used to write data and configure a
  /// worksheet in the workbook.
  ///
  /// The `sheetname` parameter is optional. If it is `NULL` the default
  /// Excel convention will be followed, i.e. Sheet1, Sheet2, etc.:
  ///
  /// @code
  /// worksheet = workbook_add_worksheet(workbook, NULL  );     // Sheet1
  /// worksheet = workbook_add_worksheet(workbook, "Foglio2");  // Foglio2
  /// worksheet = workbook_add_worksheet(workbook, "Data");     // Data
  /// worksheet = workbook_add_worksheet(workbook, NULL  );     // Sheet4
  ///
  /// @endcode
  ///
  /// @image html workbook02.png
  ///
  /// The worksheet name must be a valid Excel worksheet name, i.e:
  ///
  /// - The name is less than or equal to 31 UTF-8 characters.
  /// - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
  /// - The name doesn't start or end with an apostrophe.
  /// - The name isn't already in use. (Case insensitive).
  ///
  /// If any of these errors are encountered the function will return NULL.
  /// You can check for valid name using the `workbook_validate_sheet_name()`
  /// function.
  ///
  /// @note You should also avoid using the worksheet name "History" (case
  /// insensitive) which is reserved in English language versions of
  /// Excel. Non-English versions may have restrictions on the equivalent word.
  ffi.Pointer<lxw_worksheet> workbook_add_worksheet(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> sheetname,
  ) {
    return _workbook_add_worksheet(
      workbook,
      sheetname,
    );
  }

  late final _workbook_add_worksheetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_worksheet> Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_add_worksheet');
  late final _workbook_add_worksheet = _workbook_add_worksheetPtr.asFunction<
      ffi.Pointer<lxw_worksheet> Function(
          ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Add a new chartsheet to a workbook.
  ///
  /// @param workbook  Pointer to a lxw_workbook instance.
  /// @param sheetname Optional chartsheet name, defaults to Chart1, etc.
  ///
  /// @return A lxw_chartsheet object.
  ///
  /// The `%workbook_add_chartsheet()` function adds a new chartsheet to a
  /// workbook. The @ref chartsheet.h "Chartsheet" object is like a worksheet
  /// except it displays a chart instead of cell data.
  ///
  /// @image html chartsheet.png
  ///
  /// The `sheetname` parameter is optional. If it is `NULL` the default
  /// Excel convention will be followed, i.e. Chart1, Chart2, etc.:
  ///
  /// @code
  /// chartsheet = workbook_add_chartsheet(workbook, NULL  );     // Chart1
  /// chartsheet = workbook_add_chartsheet(workbook, "My Chart"); // My Chart
  /// chartsheet = workbook_add_chartsheet(workbook, NULL  );     // Chart3
  ///
  /// @endcode
  ///
  /// The chartsheet name must be a valid Excel worksheet name, i.e.:
  ///
  /// - The name is less than or equal to 31 UTF-8 characters.
  /// - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
  /// - The name doesn't start or end with an apostrophe.
  /// - The name isn't already in use. (Case insensitive).
  ///
  /// If any of these errors are encountered the function will return NULL.
  /// You can check for valid name using the `workbook_validate_sheet_name()`
  /// function.
  ///
  /// @note You should also avoid using the worksheet name "History" (case
  /// insensitive) which is reserved in English language versions of
  /// Excel. Non-English versions may have restrictions on the equivalent word.
  ///
  /// At least one worksheet should be added to a new workbook when creating a
  /// chartsheet in order to provide data for the chart. The @ref worksheet.h
  /// "Worksheet" object is used to write data and configure a worksheet in the
  /// workbook.
  ffi.Pointer<lxw_chartsheet> workbook_add_chartsheet(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> sheetname,
  ) {
    return _workbook_add_chartsheet(
      workbook,
      sheetname,
    );
  }

  late final _workbook_add_chartsheetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chartsheet> Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_add_chartsheet');
  late final _workbook_add_chartsheet = _workbook_add_chartsheetPtr.asFunction<
      ffi.Pointer<lxw_chartsheet> Function(
          ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Create a new @ref format.h "Format" object to formats cells in
  /// worksheets.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  ///
  /// @return A lxw_format instance.
  ///
  /// The `workbook_add_format()` function can be used to create new @ref
  /// format.h "Format" objects which are used to apply formatting to a cell.
  ///
  /// @code
  /// // Create the Format.
  /// lxw_format *format = workbook_add_format(workbook);
  ///
  /// // Set some of the format properties.
  /// format_set_bold(format);
  /// format_set_font_color(format, LXW_COLOR_RED);
  ///
  /// // Use the format to change the text format in a cell.
  /// worksheet_write_string(worksheet, 0, 0, "Hello", format);
  /// @endcode
  ///
  /// See @ref format.h "the Format object" and @ref working_with_formats
  /// sections for more details about Format properties and how to set them.
  ffi.Pointer<lxw_format> workbook_add_format(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _workbook_add_format(
      workbook,
    );
  }

  late final _workbook_add_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_format> Function(
              ffi.Pointer<lxw_workbook>)>>('workbook_add_format');
  late final _workbook_add_format = _workbook_add_formatPtr.asFunction<
      ffi.Pointer<lxw_format> Function(ffi.Pointer<lxw_workbook>)>();

  /// @brief Create a new chart to be added to a worksheet:
  ///
  /// @param workbook   Pointer to a lxw_workbook instance.
  /// @param chart_type The type of chart to be created. See #lxw_chart_type.
  ///
  /// @return A lxw_chart object.
  ///
  /// The `%workbook_add_chart()` function creates a new chart object that can
  /// be added to a worksheet:
  ///
  /// @code
  /// // Create a chart object.
  /// lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_COLUMN);
  ///
  /// // Add data series to the chart.
  /// chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
  /// chart_add_series(chart, NULL, "Sheet1!$B$1:$B$5");
  /// chart_add_series(chart, NULL, "Sheet1!$C$1:$C$5");
  ///
  /// // Insert the chart into the worksheet
  /// worksheet_insert_chart(worksheet, CELL("B7"), chart);
  /// @endcode
  ///
  /// The available chart types are defined in #lxw_chart_type. The types of
  /// charts that are supported are:
  ///
  /// | Chart type                               | Description                            |
  /// | :--------------------------------------- | :------------------------------------  |
  /// | #LXW_CHART_AREA                          | Area chart.                            |
  /// | #LXW_CHART_AREA_STACKED                  | Area chart - stacked.                  |
  /// | #LXW_CHART_AREA_STACKED_PERCENT          | Area chart - percentage stacked.       |
  /// | #LXW_CHART_BAR                           | Bar chart.                             |
  /// | #LXW_CHART_BAR_STACKED                   | Bar chart - stacked.                   |
  /// | #LXW_CHART_BAR_STACKED_PERCENT           | Bar chart - percentage stacked.        |
  /// | #LXW_CHART_COLUMN                        | Column chart.                          |
  /// | #LXW_CHART_COLUMN_STACKED                | Column chart - stacked.                |
  /// | #LXW_CHART_COLUMN_STACKED_PERCENT        | Column chart - percentage stacked.     |
  /// | #LXW_CHART_DOUGHNUT                      | Doughnut chart.                        |
  /// | #LXW_CHART_LINE                          | Line chart.                            |
  /// | #LXW_CHART_LINE_STACKED                  | Line chart - stacked.                  |
  /// | #LXW_CHART_LINE_STACKED_PERCENT          | Line chart - percentage stacked.       |
  /// | #LXW_CHART_PIE                           | Pie chart.                             |
  /// | #LXW_CHART_SCATTER                       | Scatter chart.                         |
  /// | #LXW_CHART_SCATTER_STRAIGHT              | Scatter chart - straight.              |
  /// | #LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS | Scatter chart - straight with markers. |
  /// | #LXW_CHART_SCATTER_SMOOTH                | Scatter chart - smooth.                |
  /// | #LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS   | Scatter chart - smooth with markers.   |
  /// | #LXW_CHART_RADAR                         | Radar chart.                           |
  /// | #LXW_CHART_RADAR_WITH_MARKERS            | Radar chart - with markers.            |
  /// | #LXW_CHART_RADAR_FILLED                  | Radar chart - filled.                  |
  ///
  ///
  ///
  /// See @ref chart.h for details.
  ffi.Pointer<lxw_chart> workbook_add_chart(
    ffi.Pointer<lxw_workbook> workbook,
    int chart_type,
  ) {
    return _workbook_add_chart(
      workbook,
      chart_type,
    );
  }

  late final _workbook_add_chartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chart> Function(
              ffi.Pointer<lxw_workbook>, ffi.Uint8)>>('workbook_add_chart');
  late final _workbook_add_chart = _workbook_add_chartPtr.asFunction<
      ffi.Pointer<lxw_chart> Function(ffi.Pointer<lxw_workbook>, int)>();

  /// @brief Close the Workbook object and write the XLSX file.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  ///
  /// @return A #lxw_error.
  ///
  /// The `%workbook_close()` function closes a Workbook object, writes the Excel
  /// file to disk, frees any memory allocated internally to the Workbook and
  /// frees the object itself.
  ///
  /// @code
  /// workbook_close(workbook);
  /// @endcode
  ///
  /// The `%workbook_close()` function returns any #lxw_error error codes
  /// encountered when creating the Excel file. The error code can be returned
  /// from the program main or the calling function:
  ///
  /// @code
  /// return workbook_close(workbook);
  /// @endcode
  int workbook_close(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _workbook_close(
      workbook,
    );
  }

  late final _workbook_closePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<lxw_workbook>)>>(
      'workbook_close');
  late final _workbook_close =
      _workbook_closePtr.asFunction<int Function(ffi.Pointer<lxw_workbook>)>();

  /// @brief Set the document properties such as Title, Author etc.
  ///
  /// @param workbook   Pointer to a lxw_workbook instance.
  /// @param properties Document properties to set.
  ///
  /// @return A #lxw_error.
  ///
  /// The `%workbook_set_properties` function can be used to set the document
  /// properties of the Excel file created by `libxlsxwriter`. These properties
  /// are visible when you use the `Office Button -> Prepare -> Properties`
  /// option in Excel and are also available to external applications that read
  /// or index windows files.
  ///
  /// The properties that can be set are:
  ///
  /// - `title`
  /// - `subject`
  /// - `author`
  /// - `manager`
  /// - `company`
  /// - `category`
  /// - `keywords`
  /// - `comments`
  /// - `hyperlink_base`
  /// - `created`
  ///
  /// The properties are specified via a `lxw_doc_properties` struct. All the
  /// fields are all optional. An example of how to create and pass the
  /// properties is:
  ///
  /// @code
  /// // Create a properties structure and set some of the fields.
  /// lxw_doc_properties properties = {
  /// .title    = "This is an example spreadsheet",
  /// .subject  = "With document properties",
  /// .author   = "John McNamara",
  /// .manager  = "Dr. Heinz Doofenshmirtz",
  /// .company  = "of Wolves",
  /// .category = "Example spreadsheets",
  /// .keywords = "Sample, Example, Properties",
  /// .comments = "Created with libxlsxwriter",
  /// .status   = "Quo",
  /// };
  ///
  /// // Set the properties in the workbook.
  /// workbook_set_properties(workbook, &properties);
  /// @endcode
  ///
  /// @image html doc_properties.png
  ///
  /// The `created` parameter sets the file creation date/time shown in
  /// Excel. This defaults to the current time and date if set to 0. If you wish
  /// to create files that are binary equivalent (for the same input data) then
  /// you should set this creation date/time to a known value using a `time_t`
  /// value.
  int workbook_set_properties(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<lxw_doc_properties> properties,
  ) {
    return _workbook_set_properties(
      workbook,
      properties,
    );
  }

  late final _workbook_set_propertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<lxw_doc_properties>)>>('workbook_set_properties');
  late final _workbook_set_properties = _workbook_set_propertiesPtr.asFunction<
      int Function(
          ffi.Pointer<lxw_workbook>, ffi.Pointer<lxw_doc_properties>)>();

  /// @brief Set a custom document text property.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     The name of the custom property.
  /// @param value    The value of the custom property.
  ///
  /// @return A #lxw_error.
  ///
  /// The `%workbook_set_custom_property_string()` function can be used to set one
  /// or more custom document text properties not covered by the standard
  /// properties in the `workbook_set_properties()` function above.
  ///
  /// For example:
  ///
  /// @code
  /// workbook_set_custom_property_string(workbook, "Checked by", "Eve");
  /// @endcode
  ///
  /// @image html custom_properties.png
  ///
  /// There are 4 `workbook_set_custom_property_string_*()` functions for each
  /// of the custom property types supported by Excel:
  ///
  /// - text/string: `workbook_set_custom_property_string()`
  /// - number:      `workbook_set_custom_property_number()`
  /// - datetime:    `workbook_set_custom_property_datetime()`
  /// - boolean:     `workbook_set_custom_property_boolean()`
  ///
  /// **Note**: the name and value parameters are limited to 255 characters
  /// by Excel.
  int workbook_set_custom_property_string(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _workbook_set_custom_property_string(
      workbook,
      name,
      value,
    );
  }

  late final _workbook_set_custom_property_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('workbook_set_custom_property_string');
  late final _workbook_set_custom_property_string =
      _workbook_set_custom_property_stringPtr.asFunction<
          int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// @brief Set a custom document number property.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     The name of the custom property.
  /// @param value    The value of the custom property.
  ///
  /// @return A #lxw_error.
  ///
  /// Set a custom document number property.
  /// See `workbook_set_custom_property_string()` above for details.
  ///
  /// @code
  /// workbook_set_custom_property_number(workbook, "Document number", 12345);
  /// @endcode
  int workbook_set_custom_property_number(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    double value,
  ) {
    return _workbook_set_custom_property_number(
      workbook,
      name,
      value,
    );
  }

  late final _workbook_set_custom_property_numberPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Double)>>('workbook_set_custom_property_number');
  late final _workbook_set_custom_property_number =
      _workbook_set_custom_property_numberPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>, double)>();

  /// Undocumented since the user can use workbook_set_custom_property_number().
  /// Only implemented for file format completeness and testing.
  int workbook_set_custom_property_integer(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _workbook_set_custom_property_integer(
      workbook,
      name,
      value,
    );
  }

  late final _workbook_set_custom_property_integerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('workbook_set_custom_property_integer');
  late final _workbook_set_custom_property_integer =
      _workbook_set_custom_property_integerPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Set a custom document boolean property.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     The name of the custom property.
  /// @param value    The value of the custom property.
  ///
  /// @return A #lxw_error.
  ///
  /// Set a custom document boolean property.
  /// See `workbook_set_custom_property_string()` above for details.
  ///
  /// @code
  /// workbook_set_custom_property_boolean(workbook, "Has Review", 1);
  /// @endcode
  int workbook_set_custom_property_boolean(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _workbook_set_custom_property_boolean(
      workbook,
      name,
      value,
    );
  }

  late final _workbook_set_custom_property_booleanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Uint8)>>('workbook_set_custom_property_boolean');
  late final _workbook_set_custom_property_boolean =
      _workbook_set_custom_property_booleanPtr.asFunction<
          int Function(
              ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Set a custom document date or time property.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     The name of the custom property.
  /// @param datetime The value of the custom property.
  ///
  /// @return A #lxw_error.
  ///
  /// Set a custom date or time number property.
  /// See `workbook_set_custom_property_string()` above for details.
  ///
  /// @code
  /// lxw_datetime datetime  = {2016, 12, 1,  11, 55, 0.0};
  ///
  /// workbook_set_custom_property_datetime(workbook, "Date completed", &datetime);
  /// @endcode
  int workbook_set_custom_property_datetime(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<lxw_datetime> datetime,
  ) {
    return _workbook_set_custom_property_datetime(
      workbook,
      name,
      datetime,
    );
  }

  late final _workbook_set_custom_property_datetimePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<lxw_workbook>,
                  ffi.Pointer<ffi.Char>, ffi.Pointer<lxw_datetime>)>>(
      'workbook_set_custom_property_datetime');
  late final _workbook_set_custom_property_datetime =
      _workbook_set_custom_property_datetimePtr.asFunction<
          int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<lxw_datetime>)>();

  /// @brief Create a defined name in the workbook to use as a variable.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     The defined name.
  /// @param formula  The cell or range that the defined name refers to.
  ///
  /// @return A #lxw_error.
  ///
  /// This function is used to defined a name that can be used to represent a
  /// value, a single cell or a range of cells in a workbook: These defined names
  /// can then be used in formulas:
  ///
  /// @code
  /// workbook_define_name(workbook, "Exchange_rate", "=0.96");
  /// worksheet_write_formula(worksheet, 2, 1, "=Exchange_rate", NULL);
  ///
  /// @endcode
  ///
  /// @image html defined_name.png
  ///
  /// As in Excel a name defined like this is "global" to the workbook and can be
  /// referred to from any worksheet:
  ///
  /// @code
  /// // Global workbook name.
  /// workbook_define_name(workbook, "Sales", "=Sheet1!$G$1:$H$10");
  /// @endcode
  ///
  /// It is also possible to define a local/worksheet name by prefixing it with
  /// the sheet name using the syntax `'sheetname!definedname'`:
  ///
  /// @code
  /// // Local worksheet name.
  /// workbook_define_name(workbook, "Sheet2!Sales", "=Sheet2!$G$1:$G$10");
  /// @endcode
  ///
  /// If the sheet name contains spaces or special characters you must follow the
  /// Excel convention and enclose it in single quotes:
  ///
  /// @code
  /// workbook_define_name(workbook, "'New Data'!Sales", "=Sheet2!$G$1:$G$10");
  /// @endcode
  ///
  /// The rules for names in Excel are explained in the
  /// [Microsoft Office documentation](http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx).
  int workbook_define_name(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> formula,
  ) {
    return _workbook_define_name(
      workbook,
      name,
      formula,
    );
  }

  late final _workbook_define_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('workbook_define_name');
  late final _workbook_define_name = _workbook_define_namePtr.asFunction<
      int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// @brief Get the default URL format used with `worksheet_write_url()`.
  ///
  /// @param  workbook Pointer to a lxw_workbook instance.
  /// @return A lxw_format instance that has hyperlink properties set.
  ///
  /// This function returns a lxw_format instance that is used for the default
  /// blue underline hyperlink in the `worksheet_write_url()` function when a
  /// format isn't specified:
  ///
  /// @code
  /// lxw_format *url_format = workbook_get_default_url_format(workbook);
  /// @endcode
  ///
  /// The format is the hyperlink style defined by Excel for the default theme.
  /// This format is only ever required when overwriting a string URL with
  /// data of a different type. See the example below.
  ffi.Pointer<lxw_format> workbook_get_default_url_format(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _workbook_get_default_url_format(
      workbook,
    );
  }

  late final _workbook_get_default_url_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_format> Function(
              ffi.Pointer<lxw_workbook>)>>('workbook_get_default_url_format');
  late final _workbook_get_default_url_format =
      _workbook_get_default_url_formatPtr.asFunction<
          ffi.Pointer<lxw_format> Function(ffi.Pointer<lxw_workbook>)>();

  /// @brief Get a worksheet object from its name.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     Worksheet name.
  ///
  /// @return A lxw_worksheet object.
  ///
  /// This function returns a lxw_worksheet object reference based on its name:
  ///
  /// @code
  /// worksheet = workbook_get_worksheet_by_name(workbook, "Sheet1");
  /// @endcode
  ffi.Pointer<lxw_worksheet> workbook_get_worksheet_by_name(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _workbook_get_worksheet_by_name(
      workbook,
      name,
    );
  }

  late final _workbook_get_worksheet_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_worksheet> Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_get_worksheet_by_name');
  late final _workbook_get_worksheet_by_name =
      _workbook_get_worksheet_by_namePtr.asFunction<
          ffi.Pointer<lxw_worksheet> Function(
              ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Get a chartsheet object from its name.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     chartsheet name.
  ///
  /// @return A lxw_chartsheet object.
  ///
  /// This function returns a lxw_chartsheet object reference based on its name:
  ///
  /// @code
  /// chartsheet = workbook_get_chartsheet_by_name(workbook, "Chart1");
  /// @endcode
  ffi.Pointer<lxw_chartsheet> workbook_get_chartsheet_by_name(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _workbook_get_chartsheet_by_name(
      workbook,
      name,
    );
  }

  late final _workbook_get_chartsheet_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<lxw_chartsheet> Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_get_chartsheet_by_name');
  late final _workbook_get_chartsheet_by_name =
      _workbook_get_chartsheet_by_namePtr.asFunction<
          ffi.Pointer<lxw_chartsheet> Function(
              ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Validate a worksheet or chartsheet name.
  ///
  /// @param workbook  Pointer to a lxw_workbook instance.
  /// @param sheetname Sheet name to validate.
  ///
  /// @return A #lxw_error.
  ///
  /// This function is used to validate a worksheet or chartsheet name according
  /// to the rules used by Excel:
  ///
  /// - The name is less than or equal to 31 UTF-8 characters.
  /// - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
  /// - The name doesn't start or end with an apostrophe.
  /// - The name isn't already in use. (Case insensitive, see the note below).
  ///
  /// @code
  /// lxw_error err = workbook_validate_sheet_name(workbook, "Foglio");
  /// @endcode
  ///
  /// This function is called by `workbook_add_worksheet()` and
  /// `workbook_add_chartsheet()` but it can be explicitly called by the user
  /// beforehand to ensure that the sheet name is valid.
  ///
  /// @note You should also avoid using the worksheet name "History" (case
  /// insensitive) which is reserved in English language versions of
  /// Excel. Non-English versions may have restrictions on the equivalent word.
  ///
  /// @note This function does an ASCII lowercase string comparison to determine
  /// if the sheet name is already in use. It doesn't take UTF-8 characters into
  /// account. Thus it would flag "Caf" and "caf" as a duplicate (just like
  /// Excel) but it wouldn't catch "CAF". If you need a full UTF-8 case
  /// insensitive check you should use a third party library to implement it.
  int workbook_validate_sheet_name(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> sheetname,
  ) {
    return _workbook_validate_sheet_name(
      workbook,
      sheetname,
    );
  }

  late final _workbook_validate_sheet_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_validate_sheet_name');
  late final _workbook_validate_sheet_name =
      _workbook_validate_sheet_namePtr.asFunction<
          int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Add a vbaProject binary to the Excel workbook.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param filename The path/filename of the vbaProject.bin file.
  ///
  /// The `%workbook_add_vba_project()` function can be used to add macros or
  /// functions to a workbook using a binary VBA project file that has been
  /// extracted from an existing Excel xlsm file:
  ///
  /// @code
  /// workbook_add_vba_project(workbook, "vbaProject.bin");
  /// @endcode
  ///
  /// Only one `vbaProject.bin file` can be added per workbook. The name doesn't
  /// have to be `vbaProject.bin`. Any suitable path/name for an existing VBA bin
  /// file will do.
  ///
  /// Once you add a VBA project had been add to an libxlsxwriter workbook you
  /// should ensure that the file extension is `.xlsm` to prevent Excel from
  /// giving a warning when it opens the file:
  ///
  /// @code
  /// lxw_workbook *workbook = new_workbook("macro.xlsm");
  /// @endcode
  ///
  /// See also @ref working_with_macros
  ///
  /// @return A #lxw_error.
  int workbook_add_vba_project(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _workbook_add_vba_project(
      workbook,
      filename,
    );
  }

  late final _workbook_add_vba_projectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_add_vba_project');
  late final _workbook_add_vba_project =
      _workbook_add_vba_projectPtr.asFunction<
          int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Set the VBA name for the workbook.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  /// @param name     Name of the workbook used by VBA.
  ///
  /// The `workbook_set_vba_name()` function can be used to set the VBA name for
  /// the workbook. This is sometimes required when a vbaProject macro included
  /// via `workbook_add_vba_project()` refers to the workbook by a name other
  /// than `ThisWorkbook`.
  ///
  /// @code
  /// workbook_set_vba_name(workbook, "MyWorkbook");
  /// @endcode
  ///
  /// If an Excel VBA name for the workbook isn't specified then libxlsxwriter
  /// will use `ThisWorkbook`.
  ///
  /// See also @ref working_with_macros
  ///
  /// @return A #lxw_error.
  int workbook_set_vba_name(
    ffi.Pointer<lxw_workbook> workbook,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _workbook_set_vba_name(
      workbook,
      name,
    );
  }

  late final _workbook_set_vba_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<lxw_workbook>,
              ffi.Pointer<ffi.Char>)>>('workbook_set_vba_name');
  late final _workbook_set_vba_name = _workbook_set_vba_namePtr.asFunction<
      int Function(ffi.Pointer<lxw_workbook>, ffi.Pointer<ffi.Char>)>();

  /// @brief Add a recommendation to open the file in "read-only" mode.
  ///
  /// @param workbook Pointer to a lxw_workbook instance.
  ///
  /// This function can be used to set the Excel "Read-only Recommended" option
  /// that is available when saving a file. This presents the user of the file
  /// with an option to open it in "read-only" mode. This means that any changes
  /// to the file can't be saved back to the same file and must be saved to a new
  /// file. It can be set as follows:
  ///
  /// @code
  /// workbook_read_only_recommended(workbook);
  /// @endcode
  ///
  /// Which will raise a dialog like the following when opening the file:
  ///
  /// @image html read_only.png
  void workbook_read_only_recommended(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _workbook_read_only_recommended(
      workbook,
    );
  }

  late final _workbook_read_only_recommendedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_workbook>)>>(
          'workbook_read_only_recommended');
  late final _workbook_read_only_recommended =
      _workbook_read_only_recommendedPtr
          .asFunction<void Function(ffi.Pointer<lxw_workbook>)>();

  void lxw_workbook_free(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _lxw_workbook_free(
      workbook,
    );
  }

  late final _lxw_workbook_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_workbook>)>>(
          'lxw_workbook_free');
  late final _lxw_workbook_free = _lxw_workbook_freePtr
      .asFunction<void Function(ffi.Pointer<lxw_workbook>)>();

  void lxw_workbook_assemble_xml_file(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _lxw_workbook_assemble_xml_file(
      workbook,
    );
  }

  late final _lxw_workbook_assemble_xml_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_workbook>)>>(
          'lxw_workbook_assemble_xml_file');
  late final _lxw_workbook_assemble_xml_file =
      _lxw_workbook_assemble_xml_filePtr
          .asFunction<void Function(ffi.Pointer<lxw_workbook>)>();

  void lxw_workbook_set_default_xf_indices(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _lxw_workbook_set_default_xf_indices(
      workbook,
    );
  }

  late final _lxw_workbook_set_default_xf_indicesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_workbook>)>>(
          'lxw_workbook_set_default_xf_indices');
  late final _lxw_workbook_set_default_xf_indices =
      _lxw_workbook_set_default_xf_indicesPtr
          .asFunction<void Function(ffi.Pointer<lxw_workbook>)>();

  void workbook_unset_default_url_format(
    ffi.Pointer<lxw_workbook> workbook,
  ) {
    return _workbook_unset_default_url_format(
      workbook,
    );
  }

  late final _workbook_unset_default_url_formatPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_workbook>)>>(
          'workbook_unset_default_url_format');
  late final _workbook_unset_default_url_format =
      _workbook_unset_default_url_formatPtr
          .asFunction<void Function(ffi.Pointer<lxw_workbook>)>();
}

/// Boolean values used in libxlsxwriter.
abstract class lxw_boolean {
  /// False value.
  static const int LXW_FALSE = 0;

  /// True value.
  static const int LXW_TRUE = 1;

  /// False value. Used to turn off a property that is default on, in order
  /// to distinguish it from an uninitialized value.
  static const int LXW_EXPLICIT_FALSE = 2;
}

/// @brief Error codes from libxlsxwriter functions.
///
/// See the `lxw_strerror()` function for an example of how to convert the
/// enum number to a descriptive error message string.
abstract class lxw_error {
  /// No error.
  static const int LXW_NO_ERROR = 0;

  /// Memory error, failed to malloc() required memory.
  static const int LXW_ERROR_MEMORY_MALLOC_FAILED = 1;

  /// Error creating output xlsx file. Usually a permissions error.
  static const int LXW_ERROR_CREATING_XLSX_FILE = 2;

  /// Error encountered when creating a tmpfile during file assembly.
  static const int LXW_ERROR_CREATING_TMPFILE = 3;

  /// Error reading a tmpfile.
  static const int LXW_ERROR_READING_TMPFILE = 4;

  /// Zip generic error ZIP_ERRNO while creating the xlsx file.
  static const int LXW_ERROR_ZIP_FILE_OPERATION = 5;

  /// Zip error ZIP_PARAMERROR while creating the xlsx file.
  static const int LXW_ERROR_ZIP_PARAMETER_ERROR = 6;

  /// Zip error ZIP_BADZIPFILE (use_zip64 option may be required).
  static const int LXW_ERROR_ZIP_BAD_ZIP_FILE = 7;

  /// Zip error ZIP_INTERNALERROR while creating the xlsx file.
  static const int LXW_ERROR_ZIP_INTERNAL_ERROR = 8;

  /// File error or unknown zip error when adding sub file to xlsx file.
  static const int LXW_ERROR_ZIP_FILE_ADD = 9;

  /// Unknown zip error when closing xlsx file.
  static const int LXW_ERROR_ZIP_CLOSE = 10;

  /// Feature is not currently supported in this configuration.
  static const int LXW_ERROR_FEATURE_NOT_SUPPORTED = 11;

  /// NULL function parameter ignored.
  static const int LXW_ERROR_NULL_PARAMETER_IGNORED = 12;

  /// Function parameter validation error.
  static const int LXW_ERROR_PARAMETER_VALIDATION = 13;

  /// Worksheet name exceeds Excel's limit of 31 characters.
  static const int LXW_ERROR_SHEETNAME_LENGTH_EXCEEDED = 14;

  /// Worksheet name cannot contain invalid characters: '[ ] : * ? / \\'
  static const int LXW_ERROR_INVALID_SHEETNAME_CHARACTER = 15;

  /// Worksheet name cannot start or end with an apostrophe.
  static const int LXW_ERROR_SHEETNAME_START_END_APOSTROPHE = 16;

  /// Worksheet name is already in use.
  static const int LXW_ERROR_SHEETNAME_ALREADY_USED = 17;

  /// Parameter exceeds Excel's limit of 32 characters.
  static const int LXW_ERROR_32_STRING_LENGTH_EXCEEDED = 18;

  /// Parameter exceeds Excel's limit of 128 characters.
  static const int LXW_ERROR_128_STRING_LENGTH_EXCEEDED = 19;

  /// Parameter exceeds Excel's limit of 255 characters.
  static const int LXW_ERROR_255_STRING_LENGTH_EXCEEDED = 20;

  /// String exceeds Excel's limit of 32,767 characters.
  static const int LXW_ERROR_MAX_STRING_LENGTH_EXCEEDED = 21;

  /// Error finding internal string index.
  static const int LXW_ERROR_SHARED_STRING_INDEX_NOT_FOUND = 22;

  /// Worksheet row or column index out of range.
  static const int LXW_ERROR_WORKSHEET_INDEX_OUT_OF_RANGE = 23;

  /// Maximum hyperlink length (2079) exceeded.
  static const int LXW_ERROR_WORKSHEET_MAX_URL_LENGTH_EXCEEDED = 24;

  /// Maximum number of worksheet URLs (65530) exceeded.
  static const int LXW_ERROR_WORKSHEET_MAX_NUMBER_URLS_EXCEEDED = 25;

  /// Couldn't read image dimensions or DPI.
  static const int LXW_ERROR_IMAGE_DIMENSIONS = 26;
  static const int LXW_MAX_ERRNO = 27;
}

/// @brief Struct to represent a date and time in Excel.
///
/// Struct to represent a date and time in Excel. See @ref working_with_dates.
class lxw_datetime extends ffi.Struct {
  /// Year     : 1900 - 9999
  @ffi.Int()
  external int year;

  /// Month    : 1 - 12
  @ffi.Int()
  external int month;

  /// Day      : 1 - 31
  @ffi.Int()
  external int day;

  /// Hour     : 0 - 23
  @ffi.Int()
  external int hour;

  /// Minute   : 0 - 59
  @ffi.Int()
  external int min;

  /// Seconds  : 0 - 59.999
  @ffi.Double()
  external double sec;
}

abstract class lxw_custom_property_types {
  static const int LXW_CUSTOM_NONE = 0;
  static const int LXW_CUSTOM_STRING = 1;
  static const int LXW_CUSTOM_DOUBLE = 2;
  static const int LXW_CUSTOM_INTEGER = 3;
  static const int LXW_CUSTOM_BOOLEAN = 4;
  static const int LXW_CUSTOM_DATETIME = 5;
}

/// Define the queue.h structs for the formats list.
class lxw_formats extends ffi.Struct {
  external ffi.Pointer<lxw_format> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_format>> stqh_last;
}

/// @brief Struct to represent the formatting properties of an Excel format.
///
/// Formats in `libxlsxwriter` are accessed via this struct.
///
/// The members of the lxw_format struct aren't modified directly. Instead the
/// format properties are set by calling the functions shown in format.h.
///
/// For example:
///
/// @code
/// // Create the Format.
/// lxw_format *format = workbook_add_format(workbook);
///
/// // Set some of the format properties.
/// format_set_bold(format);
/// format_set_font_color(format, LXW_COLOR_RED);
///
/// // Use the format to change the text format in a cell.
/// worksheet_write_string(worksheet, 0, 0, "Hello", format);
///
/// @endcode
class lxw_format extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  external ffi.Pointer<lxw_hash_table> xf_format_indices;

  external ffi.Pointer<lxw_hash_table> dxf_format_indices;

  external ffi.Pointer<ffi.Uint16> num_xf_formats;

  external ffi.Pointer<ffi.Uint16> num_dxf_formats;

  @ffi.Int32()
  external int xf_index;

  @ffi.Int32()
  external int dxf_index;

  @ffi.Int32()
  external int xf_id;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> num_format;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> font_name;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> font_scheme;

  @ffi.Uint16()
  external int num_format_index;

  @ffi.Uint16()
  external int font_index;

  @ffi.Uint8()
  external int has_font;

  @ffi.Uint8()
  external int has_dxf_font;

  @ffi.Double()
  external double font_size;

  @ffi.Uint8()
  external int bold;

  @ffi.Uint8()
  external int italic;

  @lxw_color_t()
  external int font_color;

  @ffi.Uint8()
  external int underline;

  @ffi.Uint8()
  external int font_strikeout;

  @ffi.Uint8()
  external int font_outline;

  @ffi.Uint8()
  external int font_shadow;

  @ffi.Uint8()
  external int font_script;

  @ffi.Uint8()
  external int font_family;

  @ffi.Uint8()
  external int font_charset;

  @ffi.Uint8()
  external int font_condense;

  @ffi.Uint8()
  external int font_extend;

  @ffi.Uint8()
  external int theme;

  @ffi.Uint8()
  external int hyperlink;

  @ffi.Uint8()
  external int hidden;

  @ffi.Uint8()
  external int locked;

  @ffi.Uint8()
  external int text_h_align;

  @ffi.Uint8()
  external int text_wrap;

  @ffi.Uint8()
  external int text_v_align;

  @ffi.Uint8()
  external int text_justlast;

  @ffi.Int16()
  external int rotation;

  @lxw_color_t()
  external int fg_color;

  @lxw_color_t()
  external int bg_color;

  @lxw_color_t()
  external int dxf_fg_color;

  @lxw_color_t()
  external int dxf_bg_color;

  @ffi.Uint8()
  external int pattern;

  @ffi.Uint8()
  external int has_fill;

  @ffi.Uint8()
  external int has_dxf_fill;

  @ffi.Int32()
  external int fill_index;

  @ffi.Int32()
  external int fill_count;

  @ffi.Int32()
  external int border_index;

  @ffi.Uint8()
  external int has_border;

  @ffi.Uint8()
  external int has_dxf_border;

  @ffi.Int32()
  external int border_count;

  @ffi.Uint8()
  external int bottom;

  @ffi.Uint8()
  external int diag_border;

  @ffi.Uint8()
  external int diag_type;

  @ffi.Uint8()
  external int left;

  @ffi.Uint8()
  external int right;

  @ffi.Uint8()
  external int top;

  @lxw_color_t()
  external int bottom_color;

  @lxw_color_t()
  external int diag_color;

  @lxw_color_t()
  external int left_color;

  @lxw_color_t()
  external int right_color;

  @lxw_color_t()
  external int top_color;

  @ffi.Uint8()
  external int indent;

  @ffi.Uint8()
  external int shrink;

  @ffi.Uint8()
  external int merge_range;

  @ffi.Uint8()
  external int reading_order;

  @ffi.Uint8()
  external int just_distrib;

  @ffi.Uint8()
  external int color_indexed;

  @ffi.Uint8()
  external int font_only;

  @ffi.Uint8()
  external int quote_prefix;

  external UnnamedStruct3 list_pointers;
}

typedef FILE = _IO_FILE;

class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

class _IO_marker extends ffi.Opaque {}

typedef __off_t = ffi.Long;
typedef _IO_lock_t = ffi.Void;
typedef __off64_t = ffi.Long;

class _IO_codecvt extends ffi.Opaque {}

class _IO_wide_data extends ffi.Opaque {}

/// LXW_HASH hash table struct.
class lxw_hash_table extends ffi.Struct {
  @ffi.Uint32()
  external int num_buckets;

  @ffi.Uint32()
  external int used_buckets;

  @ffi.Uint32()
  external int unique_count;

  @ffi.Uint8()
  external int free_key;

  @ffi.Uint8()
  external int free_value;

  external ffi.Pointer<lxw_hash_order_list> order_list;

  external ffi.Pointer<ffi.Pointer<lxw_hash_bucket_list>> buckets;
}

/// List declarations.
class lxw_hash_order_list extends ffi.Struct {
  external ffi.Pointer<lxw_hash_element> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_hash_element>> stqh_last;
}

/// LXW_HASH table element struct.
///
/// The hash elements contain pointers to allow them to be stored in
/// lists in the the hash table buckets and also pointers to track the
/// insertion order in a separate list.
class lxw_hash_element extends ffi.Struct {
  external ffi.Pointer<ffi.Void> key;

  external ffi.Pointer<ffi.Void> value;

  external UnnamedStruct1 lxw_hash_order_pointers;

  external UnnamedStruct2 lxw_hash_list_pointers;
}

class UnnamedStruct1 extends ffi.Struct {
  external ffi.Pointer<lxw_hash_element> stqe_next;
}

class UnnamedStruct2 extends ffi.Struct {
  external ffi.Pointer<lxw_hash_element> sle_next;
}

class lxw_hash_bucket_list extends ffi.Struct {
  external ffi.Pointer<lxw_hash_element> slh_first;
}

/// @brief The type for RGB colors in libxlsxwriter.
///
/// The type for RGB colors in libxlsxwriter. The valid range is `0x000000`
/// (black) to `0xFFFFFF` (white). See @ref working_with_colors.
typedef lxw_color_t = ffi.Uint32;

class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<lxw_format> stqe_next;
}

/// Define the queue.h structs for the generic data structs.
class lxw_tuples extends ffi.Struct {
  external ffi.Pointer<lxw_tuple> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_tuple>> stqh_last;
}

class lxw_tuple extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;

  external UnnamedStruct4 list_pointers;
}

class UnnamedStruct4 extends ffi.Struct {
  external ffi.Pointer<lxw_tuple> stqe_next;
}

class lxw_custom_properties extends ffi.Struct {
  external ffi.Pointer<lxw_custom_property> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_custom_property>> stqh_last;
}

/// Define custom property used in workbook.c and custom.c.
class lxw_custom_property extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  external UnnamedUnion1 u;

  external UnnamedStruct5 list_pointers;
}

class UnnamedUnion1 extends ffi.Union {
  external ffi.Pointer<ffi.Char> string;

  @ffi.Double()
  external double number;

  @ffi.Int32()
  external int integer;

  @ffi.Uint8()
  external int boolean;

  external lxw_datetime datetime;
}

class UnnamedStruct5 extends ffi.Struct {
  external ffi.Pointer<lxw_custom_property> stqe_next;
}

/// Define a tree.h RB structure for storing shared strings.
class sst_rb_tree extends ffi.Struct {
  external ffi.Pointer<sst_element> rbh_root;
}

/// Elements of the SST table. They contain pointers to allow them to
/// be stored in a RB tree and also pointers to track the insertion order
/// in a separate list.
class sst_element extends ffi.Struct {
  @ffi.Uint32()
  external int index;

  external ffi.Pointer<ffi.Char> string;

  @ffi.Uint8()
  external int is_rich_string;

  external UnnamedStruct6 sst_order_pointers;

  external UnnamedStruct7 sst_tree_pointers;
}

class UnnamedStruct6 extends ffi.Struct {
  external ffi.Pointer<sst_element> stqe_next;
}

class UnnamedStruct7 extends ffi.Struct {
  external ffi.Pointer<sst_element> rbe_left;

  external ffi.Pointer<sst_element> rbe_right;

  external ffi.Pointer<sst_element> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

/// Define a queue.h structure for storing shared strings in insertion order.
class sst_order_list extends ffi.Struct {
  external ffi.Pointer<sst_element> stqh_first;

  external ffi.Pointer<ffi.Pointer<sst_element>> stqh_last;
}

/// Struct to represent a sst.
class lxw_sst extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  @ffi.Uint32()
  external int string_count;

  @ffi.Uint32()
  external int unique_count;

  external ffi.Pointer<sst_order_list> order_list;

  external ffi.Pointer<sst_rb_tree> rb_tree;
}

/// Format underline values for format_set_underline().
abstract class lxw_format_underlines {
  static const int LXW_UNDERLINE_NONE = 0;

  /// Single underline
  static const int LXW_UNDERLINE_SINGLE = 1;

  /// Double underline
  static const int LXW_UNDERLINE_DOUBLE = 2;

  /// Single accounting underline
  static const int LXW_UNDERLINE_SINGLE_ACCOUNTING = 3;

  /// Double accounting underline
  static const int LXW_UNDERLINE_DOUBLE_ACCOUNTING = 4;
}

/// Superscript and subscript values for format_set_font_script().
abstract class lxw_format_scripts {
  /// Superscript font
  static const int LXW_FONT_SUPERSCRIPT = 1;

  /// Subscript font
  static const int LXW_FONT_SUBSCRIPT = 2;
}

/// Alignment values for format_set_align().
abstract class lxw_format_alignments {
  /// No alignment. Cell will use Excel's default for the data type
  static const int LXW_ALIGN_NONE = 0;

  /// Left horizontal alignment
  static const int LXW_ALIGN_LEFT = 1;

  /// Center horizontal alignment
  static const int LXW_ALIGN_CENTER = 2;

  /// Right horizontal alignment
  static const int LXW_ALIGN_RIGHT = 3;

  /// Cell fill horizontal alignment
  static const int LXW_ALIGN_FILL = 4;

  /// Justify horizontal alignment
  static const int LXW_ALIGN_JUSTIFY = 5;

  /// Center Across horizontal alignment
  static const int LXW_ALIGN_CENTER_ACROSS = 6;

  /// Left horizontal alignment
  static const int LXW_ALIGN_DISTRIBUTED = 7;

  /// Top vertical alignment
  static const int LXW_ALIGN_VERTICAL_TOP = 8;

  /// Bottom vertical alignment
  static const int LXW_ALIGN_VERTICAL_BOTTOM = 9;

  /// Center vertical alignment
  static const int LXW_ALIGN_VERTICAL_CENTER = 10;

  /// Justify vertical alignment
  static const int LXW_ALIGN_VERTICAL_JUSTIFY = 11;

  /// Distributed vertical alignment
  static const int LXW_ALIGN_VERTICAL_DISTRIBUTED = 12;
}

/// Diagonal border types.
abstract class lxw_format_diagonal_types {
  /// Cell diagonal border from bottom left to top right.
  static const int LXW_DIAGONAL_BORDER_UP = 1;

  /// Cell diagonal border from top left to bottom right.
  static const int LXW_DIAGONAL_BORDER_DOWN = 2;

  /// Cell diagonal border in both directions.
  static const int LXW_DIAGONAL_BORDER_UP_DOWN = 3;
}

/// Predefined values for common colors.
abstract class lxw_defined_colors {
  /// Black
  static const int LXW_COLOR_BLACK = 16777216;

  /// Blue
  static const int LXW_COLOR_BLUE = 255;

  /// Brown
  static const int LXW_COLOR_BROWN = 8388608;

  /// Cyan
  static const int LXW_COLOR_CYAN = 65535;

  /// Gray
  static const int LXW_COLOR_GRAY = 8421504;

  /// Green
  static const int LXW_COLOR_GREEN = 32768;

  /// Lime
  static const int LXW_COLOR_LIME = 65280;

  /// Magenta
  static const int LXW_COLOR_MAGENTA = 16711935;

  /// Navy
  static const int LXW_COLOR_NAVY = 128;

  /// Orange
  static const int LXW_COLOR_ORANGE = 16737792;

  /// Pink
  static const int LXW_COLOR_PINK = 16711935;

  /// Purple
  static const int LXW_COLOR_PURPLE = 8388736;

  /// Red
  static const int LXW_COLOR_RED = 16711680;

  /// Silver
  static const int LXW_COLOR_SILVER = 12632256;

  /// White
  static const int LXW_COLOR_WHITE = 16777215;

  /// Yellow
  static const int LXW_COLOR_YELLOW = 16776960;
}

/// Pattern value for use with format_set_pattern().
abstract class lxw_format_patterns {
  /// Empty pattern
  static const int LXW_PATTERN_NONE = 0;

  /// Solid pattern
  static const int LXW_PATTERN_SOLID = 1;

  /// Medium gray pattern
  static const int LXW_PATTERN_MEDIUM_GRAY = 2;

  /// Dark gray pattern
  static const int LXW_PATTERN_DARK_GRAY = 3;

  /// Light gray pattern
  static const int LXW_PATTERN_LIGHT_GRAY = 4;

  /// Dark horizontal line pattern
  static const int LXW_PATTERN_DARK_HORIZONTAL = 5;

  /// Dark vertical line pattern
  static const int LXW_PATTERN_DARK_VERTICAL = 6;

  /// Dark diagonal stripe pattern
  static const int LXW_PATTERN_DARK_DOWN = 7;

  /// Reverse dark diagonal stripe pattern
  static const int LXW_PATTERN_DARK_UP = 8;

  /// Dark grid pattern
  static const int LXW_PATTERN_DARK_GRID = 9;

  /// Dark trellis pattern
  static const int LXW_PATTERN_DARK_TRELLIS = 10;

  /// Light horizontal Line pattern
  static const int LXW_PATTERN_LIGHT_HORIZONTAL = 11;

  /// Light vertical line pattern
  static const int LXW_PATTERN_LIGHT_VERTICAL = 12;

  /// Light diagonal stripe pattern
  static const int LXW_PATTERN_LIGHT_DOWN = 13;

  /// Reverse light diagonal stripe pattern
  static const int LXW_PATTERN_LIGHT_UP = 14;

  /// Light grid pattern
  static const int LXW_PATTERN_LIGHT_GRID = 15;

  /// Light trellis pattern
  static const int LXW_PATTERN_LIGHT_TRELLIS = 16;

  /// 12.5% gray pattern
  static const int LXW_PATTERN_GRAY_125 = 17;

  /// 6.25% gray pattern
  static const int LXW_PATTERN_GRAY_0625 = 18;
}

/// Cell border styles for use with format_set_border().
abstract class lxw_format_borders {
  /// No border
  static const int LXW_BORDER_NONE = 0;

  /// Thin border style
  static const int LXW_BORDER_THIN = 1;

  /// Medium border style
  static const int LXW_BORDER_MEDIUM = 2;

  /// Dashed border style
  static const int LXW_BORDER_DASHED = 3;

  /// Dotted border style
  static const int LXW_BORDER_DOTTED = 4;

  /// Thick border style
  static const int LXW_BORDER_THICK = 5;

  /// Double border style
  static const int LXW_BORDER_DOUBLE = 6;

  /// Hair border style
  static const int LXW_BORDER_HAIR = 7;

  /// Medium dashed border style
  static const int LXW_BORDER_MEDIUM_DASHED = 8;

  /// Dash-dot border style
  static const int LXW_BORDER_DASH_DOT = 9;

  /// Medium dash-dot border style
  static const int LXW_BORDER_MEDIUM_DASH_DOT = 10;

  /// Dash-dot-dot border style
  static const int LXW_BORDER_DASH_DOT_DOT = 11;

  /// Medium dash-dot-dot border style
  static const int LXW_BORDER_MEDIUM_DASH_DOT_DOT = 12;

  /// Slant dash-dot border style
  static const int LXW_BORDER_SLANT_DASH_DOT = 13;
}

/// Struct to represent the font component of a format.
class lxw_font extends ffi.Struct {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> font_name;

  @ffi.Double()
  external double font_size;

  @ffi.Uint8()
  external int bold;

  @ffi.Uint8()
  external int italic;

  @ffi.Uint8()
  external int underline;

  @ffi.Uint8()
  external int theme;

  @ffi.Uint8()
  external int font_strikeout;

  @ffi.Uint8()
  external int font_outline;

  @ffi.Uint8()
  external int font_shadow;

  @ffi.Uint8()
  external int font_script;

  @ffi.Uint8()
  external int font_family;

  @ffi.Uint8()
  external int font_charset;

  @ffi.Uint8()
  external int font_condense;

  @ffi.Uint8()
  external int font_extend;

  @lxw_color_t()
  external int font_color;
}

/// Struct to represent the border component of a format.
class lxw_border extends ffi.Struct {
  @ffi.Uint8()
  external int bottom;

  @ffi.Uint8()
  external int diag_border;

  @ffi.Uint8()
  external int diag_type;

  @ffi.Uint8()
  external int left;

  @ffi.Uint8()
  external int right;

  @ffi.Uint8()
  external int top;

  @lxw_color_t()
  external int bottom_color;

  @lxw_color_t()
  external int diag_color;

  @lxw_color_t()
  external int left_color;

  @lxw_color_t()
  external int right_color;

  @lxw_color_t()
  external int top_color;
}

/// Struct to represent the fill component of a format.
class lxw_fill extends ffi.Struct {
  @lxw_color_t()
  external int fg_color;

  @lxw_color_t()
  external int bg_color;

  @ffi.Uint8()
  external int pattern;
}

class lxw_chart_series_list extends ffi.Struct {
  external ffi.Pointer<lxw_chart_series> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_chart_series>> stqh_last;
}

/// @brief Struct to represent an Excel chart data series.
///
/// The lxw_chart_series is created using the chart_add_series function. It is
/// used in functions that modify a chart series but the members of the struct
/// aren't modified directly.
class lxw_chart_series extends ffi.Struct {
  external ffi.Pointer<lxw_series_range> categories;

  external ffi.Pointer<lxw_series_range> values;

  external lxw_chart_title title;

  external ffi.Pointer<lxw_chart_line> line;

  external ffi.Pointer<lxw_chart_fill> fill;

  external ffi.Pointer<lxw_chart_pattern> pattern;

  external ffi.Pointer<lxw_chart_marker> marker;

  external ffi.Pointer<lxw_chart_point> points;

  external ffi.Pointer<lxw_chart_custom_label> data_labels;

  @ffi.Uint16()
  external int point_count;

  @ffi.Uint16()
  external int data_label_count;

  @ffi.Uint8()
  external int smooth;

  @ffi.Uint8()
  external int invert_if_negative;

  /// Data label parameters.
  @ffi.Uint8()
  external int has_labels;

  @ffi.Uint8()
  external int show_labels_value;

  @ffi.Uint8()
  external int show_labels_category;

  @ffi.Uint8()
  external int show_labels_name;

  @ffi.Uint8()
  external int show_labels_leader;

  @ffi.Uint8()
  external int show_labels_legend;

  @ffi.Uint8()
  external int show_labels_percent;

  @ffi.Uint8()
  external int label_position;

  @ffi.Uint8()
  external int label_separator;

  @ffi.Uint8()
  external int default_label_position;

  external ffi.Pointer<ffi.Char> label_num_format;

  external ffi.Pointer<lxw_chart_font> label_font;

  external ffi.Pointer<lxw_chart_line> label_line;

  external ffi.Pointer<lxw_chart_fill> label_fill;

  external ffi.Pointer<lxw_chart_pattern> label_pattern;

  external ffi.Pointer<lxw_series_error_bars> x_error_bars;

  external ffi.Pointer<lxw_series_error_bars> y_error_bars;

  @ffi.Uint8()
  external int has_trendline;

  @ffi.Uint8()
  external int has_trendline_forecast;

  @ffi.Uint8()
  external int has_trendline_equation;

  @ffi.Uint8()
  external int has_trendline_r_squared;

  @ffi.Uint8()
  external int has_trendline_intercept;

  @ffi.Uint8()
  external int trendline_type;

  @ffi.Uint8()
  external int trendline_value;

  @ffi.Double()
  external double trendline_forward;

  @ffi.Double()
  external double trendline_backward;

  @ffi.Uint8()
  external int trendline_value_type;

  external ffi.Pointer<ffi.Char> trendline_name;

  external ffi.Pointer<lxw_chart_line> trendline_line;

  @ffi.Double()
  external double trendline_intercept;

  external UnnamedStruct9 list_pointers;
}

class lxw_series_range extends ffi.Struct {
  external ffi.Pointer<ffi.Char> formula;

  external ffi.Pointer<ffi.Char> sheetname;

  @lxw_row_t()
  external int first_row;

  @lxw_row_t()
  external int last_row;

  @lxw_col_t()
  external int first_col;

  @lxw_col_t()
  external int last_col;

  @ffi.Uint8()
  external int ignore_cache;

  @ffi.Uint8()
  external int has_string_cache;

  @ffi.Uint16()
  external int num_data_points;

  external ffi.Pointer<lxw_series_data_points> data_cache;
}

/// Integer data type to represent a row value. Equivalent to `uint32_t`.
///
/// The maximum row in Excel is 1,048,576.
typedef lxw_row_t = ffi.Uint32;

/// Integer data type to represent a column value. Equivalent to `uint16_t`.
///
/// The maximum column in Excel is 16,384.
typedef lxw_col_t = ffi.Uint16;

class lxw_series_data_points extends ffi.Struct {
  external ffi.Pointer<lxw_series_data_point> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_series_data_point>> stqh_last;
}

class lxw_series_data_point extends ffi.Struct {
  @ffi.Uint8()
  external int is_string;

  @ffi.Double()
  external double number;

  external ffi.Pointer<ffi.Char> string;

  @ffi.Uint8()
  external int no_data;

  external UnnamedStruct8 list_pointers;
}

class UnnamedStruct8 extends ffi.Struct {
  external ffi.Pointer<lxw_series_data_point> stqe_next;
}

class lxw_chart_title extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @lxw_row_t()
  external int row;

  @lxw_col_t()
  external int col;

  external ffi.Pointer<lxw_chart_font> font;

  @ffi.Uint8()
  external int off;

  @ffi.Uint8()
  external int is_horizontal;

  @ffi.Uint8()
  external int ignore_cache;

  /// We use a range to hold the title formula properties even though it
  /// will only have 1 point in order to re-use similar functions.
  external ffi.Pointer<lxw_series_range> range;

  external lxw_series_data_point data_point;
}

/// @brief Struct to represent a chart font.
///
/// See @ref chart_fonts.
class lxw_chart_font extends ffi.Struct {
  /// The chart font name, such as "Arial" or "Calibri".
  external ffi.Pointer<ffi.Char> name;

  /// The chart font size. The default is 11.
  @ffi.Double()
  external double size;

  /// The chart font bold property. Set to 0 or 1.
  @ffi.Uint8()
  external int bold;

  /// The chart font italic property. Set to 0 or 1.
  @ffi.Uint8()
  external int italic;

  /// The chart font underline property. Set to 0 or 1.
  @ffi.Uint8()
  external int underline;

  /// The chart font rotation property. Range: -90 to 90, and 270, 271 and 360:
  ///
  /// - The angles -90 to 90 are the normal range shown in the Excel user interface.
  /// - The angle 270 gives a stacked (top to bottom) alignment.
  /// - The angle 271 gives a stacked alignment for East Asian fonts.
  /// - The angle 360 gives an explicit angle of 0 to override the y axis default.
  @ffi.Int32()
  external int rotation;

  /// The chart font color. See @ref working_with_colors.
  @lxw_color_t()
  external int color;

  /// The chart font pitch family property. Rarely required, set to 0.
  @ffi.Uint8()
  external int pitch_family;

  /// The chart font character set property. Rarely required, set to 0.
  @ffi.Uint8()
  external int charset;

  /// The chart font baseline property. Rarely required, set to 0.
  @ffi.Int8()
  external int baseline;
}

/// @brief Struct to represent a chart line.
///
/// See @ref chart_lines.
class lxw_chart_line extends ffi.Struct {
  /// The chart font color. See @ref working_with_colors.
  @lxw_color_t()
  external int color;

  /// Turn off/hide line. Set to 0 or 1.
  @ffi.Uint8()
  external int none;

  /// Width of the line in increments of 0.25. Default is 2.25.
  @ffi.Float()
  external double width;

  /// The line dash type. See #lxw_chart_line_dash_type.
  @ffi.Uint8()
  external int dash_type;

  /// Set the transparency of the line. 0 - 100. Default 0.
  @ffi.Uint8()
  external int transparency;
}

/// @brief Struct to represent a chart fill.
///
/// See @ref chart_fills.
class lxw_chart_fill extends ffi.Struct {
  /// The chart font color. See @ref working_with_colors.
  @lxw_color_t()
  external int color;

  /// Turn off/hide line. Set to 0 or 1.
  @ffi.Uint8()
  external int none;

  /// Set the transparency of the fill. 0 - 100. Default 0.
  @ffi.Uint8()
  external int transparency;
}

/// @brief Struct to represent a chart pattern.
///
/// See @ref chart_patterns.
class lxw_chart_pattern extends ffi.Struct {
  /// The pattern foreground color. See @ref working_with_colors.
  @lxw_color_t()
  external int fg_color;

  /// The pattern background color. See @ref working_with_colors.
  @lxw_color_t()
  external int bg_color;

  /// The pattern type. See #lxw_chart_pattern_type.
  @ffi.Uint8()
  external int type;
}

class lxw_chart_marker extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int size;

  external ffi.Pointer<lxw_chart_line> line;

  external ffi.Pointer<lxw_chart_fill> fill;

  external ffi.Pointer<lxw_chart_pattern> pattern;
}

/// @brief Struct to represent an Excel chart data point.
///
/// The lxw_chart_point used to set the line, fill and pattern of one or more
/// points in a chart data series. See @ref chart_points.
class lxw_chart_point extends ffi.Struct {
  /// The line/border for the chart point. See @ref chart_lines.
  external ffi.Pointer<lxw_chart_line> line;

  /// The fill for the chart point. See @ref chart_fills.
  external ffi.Pointer<lxw_chart_fill> fill;

  /// The pattern for the chart point. See @ref chart_patterns.
  external ffi.Pointer<lxw_chart_pattern> pattern;
}

/// Internal version of lxw_chart_data_label with more metadata.
class lxw_chart_custom_label extends ffi.Struct {
  external ffi.Pointer<ffi.Char> value;

  @ffi.Uint8()
  external int hide1;

  external ffi.Pointer<lxw_chart_font> font;

  external ffi.Pointer<lxw_chart_line> line;

  external ffi.Pointer<lxw_chart_fill> fill;

  external ffi.Pointer<lxw_chart_pattern> pattern;

  /// We use a range to hold the label formula properties even though it
  /// will only have 1 point in order to re-use similar functions.
  external ffi.Pointer<lxw_series_range> range;

  external lxw_series_data_point data_point;
}

class lxw_series_error_bars extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int direction;

  @ffi.Uint8()
  external int endcap;

  @ffi.Uint8()
  external int has_value;

  @ffi.Uint8()
  external int is_set;

  @ffi.Uint8()
  external int is_x;

  @ffi.Uint8()
  external int chart_group;

  @ffi.Double()
  external double value;

  external ffi.Pointer<lxw_chart_line> line;
}

class UnnamedStruct9 extends ffi.Struct {
  external ffi.Pointer<lxw_chart_series> stqe_next;
}

/// @brief Available chart types.
abstract class lxw_chart_type {
  /// None.
  static const int LXW_CHART_NONE = 0;

  /// Area chart.
  static const int LXW_CHART_AREA = 1;

  /// Area chart - stacked.
  static const int LXW_CHART_AREA_STACKED = 2;

  /// Area chart - percentage stacked.
  static const int LXW_CHART_AREA_STACKED_PERCENT = 3;

  /// Bar chart.
  static const int LXW_CHART_BAR = 4;

  /// Bar chart - stacked.
  static const int LXW_CHART_BAR_STACKED = 5;

  /// Bar chart - percentage stacked.
  static const int LXW_CHART_BAR_STACKED_PERCENT = 6;

  /// Column chart.
  static const int LXW_CHART_COLUMN = 7;

  /// Column chart - stacked.
  static const int LXW_CHART_COLUMN_STACKED = 8;

  /// Column chart - percentage stacked.
  static const int LXW_CHART_COLUMN_STACKED_PERCENT = 9;

  /// Doughnut chart.
  static const int LXW_CHART_DOUGHNUT = 10;

  /// Line chart.
  static const int LXW_CHART_LINE = 11;

  /// Line chart - stacked.
  static const int LXW_CHART_LINE_STACKED = 12;

  /// Line chart - percentage stacked.
  static const int LXW_CHART_LINE_STACKED_PERCENT = 13;

  /// Pie chart.
  static const int LXW_CHART_PIE = 14;

  /// Scatter chart.
  static const int LXW_CHART_SCATTER = 15;

  /// Scatter chart - straight.
  static const int LXW_CHART_SCATTER_STRAIGHT = 16;

  /// Scatter chart - straight with markers.
  static const int LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS = 17;

  /// Scatter chart - smooth.
  static const int LXW_CHART_SCATTER_SMOOTH = 18;

  /// Scatter chart - smooth with markers.
  static const int LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS = 19;

  /// Radar chart.
  static const int LXW_CHART_RADAR = 20;

  /// Radar chart - with markers.
  static const int LXW_CHART_RADAR_WITH_MARKERS = 21;

  /// Radar chart - filled.
  static const int LXW_CHART_RADAR_FILLED = 22;
}

/// @brief Chart legend positions.
abstract class lxw_chart_legend_position {
  /// No chart legend.
  static const int LXW_CHART_LEGEND_NONE = 0;

  /// Chart legend positioned at right side.
  static const int LXW_CHART_LEGEND_RIGHT = 1;

  /// Chart legend positioned at left side.
  static const int LXW_CHART_LEGEND_LEFT = 2;

  /// Chart legend positioned at top.
  static const int LXW_CHART_LEGEND_TOP = 3;

  /// Chart legend positioned at bottom.
  static const int LXW_CHART_LEGEND_BOTTOM = 4;

  /// Chart legend positioned at top right.
  static const int LXW_CHART_LEGEND_TOP_RIGHT = 5;

  /// Chart legend overlaid at right side.
  static const int LXW_CHART_LEGEND_OVERLAY_RIGHT = 6;

  /// Chart legend overlaid at left side.
  static const int LXW_CHART_LEGEND_OVERLAY_LEFT = 7;

  /// Chart legend overlaid at top right.
  static const int LXW_CHART_LEGEND_OVERLAY_TOP_RIGHT = 8;
}

/// @brief Chart line dash types.
///
/// The dash types are shown in the order that they appear in the Excel dialog.
/// See @ref chart_lines.
abstract class lxw_chart_line_dash_type {
  /// Solid.
  static const int LXW_CHART_LINE_DASH_SOLID = 0;

  /// Round Dot.
  static const int LXW_CHART_LINE_DASH_ROUND_DOT = 1;

  /// Square Dot.
  static const int LXW_CHART_LINE_DASH_SQUARE_DOT = 2;

  /// Dash.
  static const int LXW_CHART_LINE_DASH_DASH = 3;

  /// Dash Dot.
  static const int LXW_CHART_LINE_DASH_DASH_DOT = 4;

  /// Long Dash.
  static const int LXW_CHART_LINE_DASH_LONG_DASH = 5;

  /// Long Dash Dot.
  static const int LXW_CHART_LINE_DASH_LONG_DASH_DOT = 6;

  /// Long Dash Dot Dot.
  static const int LXW_CHART_LINE_DASH_LONG_DASH_DOT_DOT = 7;

  /// These aren't available in the dialog but are used by Excel.
  static const int LXW_CHART_LINE_DASH_DOT = 8;
  static const int LXW_CHART_LINE_DASH_SYSTEM_DASH_DOT = 9;
  static const int LXW_CHART_LINE_DASH_SYSTEM_DASH_DOT_DOT = 10;
}

/// @brief Chart marker types.
abstract class lxw_chart_marker_type {
  /// Automatic, series default, marker type.
  static const int LXW_CHART_MARKER_AUTOMATIC = 0;

  /// No marker type.
  static const int LXW_CHART_MARKER_NONE = 1;

  /// Square marker type.
  static const int LXW_CHART_MARKER_SQUARE = 2;

  /// Diamond marker type.
  static const int LXW_CHART_MARKER_DIAMOND = 3;

  /// Triangle marker type.
  static const int LXW_CHART_MARKER_TRIANGLE = 4;

  /// X shape marker type.
  static const int LXW_CHART_MARKER_X = 5;

  /// Star marker type.
  static const int LXW_CHART_MARKER_STAR = 6;

  /// Short dash marker type.
  static const int LXW_CHART_MARKER_SHORT_DASH = 7;

  /// Long dash marker type.
  static const int LXW_CHART_MARKER_LONG_DASH = 8;

  /// Circle marker type.
  static const int LXW_CHART_MARKER_CIRCLE = 9;

  /// Plus (+) marker type.
  static const int LXW_CHART_MARKER_PLUS = 10;
}

/// @brief Chart pattern types.
abstract class lxw_chart_pattern_type {
  /// None pattern.
  static const int LXW_CHART_PATTERN_NONE = 0;

  /// 5 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_5 = 1;

  /// 10 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_10 = 2;

  /// 20 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_20 = 3;

  /// 25 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_25 = 4;

  /// 30 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_30 = 5;

  /// 40 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_40 = 6;

  /// 50 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_50 = 7;

  /// 60 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_60 = 8;

  /// 70 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_70 = 9;

  /// 75 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_75 = 10;

  /// 80 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_80 = 11;

  /// 90 Percent pattern.
  static const int LXW_CHART_PATTERN_PERCENT_90 = 12;

  /// Light downward diagonal pattern.
  static const int LXW_CHART_PATTERN_LIGHT_DOWNWARD_DIAGONAL = 13;

  /// Light upward diagonal pattern.
  static const int LXW_CHART_PATTERN_LIGHT_UPWARD_DIAGONAL = 14;

  /// Dark downward diagonal pattern.
  static const int LXW_CHART_PATTERN_DARK_DOWNWARD_DIAGONAL = 15;

  /// Dark upward diagonal pattern.
  static const int LXW_CHART_PATTERN_DARK_UPWARD_DIAGONAL = 16;

  /// Wide downward diagonal pattern.
  static const int LXW_CHART_PATTERN_WIDE_DOWNWARD_DIAGONAL = 17;

  /// Wide upward diagonal pattern.
  static const int LXW_CHART_PATTERN_WIDE_UPWARD_DIAGONAL = 18;

  /// Light vertical pattern.
  static const int LXW_CHART_PATTERN_LIGHT_VERTICAL = 19;

  /// Light horizontal pattern.
  static const int LXW_CHART_PATTERN_LIGHT_HORIZONTAL = 20;

  /// Narrow vertical pattern.
  static const int LXW_CHART_PATTERN_NARROW_VERTICAL = 21;

  /// Narrow horizontal pattern.
  static const int LXW_CHART_PATTERN_NARROW_HORIZONTAL = 22;

  /// Dark vertical pattern.
  static const int LXW_CHART_PATTERN_DARK_VERTICAL = 23;

  /// Dark horizontal pattern.
  static const int LXW_CHART_PATTERN_DARK_HORIZONTAL = 24;

  /// Dashed downward diagonal pattern.
  static const int LXW_CHART_PATTERN_DASHED_DOWNWARD_DIAGONAL = 25;

  /// Dashed upward diagonal pattern.
  static const int LXW_CHART_PATTERN_DASHED_UPWARD_DIAGONAL = 26;

  /// Dashed horizontal pattern.
  static const int LXW_CHART_PATTERN_DASHED_HORIZONTAL = 27;

  /// Dashed vertical pattern.
  static const int LXW_CHART_PATTERN_DASHED_VERTICAL = 28;

  /// Small confetti pattern.
  static const int LXW_CHART_PATTERN_SMALL_CONFETTI = 29;

  /// Large confetti pattern.
  static const int LXW_CHART_PATTERN_LARGE_CONFETTI = 30;

  /// Zigzag pattern.
  static const int LXW_CHART_PATTERN_ZIGZAG = 31;

  /// Wave pattern.
  static const int LXW_CHART_PATTERN_WAVE = 32;

  /// Diagonal brick pattern.
  static const int LXW_CHART_PATTERN_DIAGONAL_BRICK = 33;

  /// Horizontal brick pattern.
  static const int LXW_CHART_PATTERN_HORIZONTAL_BRICK = 34;

  /// Weave pattern.
  static const int LXW_CHART_PATTERN_WEAVE = 35;

  /// Plaid pattern.
  static const int LXW_CHART_PATTERN_PLAID = 36;

  /// Divot pattern.
  static const int LXW_CHART_PATTERN_DIVOT = 37;

  /// Dotted grid pattern.
  static const int LXW_CHART_PATTERN_DOTTED_GRID = 38;

  /// Dotted diamond pattern.
  static const int LXW_CHART_PATTERN_DOTTED_DIAMOND = 39;

  /// Shingle pattern.
  static const int LXW_CHART_PATTERN_SHINGLE = 40;

  /// Trellis pattern.
  static const int LXW_CHART_PATTERN_TRELLIS = 41;

  /// Sphere pattern.
  static const int LXW_CHART_PATTERN_SPHERE = 42;

  /// Small grid pattern.
  static const int LXW_CHART_PATTERN_SMALL_GRID = 43;

  /// Large grid pattern.
  static const int LXW_CHART_PATTERN_LARGE_GRID = 44;

  /// Small check pattern.
  static const int LXW_CHART_PATTERN_SMALL_CHECK = 45;

  /// Large check pattern.
  static const int LXW_CHART_PATTERN_LARGE_CHECK = 46;

  /// Outlined diamond pattern.
  static const int LXW_CHART_PATTERN_OUTLINED_DIAMOND = 47;

  /// Solid diamond pattern.
  static const int LXW_CHART_PATTERN_SOLID_DIAMOND = 48;
}

/// @brief Chart data label positions.
abstract class lxw_chart_label_position {
  /// Series data label position: default position.
  static const int LXW_CHART_LABEL_POSITION_DEFAULT = 0;

  /// Series data label position: center.
  static const int LXW_CHART_LABEL_POSITION_CENTER = 1;

  /// Series data label position: right.
  static const int LXW_CHART_LABEL_POSITION_RIGHT = 2;

  /// Series data label position: left.
  static const int LXW_CHART_LABEL_POSITION_LEFT = 3;

  /// Series data label position: above.
  static const int LXW_CHART_LABEL_POSITION_ABOVE = 4;

  /// Series data label position: below.
  static const int LXW_CHART_LABEL_POSITION_BELOW = 5;

  /// Series data label position: inside base.
  static const int LXW_CHART_LABEL_POSITION_INSIDE_BASE = 6;

  /// Series data label position: inside end.
  static const int LXW_CHART_LABEL_POSITION_INSIDE_END = 7;

  /// Series data label position: outside end.
  static const int LXW_CHART_LABEL_POSITION_OUTSIDE_END = 8;

  /// Series data label position: best fit.
  static const int LXW_CHART_LABEL_POSITION_BEST_FIT = 9;
}

/// @brief Chart data label separator.
abstract class lxw_chart_label_separator {
  /// Series data label separator: comma (the default).
  static const int LXW_CHART_LABEL_SEPARATOR_COMMA = 0;

  /// Series data label separator: semicolon.
  static const int LXW_CHART_LABEL_SEPARATOR_SEMICOLON = 1;

  /// Series data label separator: period.
  static const int LXW_CHART_LABEL_SEPARATOR_PERIOD = 2;

  /// Series data label separator: newline.
  static const int LXW_CHART_LABEL_SEPARATOR_NEWLINE = 3;

  /// Series data label separator: space.
  static const int LXW_CHART_LABEL_SEPARATOR_SPACE = 4;
}

/// @brief Chart axis types.
abstract class lxw_chart_axis_type {
  /// Chart X axis.
  static const int LXW_CHART_AXIS_TYPE_X = 0;

  /// Chart Y axis.
  static const int LXW_CHART_AXIS_TYPE_Y = 1;
}

abstract class lxw_chart_subtype {
  static const int LXW_CHART_SUBTYPE_NONE = 0;
  static const int LXW_CHART_SUBTYPE_STACKED = 1;
  static const int LXW_CHART_SUBTYPE_STACKED_PERCENT = 2;
}

abstract class lxw_chart_grouping {
  static const int LXW_GROUPING_CLUSTERED = 0;
  static const int LXW_GROUPING_STANDARD = 1;
  static const int LXW_GROUPING_PERCENTSTACKED = 2;
  static const int LXW_GROUPING_STACKED = 3;
}

/// @brief Axis positions for category axes.
abstract class lxw_chart_axis_tick_position {
  static const int LXW_CHART_AXIS_POSITION_DEFAULT = 0;

  /// Position category axis on tick marks.
  static const int LXW_CHART_AXIS_POSITION_ON_TICK = 1;

  /// Position category axis between tick marks.
  static const int LXW_CHART_AXIS_POSITION_BETWEEN = 2;
}

/// @brief Axis label positions.
abstract class lxw_chart_axis_label_position {
  /// Position the axis labels next to the axis. The default.
  static const int LXW_CHART_AXIS_LABEL_POSITION_NEXT_TO = 0;

  /// Position the axis labels at the top of the chart, for horizontal
  /// axes, or to the right for vertical axes.
  static const int LXW_CHART_AXIS_LABEL_POSITION_HIGH = 1;

  /// Position the axis labels at the bottom of the chart, for horizontal
  /// axes, or to the left for vertical axes.
  static const int LXW_CHART_AXIS_LABEL_POSITION_LOW = 2;

  /// Turn off the the axis labels.
  static const int LXW_CHART_AXIS_LABEL_POSITION_NONE = 3;
}

/// @brief Axis label alignments.
abstract class lxw_chart_axis_label_alignment {
  /// Chart axis label alignment: center.
  static const int LXW_CHART_AXIS_LABEL_ALIGN_CENTER = 0;

  /// Chart axis label alignment: left.
  static const int LXW_CHART_AXIS_LABEL_ALIGN_LEFT = 1;

  /// Chart axis label alignment: right.
  static const int LXW_CHART_AXIS_LABEL_ALIGN_RIGHT = 2;
}

/// @brief Display units for chart value axis.
abstract class lxw_chart_axis_display_unit {
  /// Axis display units: None. The default.
  static const int LXW_CHART_AXIS_UNITS_NONE = 0;

  /// Axis display units: Hundreds.
  static const int LXW_CHART_AXIS_UNITS_HUNDREDS = 1;

  /// Axis display units: Thousands.
  static const int LXW_CHART_AXIS_UNITS_THOUSANDS = 2;

  /// Axis display units: Ten thousands.
  static const int LXW_CHART_AXIS_UNITS_TEN_THOUSANDS = 3;

  /// Axis display units: Hundred thousands.
  static const int LXW_CHART_AXIS_UNITS_HUNDRED_THOUSANDS = 4;

  /// Axis display units: Millions.
  static const int LXW_CHART_AXIS_UNITS_MILLIONS = 5;

  /// Axis display units: Ten millions.
  static const int LXW_CHART_AXIS_UNITS_TEN_MILLIONS = 6;

  /// Axis display units: Hundred millions.
  static const int LXW_CHART_AXIS_UNITS_HUNDRED_MILLIONS = 7;

  /// Axis display units: Billions.
  static const int LXW_CHART_AXIS_UNITS_BILLIONS = 8;

  /// Axis display units: Trillions.
  static const int LXW_CHART_AXIS_UNITS_TRILLIONS = 9;
}

/// @brief Tick mark types for an axis.
abstract class lxw_chart_axis_tick_mark {
  /// Default tick mark for the chart axis. Usually outside.
  static const int LXW_CHART_AXIS_TICK_MARK_DEFAULT = 0;

  /// No tick mark for the axis.
  static const int LXW_CHART_AXIS_TICK_MARK_NONE = 1;

  /// Tick mark inside the axis only.
  static const int LXW_CHART_AXIS_TICK_MARK_INSIDE = 2;

  /// Tick mark outside the axis only.
  static const int LXW_CHART_AXIS_TICK_MARK_OUTSIDE = 3;

  /// Tick mark inside and outside the axis.
  static const int LXW_CHART_AXIS_TICK_MARK_CROSSING = 4;
}

class lxw_chart_legend extends ffi.Struct {
  external ffi.Pointer<lxw_chart_font> font;

  @ffi.Uint8()
  external int position;
}

/// @brief Struct to represent an Excel chart data label.
///
/// The lxw_chart_data_label struct is used to represent a data label in a
/// chart series so that custom properties can be set for it.
class lxw_chart_data_label extends ffi.Struct {
  /// The string or formula value for the data label. See
  /// @ref chart_custom_labels.
  external ffi.Pointer<ffi.Char> value;

  /// Option to hide/delete the data label from the chart series.
  /// See @ref chart_custom_labels.
  @ffi.Uint8()
  external int hide1;

  /// The font properties for the chart data label. @ref chart_fonts.
  external ffi.Pointer<lxw_chart_font> font;

  /// The line/border for the chart data label. See @ref chart_lines.
  external ffi.Pointer<lxw_chart_line> line;

  /// The fill for the chart data label. See @ref chart_fills.
  external ffi.Pointer<lxw_chart_fill> fill;

  /// The pattern for the chart data label. See @ref chart_patterns.
  external ffi.Pointer<lxw_chart_pattern> pattern;
}

/// @brief Define how blank values are displayed in a chart.
abstract class lxw_chart_blank {
  /// Show empty chart cells as gaps in the data. The default.
  static const int LXW_CHART_BLANKS_AS_GAP = 0;

  /// Show empty chart cells as zeros.
  static const int LXW_CHART_BLANKS_AS_ZERO = 1;

  /// Show empty chart cells as connected. Only for charts with lines.
  static const int LXW_CHART_BLANKS_AS_CONNECTED = 2;
}

abstract class lxw_chart_position {
  static const int LXW_CHART_AXIS_RIGHT = 0;
  static const int LXW_CHART_AXIS_LEFT = 1;
  static const int LXW_CHART_AXIS_TOP = 2;
  static const int LXW_CHART_AXIS_BOTTOM = 3;
}

/// @brief Type/amount of data series error bar.
abstract class lxw_chart_error_bar_type {
  /// Error bar type: Standard error.
  static const int LXW_CHART_ERROR_BAR_TYPE_STD_ERROR = 0;

  /// Error bar type: Fixed value.
  static const int LXW_CHART_ERROR_BAR_TYPE_FIXED = 1;

  /// Error bar type: Percentage.
  static const int LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE = 2;

  /// Error bar type: Standard deviation(s).
  static const int LXW_CHART_ERROR_BAR_TYPE_STD_DEV = 3;
}

/// @brief Direction for a data series error bar.
abstract class lxw_chart_error_bar_direction {
  /// Error bar extends in both directions. The default.
  static const int LXW_CHART_ERROR_BAR_DIR_BOTH = 0;

  /// Error bar extends in positive direction.
  static const int LXW_CHART_ERROR_BAR_DIR_PLUS = 1;

  /// Error bar extends in negative direction.
  static const int LXW_CHART_ERROR_BAR_DIR_MINUS = 2;
}

/// @brief Direction for a data series error bar.
abstract class lxw_chart_error_bar_axis {
  /// X axis error bar.
  static const int LXW_CHART_ERROR_BAR_AXIS_X = 0;

  /// Y axis error bar.
  static const int LXW_CHART_ERROR_BAR_AXIS_Y = 1;
}

/// @brief End cap styles for a data series error bar.
abstract class lxw_chart_error_bar_cap {
  /// Flat end cap. The default.
  static const int LXW_CHART_ERROR_BAR_END_CAP = 0;

  /// No end cap.
  static const int LXW_CHART_ERROR_BAR_NO_CAP = 1;
}

/// @brief Series trendline/regression types.
abstract class lxw_chart_trendline_type {
  /// Trendline type: Linear.
  static const int LXW_CHART_TRENDLINE_TYPE_LINEAR = 0;

  /// Trendline type: Logarithm.
  static const int LXW_CHART_TRENDLINE_TYPE_LOG = 1;

  /// Trendline type: Polynomial.
  static const int LXW_CHART_TRENDLINE_TYPE_POLY = 2;

  /// Trendline type: Power.
  static const int LXW_CHART_TRENDLINE_TYPE_POWER = 3;

  /// Trendline type: Exponential.
  static const int LXW_CHART_TRENDLINE_TYPE_EXP = 4;

  /// Trendline type: Moving Average.
  static const int LXW_CHART_TRENDLINE_TYPE_AVERAGE = 5;
}

/// Struct for major/minor axis gridlines.
class lxw_chart_gridline extends ffi.Struct {
  @ffi.Uint8()
  external int visible;

  external ffi.Pointer<lxw_chart_line> line;
}

/// @brief Struct to represent an Excel chart axis.
///
/// The lxw_chart_axis struct is used in functions that modify a chart axis
/// but the members of the struct aren't modified directly.
class lxw_chart_axis extends ffi.Struct {
  external lxw_chart_title title;

  external ffi.Pointer<ffi.Char> num_format;

  external ffi.Pointer<ffi.Char> default_num_format;

  @ffi.Uint8()
  external int source_linked;

  @ffi.Uint8()
  external int major_tick_mark;

  @ffi.Uint8()
  external int minor_tick_mark;

  @ffi.Uint8()
  external int is_horizontal;

  external lxw_chart_gridline major_gridlines;

  external lxw_chart_gridline minor_gridlines;

  external ffi.Pointer<lxw_chart_font> num_font;

  external ffi.Pointer<lxw_chart_line> line;

  external ffi.Pointer<lxw_chart_fill> fill;

  external ffi.Pointer<lxw_chart_pattern> pattern;

  @ffi.Uint8()
  external int is_category;

  @ffi.Uint8()
  external int is_date;

  @ffi.Uint8()
  external int is_value;

  @ffi.Uint8()
  external int axis_position;

  @ffi.Uint8()
  external int position_axis;

  @ffi.Uint8()
  external int label_position;

  @ffi.Uint8()
  external int label_align;

  @ffi.Uint8()
  external int hidden;

  @ffi.Uint8()
  external int reverse;

  @ffi.Uint8()
  external int has_min;

  @ffi.Double()
  external double min;

  @ffi.Uint8()
  external int has_max;

  @ffi.Double()
  external double max;

  @ffi.Uint8()
  external int has_major_unit;

  @ffi.Double()
  external double major_unit;

  @ffi.Uint8()
  external int has_minor_unit;

  @ffi.Double()
  external double minor_unit;

  @ffi.Uint16()
  external int interval_unit;

  @ffi.Uint16()
  external int interval_tick;

  @ffi.Uint16()
  external int log_base;

  @ffi.Uint8()
  external int display_units;

  @ffi.Uint8()
  external int display_units_visible;

  @ffi.Uint8()
  external int has_crossing;

  @ffi.Uint8()
  external int crossing_min;

  @ffi.Uint8()
  external int crossing_max;

  @ffi.Double()
  external double crossing;
}

/// @brief Struct to represent an Excel chart.
///
/// The members of the lxw_chart struct aren't modified directly. Instead
/// the chart properties are set by calling the functions shown in chart.h.
class lxw_chart extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int subtype;

  @ffi.Uint16()
  external int series_index;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>
      write_chart_type;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lxw_chart>)>>
      write_plot_area;

  /// A pointer to the chart x_axis object which can be used in functions
  /// that configures the X axis.
  external ffi.Pointer<lxw_chart_axis> x_axis;

  /// A pointer to the chart y_axis object which can be used in functions
  /// that configures the Y axis.
  external ffi.Pointer<lxw_chart_axis> y_axis;

  external lxw_chart_title title;

  @ffi.Uint32()
  external int id;

  @ffi.Uint32()
  external int axis_id_1;

  @ffi.Uint32()
  external int axis_id_2;

  @ffi.Uint32()
  external int axis_id_3;

  @ffi.Uint32()
  external int axis_id_4;

  @ffi.Uint8()
  external int in_use;

  @ffi.Uint8()
  external int chart_group;

  @ffi.Uint8()
  external int cat_has_num_fmt;

  @ffi.Uint8()
  external int is_chartsheet;

  @ffi.Uint8()
  external int has_horiz_cat_axis;

  @ffi.Uint8()
  external int has_horiz_val_axis;

  @ffi.Uint8()
  external int style_id;

  @ffi.Uint16()
  external int rotation;

  @ffi.Uint16()
  external int hole_size;

  @ffi.Uint8()
  external int no_title;

  @ffi.Uint8()
  external int has_overlap;

  @ffi.Int8()
  external int overlap_y1;

  @ffi.Int8()
  external int overlap_y2;

  @ffi.Uint16()
  external int gap_y1;

  @ffi.Uint16()
  external int gap_y2;

  @ffi.Uint8()
  external int grouping;

  @ffi.Uint8()
  external int default_cross_between;

  external lxw_chart_legend legend;

  external ffi.Pointer<ffi.Int16> delete_series;

  @ffi.Uint16()
  external int delete_series_count;

  external ffi.Pointer<lxw_chart_marker> default_marker;

  external ffi.Pointer<lxw_chart_line> chartarea_line;

  external ffi.Pointer<lxw_chart_fill> chartarea_fill;

  external ffi.Pointer<lxw_chart_pattern> chartarea_pattern;

  external ffi.Pointer<lxw_chart_line> plotarea_line;

  external ffi.Pointer<lxw_chart_fill> plotarea_fill;

  external ffi.Pointer<lxw_chart_pattern> plotarea_pattern;

  @ffi.Uint8()
  external int has_drop_lines;

  external ffi.Pointer<lxw_chart_line> drop_lines_line;

  @ffi.Uint8()
  external int has_high_low_lines;

  external ffi.Pointer<lxw_chart_line> high_low_lines_line;

  external ffi.Pointer<lxw_chart_series_list> series_list;

  @ffi.Uint8()
  external int has_table;

  @ffi.Uint8()
  external int has_table_vertical;

  @ffi.Uint8()
  external int has_table_horizontal;

  @ffi.Uint8()
  external int has_table_outline;

  @ffi.Uint8()
  external int has_table_legend_keys;

  external ffi.Pointer<lxw_chart_font> table_font;

  @ffi.Uint8()
  external int show_blanks_as;

  @ffi.Uint8()
  external int show_hidden_data;

  @ffi.Uint8()
  external int has_up_down_bars;

  external ffi.Pointer<lxw_chart_line> up_bar_line;

  external ffi.Pointer<lxw_chart_line> down_bar_line;

  external ffi.Pointer<lxw_chart_fill> up_bar_fill;

  external ffi.Pointer<lxw_chart_fill> down_bar_fill;

  @ffi.Uint8()
  external int default_label_position;

  @ffi.Uint8()
  external int is_protected;

  external UnnamedStruct10 ordered_list_pointers;

  external UnnamedStruct11 list_pointers;
}

class UnnamedStruct10 extends ffi.Struct {
  external ffi.Pointer<lxw_chart> stqe_next;
}

class UnnamedStruct11 extends ffi.Struct {
  external ffi.Pointer<lxw_chart> stqe_next;
}

class lxw_drawing_objects extends ffi.Struct {
  external ffi.Pointer<lxw_drawing_object> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_drawing_object>> stqh_last;
}

/// Object to represent the properties of a drawing.
class lxw_drawing_object extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int anchor;

  external lxw_drawing_coords from;

  external lxw_drawing_coords to;

  @ffi.Uint32()
  external int col_absolute;

  @ffi.Uint32()
  external int row_absolute;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;

  @ffi.Uint8()
  external int shape;

  @ffi.Uint32()
  external int rel_index;

  @ffi.Uint32()
  external int url_rel_index;

  external ffi.Pointer<ffi.Char> description;

  external ffi.Pointer<ffi.Char> tip;

  @ffi.Uint8()
  external int decorative;

  external UnnamedStruct12 list_pointers;
}

/// Coordinates used in a drawing object.
class lxw_drawing_coords extends ffi.Struct {
  @ffi.Uint32()
  external int col;

  @ffi.Uint32()
  external int row;

  @ffi.Double()
  external double col_offset;

  @ffi.Double()
  external double row_offset;
}

class UnnamedStruct12 extends ffi.Struct {
  external ffi.Pointer<lxw_drawing_object> stqe_next;
}

abstract class lxw_drawing_types {
  static const int LXW_DRAWING_NONE = 0;
  static const int LXW_DRAWING_IMAGE = 1;
  static const int LXW_DRAWING_CHART = 2;
  static const int LXW_DRAWING_SHAPE = 3;
}

abstract class image_types {
  static const int LXW_IMAGE_UNKNOWN = 0;
  static const int LXW_IMAGE_PNG = 1;
  static const int LXW_IMAGE_JPEG = 2;
  static const int LXW_IMAGE_BMP = 3;
  static const int LXW_IMAGE_GIF = 4;
}

/// Struct to represent a collection of drawings.
class lxw_drawing extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  @ffi.Uint8()
  external int embedded;

  @ffi.Uint8()
  external int orientation;

  external ffi.Pointer<lxw_drawing_objects> drawing_objects;
}

/// Struct to represent a styles.
class lxw_styles extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  @ffi.Uint32()
  external int font_count;

  @ffi.Uint32()
  external int xf_count;

  @ffi.Uint32()
  external int dxf_count;

  @ffi.Uint32()
  external int num_format_count;

  @ffi.Uint32()
  external int border_count;

  @ffi.Uint32()
  external int fill_count;

  external ffi.Pointer<lxw_formats> xf_formats;

  external ffi.Pointer<lxw_formats> dxf_formats;

  @ffi.Uint8()
  external int has_hyperlink;

  @ffi.Uint16()
  external int hyperlink_font_id;

  @ffi.Uint8()
  external int has_comments;
}

/// Attribute used in XML elements.
class xml_attribute extends ffi.Struct {
  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> key;

  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> value;

  /// Make the struct a queue.h list element.
  external UnnamedStruct13 list_entries;
}

class UnnamedStruct13 extends ffi.Struct {
  external ffi.Pointer<xml_attribute> stqe_next;
}

/// Use queue.h macros to define the xml_attribute_list type.
class xml_attribute_list extends ffi.Struct {
  external ffi.Pointer<xml_attribute> stqh_first;

  external ffi.Pointer<ffi.Pointer<xml_attribute>> stqh_last;
}

/// Define the queue.h STAILQ structs for the generic data structs.
class lxw_rel_tuples extends ffi.Struct {
  external ffi.Pointer<lxw_rel_tuple> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_rel_tuple>> stqh_last;
}

class lxw_rel_tuple extends ffi.Struct {
  external ffi.Pointer<ffi.Char> type;

  external ffi.Pointer<ffi.Char> target;

  external ffi.Pointer<ffi.Char> target_mode;

  external UnnamedStruct14 list_pointers;
}

class UnnamedStruct14 extends ffi.Struct {
  external ffi.Pointer<lxw_rel_tuple> stqe_next;
}

/// Struct to represent a relationships.
class lxw_relationships extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  @ffi.Uint32()
  external int rel_id;

  external ffi.Pointer<lxw_rel_tuples> relationships;
}

/// Gridline options using in `worksheet_gridlines()`.
abstract class lxw_gridlines {
  /// Hide screen and print gridlines.
  static const int LXW_HIDE_ALL_GRIDLINES = 0;

  /// Show screen gridlines.
  static const int LXW_SHOW_SCREEN_GRIDLINES = 1;

  /// Show print gridlines.
  static const int LXW_SHOW_PRINT_GRIDLINES = 2;

  /// Show screen and print gridlines.
  static const int LXW_SHOW_ALL_GRIDLINES = 3;
}

/// Data validation property values.
abstract class lxw_validation_boolean {
  static const int LXW_VALIDATION_DEFAULT = 0;

  /// Turn a data validation property off.
  static const int LXW_VALIDATION_OFF = 1;

  /// Turn a data validation property on. Data validation properties are
  /// generally on by default.
  static const int LXW_VALIDATION_ON = 2;
}

/// Data validation types.
abstract class lxw_validation_types {
  static const int LXW_VALIDATION_TYPE_NONE = 0;

  /// Restrict cell input to whole/integer numbers only.
  static const int LXW_VALIDATION_TYPE_INTEGER = 1;

  /// Restrict cell input to whole/integer numbers only, using a cell
  /// reference.
  static const int LXW_VALIDATION_TYPE_INTEGER_FORMULA = 2;

  /// Restrict cell input to decimal numbers only.
  static const int LXW_VALIDATION_TYPE_DECIMAL = 3;

  /// Restrict cell input to decimal numbers only, using a cell
  /// reference.
  static const int LXW_VALIDATION_TYPE_DECIMAL_FORMULA = 4;

  /// Restrict cell input to a list of strings in a dropdown.
  static const int LXW_VALIDATION_TYPE_LIST = 5;

  /// Restrict cell input to a list of strings in a dropdown, using a
  /// cell range.
  static const int LXW_VALIDATION_TYPE_LIST_FORMULA = 6;

  /// Restrict cell input to date values only, using a lxw_datetime type.
  static const int LXW_VALIDATION_TYPE_DATE = 7;

  /// Restrict cell input to date values only, using a cell reference.
  static const int LXW_VALIDATION_TYPE_DATE_FORMULA = 8;

  /// Restrict cell input to date values only, as a serial number.
  /// Undocumented.
  static const int LXW_VALIDATION_TYPE_DATE_NUMBER = 9;

  /// Restrict cell input to time values only, using a lxw_datetime type.
  static const int LXW_VALIDATION_TYPE_TIME = 10;

  /// Restrict cell input to time values only, using a cell reference.
  static const int LXW_VALIDATION_TYPE_TIME_FORMULA = 11;

  /// Restrict cell input to time values only, as a serial number.
  /// Undocumented.
  static const int LXW_VALIDATION_TYPE_TIME_NUMBER = 12;

  /// Restrict cell input to strings of defined length, using a cell
  /// reference.
  static const int LXW_VALIDATION_TYPE_LENGTH = 13;

  /// Restrict cell input to strings of defined length, using a cell
  /// reference.
  static const int LXW_VALIDATION_TYPE_LENGTH_FORMULA = 14;

  /// Restrict cell to input controlled by a custom formula that returns
  /// `TRUE/FALSE`.
  static const int LXW_VALIDATION_TYPE_CUSTOM_FORMULA = 15;

  /// Allow any type of input. Mainly only useful for pop-up messages.
  static const int LXW_VALIDATION_TYPE_ANY = 16;
}

/// Data validation criteria uses to control the selection of data.
abstract class lxw_validation_criteria {
  static const int LXW_VALIDATION_CRITERIA_NONE = 0;

  /// Select data between two values.
  static const int LXW_VALIDATION_CRITERIA_BETWEEN = 1;

  /// Select data that is not between two values.
  static const int LXW_VALIDATION_CRITERIA_NOT_BETWEEN = 2;

  /// Select data equal to a value.
  static const int LXW_VALIDATION_CRITERIA_EQUAL_TO = 3;

  /// Select data not equal to a value.
  static const int LXW_VALIDATION_CRITERIA_NOT_EQUAL_TO = 4;

  /// Select data greater than a value.
  static const int LXW_VALIDATION_CRITERIA_GREATER_THAN = 5;

  /// Select data less than a value.
  static const int LXW_VALIDATION_CRITERIA_LESS_THAN = 6;

  /// Select data greater than or equal to a value.
  static const int LXW_VALIDATION_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 7;

  /// Select data less than or equal to a value.
  static const int LXW_VALIDATION_CRITERIA_LESS_THAN_OR_EQUAL_TO = 8;
}

/// Data validation error types for pop-up messages.
abstract class lxw_validation_error_types {
  /// Show a "Stop" data validation pop-up message. This is the default.
  static const int LXW_VALIDATION_ERROR_TYPE_STOP = 0;

  /// Show an "Error" data validation pop-up message.
  static const int LXW_VALIDATION_ERROR_TYPE_WARNING = 1;

  /// Show an "Information" data validation pop-up message.
  static const int LXW_VALIDATION_ERROR_TYPE_INFORMATION = 2;
}

/// Set the display type for a cell comment. This is hidden by default but
/// can be set to visible with the `worksheet_show_comments()` function.
abstract class lxw_comment_display_types {
  /// Default to the worksheet default which can be hidden or visible.
  static const int LXW_COMMENT_DISPLAY_DEFAULT = 0;

  /// Hide the cell comment. Usually the default.
  static const int LXW_COMMENT_DISPLAY_HIDDEN = 1;

  /// Show the cell comment. Can also be set for the worksheet with the
  /// `worksheet_show_comments()` function.
  static const int LXW_COMMENT_DISPLAY_VISIBLE = 2;
}

/// @brief Type definitions for conditional formats.
///
/// Values used to set the "type" field of conditional format.
abstract class lxw_conditional_format_types {
  static const int LXW_CONDITIONAL_TYPE_NONE = 0;

  /// The Cell type is the most common conditional formatting type. It is
  /// used when a format is applied to a cell based on a simple
  /// criterion.
  static const int LXW_CONDITIONAL_TYPE_CELL = 1;

  /// The Text type is used to specify Excel's "Specific Text" style
  /// conditional format.
  static const int LXW_CONDITIONAL_TYPE_TEXT = 2;

  /// The Time Period type is used to specify Excel's "Dates Occurring"
  /// style conditional format.
  static const int LXW_CONDITIONAL_TYPE_TIME_PERIOD = 3;

  /// The Average type is used to specify Excel's "Average" style
  /// conditional format.
  static const int LXW_CONDITIONAL_TYPE_AVERAGE = 4;

  /// The Duplicate type is used to highlight duplicate cells in a range.
  static const int LXW_CONDITIONAL_TYPE_DUPLICATE = 5;

  /// The Unique type is used to highlight unique cells in a range.
  static const int LXW_CONDITIONAL_TYPE_UNIQUE = 6;

  /// The Top type is used to specify the top n values by number or
  /// percentage in a range.
  static const int LXW_CONDITIONAL_TYPE_TOP = 7;

  /// The Bottom type is used to specify the bottom n values by number or
  /// percentage in a range.
  static const int LXW_CONDITIONAL_TYPE_BOTTOM = 8;

  /// The Blanks type is used to highlight blank cells in a range.
  static const int LXW_CONDITIONAL_TYPE_BLANKS = 9;

  /// The No Blanks type is used to highlight non blank cells in a range.
  static const int LXW_CONDITIONAL_TYPE_NO_BLANKS = 10;

  /// The Errors type is used to highlight error cells in a range.
  static const int LXW_CONDITIONAL_TYPE_ERRORS = 11;

  /// The No Errors type is used to highlight non error cells in a range.
  static const int LXW_CONDITIONAL_TYPE_NO_ERRORS = 12;

  /// The Formula type is used to specify a conditional format based on a
  /// user defined formula.
  static const int LXW_CONDITIONAL_TYPE_FORMULA = 13;

  /// The 2 Color Scale type is used to specify Excel's "2 Color Scale"
  /// style conditional format.
  static const int LXW_CONDITIONAL_2_COLOR_SCALE = 14;

  /// The 3 Color Scale type is used to specify Excel's "3 Color Scale"
  /// style conditional format.
  static const int LXW_CONDITIONAL_3_COLOR_SCALE = 15;

  /// The Data Bar type is used to specify Excel's "Data Bar" style
  /// conditional format.
  static const int LXW_CONDITIONAL_DATA_BAR = 16;

  /// The Icon Set type is used to specify a conditional format with a set
  /// of icons such as traffic lights or arrows.
  static const int LXW_CONDITIONAL_TYPE_ICON_SETS = 17;
  static const int LXW_CONDITIONAL_TYPE_LAST = 18;
}

/// @brief The criteria used in a conditional format.
///
/// Criteria used to define how a conditional format works.
abstract class lxw_conditional_criteria {
  static const int LXW_CONDITIONAL_CRITERIA_NONE = 0;

  /// Format cells equal to a value.
  static const int LXW_CONDITIONAL_CRITERIA_EQUAL_TO = 1;

  /// Format cells not equal to a value.
  static const int LXW_CONDITIONAL_CRITERIA_NOT_EQUAL_TO = 2;

  /// Format cells greater than a value.
  static const int LXW_CONDITIONAL_CRITERIA_GREATER_THAN = 3;

  /// Format cells less than a value.
  static const int LXW_CONDITIONAL_CRITERIA_LESS_THAN = 4;

  /// Format cells greater than or equal to a value.
  static const int LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 5;

  /// Format cells less than or equal to a value.
  static const int LXW_CONDITIONAL_CRITERIA_LESS_THAN_OR_EQUAL_TO = 6;

  /// Format cells between two values.
  static const int LXW_CONDITIONAL_CRITERIA_BETWEEN = 7;

  /// Format cells that is not between two values.
  static const int LXW_CONDITIONAL_CRITERIA_NOT_BETWEEN = 8;

  /// Format cells that contain the specified text.
  static const int LXW_CONDITIONAL_CRITERIA_TEXT_CONTAINING = 9;

  /// Format cells that don't contain the specified text.
  static const int LXW_CONDITIONAL_CRITERIA_TEXT_NOT_CONTAINING = 10;

  /// Format cells that begin with the specified text.
  static const int LXW_CONDITIONAL_CRITERIA_TEXT_BEGINS_WITH = 11;

  /// Format cells that end with the specified text.
  static const int LXW_CONDITIONAL_CRITERIA_TEXT_ENDS_WITH = 12;

  /// Format cells with a date of yesterday.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_YESTERDAY = 13;

  /// Format cells with a date of today.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_TODAY = 14;

  /// Format cells with a date of tomorrow.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_TOMORROW = 15;

  /// Format cells with a date in the last 7 days.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_7_DAYS = 16;

  /// Format cells with a date in the last week.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_WEEK = 17;

  /// Format cells with a date in the current week.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_THIS_WEEK = 18;

  /// Format cells with a date in the next week.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_NEXT_WEEK = 19;

  /// Format cells with a date in the last month.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_MONTH = 20;

  /// Format cells with a date in the current month.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_THIS_MONTH = 21;

  /// Format cells with a date in the next month.
  static const int LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_NEXT_MONTH = 22;

  /// Format cells above the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_ABOVE = 23;

  /// Format cells below the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_BELOW = 24;

  /// Format cells above or equal to the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_ABOVE_OR_EQUAL = 25;

  /// Format cells below or equal to the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_BELOW_OR_EQUAL = 26;

  /// Format cells 1 standard deviation above the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_1_STD_DEV_ABOVE = 27;

  /// Format cells 1 standard deviation below the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_1_STD_DEV_BELOW = 28;

  /// Format cells 2 standard deviation above the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_2_STD_DEV_ABOVE = 29;

  /// Format cells 2 standard deviation below the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_2_STD_DEV_BELOW = 30;

  /// Format cells 3 standard deviation above the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_3_STD_DEV_ABOVE = 31;

  /// Format cells 3 standard deviation below the average for the range.
  static const int LXW_CONDITIONAL_CRITERIA_AVERAGE_3_STD_DEV_BELOW = 32;

  /// Format cells in the top of bottom percentage.
  static const int LXW_CONDITIONAL_CRITERIA_TOP_OR_BOTTOM_PERCENT = 33;
}

/// @brief Conditional format rule types.
///
/// Conditional format rule types that apply to Color Scale and Data Bars.
abstract class lxw_conditional_format_rule_types {
  static const int LXW_CONDITIONAL_RULE_TYPE_NONE = 0;

  /// Conditional format rule type: matches the minimum values in the
  /// range. Can only be applied to min_rule_type.
  static const int LXW_CONDITIONAL_RULE_TYPE_MINIMUM = 1;

  /// Conditional format rule type: use a number to set the bound.
  static const int LXW_CONDITIONAL_RULE_TYPE_NUMBER = 2;

  /// Conditional format rule type: use a percentage to set the bound.
  static const int LXW_CONDITIONAL_RULE_TYPE_PERCENT = 3;

  /// Conditional format rule type: use a percentile to set the bound.
  static const int LXW_CONDITIONAL_RULE_TYPE_PERCENTILE = 4;

  /// Conditional format rule type: use a formula to set the bound.
  static const int LXW_CONDITIONAL_RULE_TYPE_FORMULA = 5;

  /// Conditional format rule type: matches the maximum values in the
  /// range. Can only be applied to max_rule_type.
  static const int LXW_CONDITIONAL_RULE_TYPE_MAXIMUM = 6;

  /// Used internally for Excel2010 bars. Not documented.
  static const int LXW_CONDITIONAL_RULE_TYPE_AUTO_MIN = 7;

  /// Used internally for Excel2010 bars. Not documented.
  static const int LXW_CONDITIONAL_RULE_TYPE_AUTO_MAX = 8;
}

/// @brief Conditional format data bar directions.
///
/// Values used to set the bar direction of a conditional format data bar.
abstract class lxw_conditional_format_bar_direction {
  /// Data bar direction is set by Excel based on the context of the data
  /// displayed.
  static const int LXW_CONDITIONAL_BAR_DIRECTION_CONTEXT = 0;

  /// Data bar direction is from right to left.
  static const int LXW_CONDITIONAL_BAR_DIRECTION_RIGHT_TO_LEFT = 1;

  /// Data bar direction is from left to right.
  static const int LXW_CONDITIONAL_BAR_DIRECTION_LEFT_TO_RIGHT = 2;
}

/// @brief Conditional format data bar axis options.
///
/// Values used to set the position of the axis in a conditional format data
/// bar.
abstract class lxw_conditional_bar_axis_position {
  /// Data bar axis position is set by Excel based on the context of the
  /// data displayed.
  static const int LXW_CONDITIONAL_BAR_AXIS_AUTOMATIC = 0;

  /// Data bar axis position is set at the midpoint.
  static const int LXW_CONDITIONAL_BAR_AXIS_MIDPOINT = 1;

  /// Data bar axis is turned off.
  static const int LXW_CONDITIONAL_BAR_AXIS_NONE = 2;
}

/// @brief Icon types used in the #lxw_conditional_format icon_style field.
///
/// Definitions of icon styles used with Icon Set conditional formats.
abstract class lxw_conditional_icon_types {
  /// Icon style: 3 colored arrows showing up, sideways and down.
  static const int LXW_CONDITIONAL_ICONS_3_ARROWS_COLORED = 0;

  /// Icon style: 3 gray arrows showing up, sideways and down.
  static const int LXW_CONDITIONAL_ICONS_3_ARROWS_GRAY = 1;

  /// Icon style: 3 colored flags in red, yellow and green.
  static const int LXW_CONDITIONAL_ICONS_3_FLAGS = 2;

  /// Icon style: 3 traffic lights - rounded.
  static const int LXW_CONDITIONAL_ICONS_3_TRAFFIC_LIGHTS_UNRIMMED = 3;

  /// Icon style: 3 traffic lights with a rim - squarish.
  static const int LXW_CONDITIONAL_ICONS_3_TRAFFIC_LIGHTS_RIMMED = 4;

  /// Icon style: 3 colored shapes - a circle, triangle and diamond.
  static const int LXW_CONDITIONAL_ICONS_3_SIGNS = 5;

  /// Icon style: 3 circled symbols with tick mark, exclamation and
  /// cross.
  static const int LXW_CONDITIONAL_ICONS_3_SYMBOLS_CIRCLED = 6;

  /// Icon style: 3 symbols with tick mark, exclamation and cross.
  static const int LXW_CONDITIONAL_ICONS_3_SYMBOLS_UNCIRCLED = 7;

  /// Icon style: 3 colored arrows showing up, diagonal up, diagonal down
  /// and down.
  static const int LXW_CONDITIONAL_ICONS_4_ARROWS_COLORED = 8;

  /// Icon style: 3 gray arrows showing up, diagonal up, diagonal down and
  /// down.
  static const int LXW_CONDITIONAL_ICONS_4_ARROWS_GRAY = 9;

  /// Icon style: 4 circles in 4 colors going from red to black.
  static const int LXW_CONDITIONAL_ICONS_4_RED_TO_BLACK = 10;

  /// Icon style: 4 histogram ratings.
  static const int LXW_CONDITIONAL_ICONS_4_RATINGS = 11;

  /// Icon style: 4 traffic lights.
  static const int LXW_CONDITIONAL_ICONS_4_TRAFFIC_LIGHTS = 12;

  /// Icon style: 5 colored arrows showing up, diagonal up, sideways,
  /// diagonal down and down.
  static const int LXW_CONDITIONAL_ICONS_5_ARROWS_COLORED = 13;

  /// Icon style: 5 gray arrows showing up, diagonal up, sideways, diagonal
  /// down and down.
  static const int LXW_CONDITIONAL_ICONS_5_ARROWS_GRAY = 14;

  /// Icon style: 5 histogram ratings.
  static const int LXW_CONDITIONAL_ICONS_5_RATINGS = 15;

  /// Icon style: 5 quarters, from 0 to 4 quadrants filled.
  static const int LXW_CONDITIONAL_ICONS_5_QUARTERS = 16;
}

/// @brief The type of table style.
///
/// The type of table style (Light, Medium or Dark).
abstract class lxw_table_style_type {
  static const int LXW_TABLE_STYLE_TYPE_DEFAULT = 0;

  /// Light table style.
  static const int LXW_TABLE_STYLE_TYPE_LIGHT = 1;

  /// Light table style.
  static const int LXW_TABLE_STYLE_TYPE_MEDIUM = 2;

  /// Light table style.
  static const int LXW_TABLE_STYLE_TYPE_DARK = 3;
}

/// @brief Standard Excel functions for totals in tables.
///
/// Definitions for the standard Excel functions that are available via the
/// dropdown in the total row of an Excel table.
abstract class lxw_table_total_functions {
  static const int LXW_TABLE_FUNCTION_NONE = 0;

  /// Use the average function as the table total.
  static const int LXW_TABLE_FUNCTION_AVERAGE = 101;

  /// Use the count numbers function as the table total.
  static const int LXW_TABLE_FUNCTION_COUNT_NUMS = 102;

  /// Use the count function as the table total.
  static const int LXW_TABLE_FUNCTION_COUNT = 103;

  /// Use the max function as the table total.
  static const int LXW_TABLE_FUNCTION_MAX = 104;

  /// Use the min function as the table total.
  static const int LXW_TABLE_FUNCTION_MIN = 105;

  /// Use the standard deviation function as the table total.
  static const int LXW_TABLE_FUNCTION_STD_DEV = 107;

  /// Use the sum function as the table total.
  static const int LXW_TABLE_FUNCTION_SUM = 109;

  /// Use the var function as the table total.
  static const int LXW_TABLE_FUNCTION_VAR = 110;
}

/// @brief The criteria used in autofilter rules.
///
/// Criteria used to define an autofilter rule condition.
abstract class lxw_filter_criteria {
  static const int LXW_FILTER_CRITERIA_NONE = 0;

  /// Filter cells equal to a value.
  static const int LXW_FILTER_CRITERIA_EQUAL_TO = 1;

  /// Filter cells not equal to a value.
  static const int LXW_FILTER_CRITERIA_NOT_EQUAL_TO = 2;

  /// Filter cells greater than a value.
  static const int LXW_FILTER_CRITERIA_GREATER_THAN = 3;

  /// Filter cells less than a value.
  static const int LXW_FILTER_CRITERIA_LESS_THAN = 4;

  /// Filter cells greater than or equal to a value.
  static const int LXW_FILTER_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 5;

  /// Filter cells less than or equal to a value.
  static const int LXW_FILTER_CRITERIA_LESS_THAN_OR_EQUAL_TO = 6;

  /// Filter cells that are blank.
  static const int LXW_FILTER_CRITERIA_BLANKS = 7;

  /// Filter cells that are not blank.
  static const int LXW_FILTER_CRITERIA_NON_BLANKS = 8;
}

/// @brief And/or operator when using 2 filter rules.
///
/// And/or operator conditions when using 2 filter rules with
/// worksheet_filter_column2(). In general LXW_FILTER_OR is used with
/// LXW_FILTER_CRITERIA_EQUAL_TO and LXW_FILTER_AND is used with the other
/// filter criteria.
abstract class lxw_filter_operator {
  /// Logical "and" of 2 filter rules.
  static const int LXW_FILTER_AND = 0;

  /// Logical "or" of 2 filter rules.
  static const int LXW_FILTER_OR = 1;
}

/// Internal filter types.
abstract class lxw_filter_type {
  static const int LXW_FILTER_TYPE_NONE = 0;
  static const int LXW_FILTER_TYPE_SINGLE = 1;
  static const int LXW_FILTER_TYPE_AND = 2;
  static const int LXW_FILTER_TYPE_OR = 3;
  static const int LXW_FILTER_TYPE_STRING_LIST = 4;
}

/// Options to control the positioning of worksheet objects such as images
/// or charts. See @ref working_with_object_positioning.
abstract class lxw_object_position {
  /// Default positioning for the object.
  static const int LXW_OBJECT_POSITION_DEFAULT = 0;

  /// Move and size the worksheet object with the cells.
  static const int LXW_OBJECT_MOVE_AND_SIZE = 1;

  /// Move but don't size the worksheet object with the cells.
  static const int LXW_OBJECT_MOVE_DONT_SIZE = 2;

  /// Don't move or size the worksheet object with the cells.
  static const int LXW_OBJECT_DONT_MOVE_DONT_SIZE = 3;

  /// Same as #LXW_OBJECT_MOVE_AND_SIZE except libxlsxwriter applies hidden
  /// cells after the object is inserted.
  static const int LXW_OBJECT_MOVE_AND_SIZE_AFTER = 4;
}

/// Options for ignoring worksheet errors/warnings. See worksheet_ignore_errors().
abstract class lxw_ignore_errors {
  /// Turn off errors/warnings for numbers stores as text.
  static const int LXW_IGNORE_NUMBER_STORED_AS_TEXT = 1;

  /// Turn off errors/warnings for formula errors (such as divide by
  /// zero).
  static const int LXW_IGNORE_EVAL_ERROR = 2;

  /// Turn off errors/warnings for formulas that differ from surrounding
  /// formulas.
  static const int LXW_IGNORE_FORMULA_DIFFERS = 3;

  /// Turn off errors/warnings for formulas that omit cells in a range.
  static const int LXW_IGNORE_FORMULA_RANGE = 4;

  /// Turn off errors/warnings for unlocked cells that contain formulas.
  static const int LXW_IGNORE_FORMULA_UNLOCKED = 5;

  /// Turn off errors/warnings for formulas that refer to empty cells.
  static const int LXW_IGNORE_EMPTY_CELL_REFERENCE = 6;

  /// Turn off errors/warnings for cells in a table that do not comply with
  /// applicable data validation rules.
  static const int LXW_IGNORE_LIST_DATA_VALIDATION = 7;

  /// Turn off errors/warnings for cell formulas that differ from the column
  /// formula.
  static const int LXW_IGNORE_CALCULATED_COLUMN = 8;

  /// Turn off errors/warnings for formulas that contain a two digit text
  /// representation of a year.
  static const int LXW_IGNORE_TWO_DIGIT_TEXT_YEAR = 9;
  static const int LXW_IGNORE_LAST_OPTION = 10;
}

abstract class cell_types {
  static const int NUMBER_CELL = 1;
  static const int STRING_CELL = 2;
  static const int INLINE_STRING_CELL = 3;
  static const int INLINE_RICH_STRING_CELL = 4;
  static const int FORMULA_CELL = 5;
  static const int ARRAY_FORMULA_CELL = 6;
  static const int DYNAMIC_ARRAY_FORMULA_CELL = 7;
  static const int BLANK_CELL = 8;
  static const int BOOLEAN_CELL = 9;
  static const int COMMENT = 10;
  static const int HYPERLINK_URL = 11;
  static const int HYPERLINK_INTERNAL = 12;
  static const int HYPERLINK_EXTERNAL = 13;
}

abstract class pane_types {
  static const int NO_PANES = 0;
  static const int FREEZE_PANES = 1;
  static const int SPLIT_PANES = 2;
  static const int FREEZE_SPLIT_PANES = 3;
}

abstract class lxw_image_position {
  static const int HEADER_LEFT = 0;
  static const int HEADER_CENTER = 1;
  static const int HEADER_RIGHT = 2;
  static const int FOOTER_LEFT = 3;
  static const int FOOTER_CENTER = 4;
  static const int FOOTER_RIGHT = 5;
}

/// Define the tree.h RB structs for the red-black head types.
class lxw_table_cells extends ffi.Struct {
  external ffi.Pointer<lxw_cell> rbh_root;
}

/// Struct to represent a worksheet cell.
class lxw_cell extends ffi.Struct {
  @lxw_row_t()
  external int row_num;

  @lxw_col_t()
  external int col_num;

  @ffi.Int32()
  external int type;

  external ffi.Pointer<lxw_format> format;

  external ffi.Pointer<lxw_vml_obj> comment;

  external UnnamedUnion2 u;

  @ffi.Double()
  external double formula_result;

  external ffi.Pointer<ffi.Char> user_data1;

  external ffi.Pointer<ffi.Char> user_data2;

  external ffi.Pointer<ffi.Char> sst_string;

  /// List pointers for tree.h.
  external UnnamedStruct16 tree_pointers;
}

/// Internal structure for VML object options.
class lxw_vml_obj extends ffi.Struct {
  @lxw_row_t()
  external int row;

  @lxw_col_t()
  external int col;

  @lxw_row_t()
  external int start_row;

  @lxw_col_t()
  external int start_col;

  @ffi.Int32()
  external int x_offset;

  @ffi.Int32()
  external int y_offset;

  @ffi.Uint32()
  external int col_absolute;

  @ffi.Uint32()
  external int row_absolute;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;

  @ffi.Double()
  external double x_dpi;

  @ffi.Double()
  external double y_dpi;

  @lxw_color_t()
  external int color;

  @ffi.Uint8()
  external int font_family;

  @ffi.Uint8()
  external int visible;

  @ffi.Uint32()
  external int author_id;

  @ffi.Uint32()
  external int rel_index;

  @ffi.Double()
  external double font_size;

  external lxw_drawing_coords from;

  external lxw_drawing_coords to;

  external ffi.Pointer<ffi.Char> author;

  external ffi.Pointer<ffi.Char> font_name;

  external ffi.Pointer<ffi.Char> text;

  external ffi.Pointer<ffi.Char> image_position;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> macro;

  external UnnamedStruct15 list_pointers;
}

class UnnamedStruct15 extends ffi.Struct {
  external ffi.Pointer<lxw_vml_obj> stqe_next;
}

class UnnamedUnion2 extends ffi.Union {
  @ffi.Double()
  external double number;

  @ffi.Int32()
  external int string_id;

  external ffi.Pointer<ffi.Char> string;
}

class UnnamedStruct16 extends ffi.Struct {
  external ffi.Pointer<lxw_cell> rbe_left;

  external ffi.Pointer<lxw_cell> rbe_right;

  external ffi.Pointer<lxw_cell> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

class lxw_drawing_rel_ids extends ffi.Struct {
  external ffi.Pointer<lxw_drawing_rel_id> rbh_root;
}

/// Struct to represent a drawing Target/ID pair.
class lxw_drawing_rel_id extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  external ffi.Pointer<ffi.Char> target;

  external UnnamedStruct17 tree_pointers;
}

class UnnamedStruct17 extends ffi.Struct {
  external ffi.Pointer<lxw_drawing_rel_id> rbe_left;

  external ffi.Pointer<lxw_drawing_rel_id> rbe_right;

  external ffi.Pointer<lxw_drawing_rel_id> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

class lxw_vml_drawing_rel_ids extends ffi.Struct {
  external ffi.Pointer<lxw_drawing_rel_id> rbh_root;
}

class lxw_cond_format_hash extends ffi.Struct {
  external ffi.Pointer<lxw_cond_format_hash_element> rbh_root;
}

class lxw_cond_format_hash_element extends ffi.Struct {
  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> sqref;

  external ffi.Pointer<lxw_cond_format_list> cond_formats;

  external UnnamedStruct19 tree_pointers;
}

class lxw_cond_format_list extends ffi.Struct {
  external ffi.Pointer<lxw_cond_format_obj> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_cond_format_obj>> stqh_last;
}

/// Internal
class lxw_cond_format_obj extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int criteria;

  @ffi.Double()
  external double min_value;

  external ffi.Pointer<ffi.Char> min_value_string;

  @ffi.Uint8()
  external int min_rule_type;

  @lxw_color_t()
  external int min_color;

  @ffi.Double()
  external double mid_value;

  external ffi.Pointer<ffi.Char> mid_value_string;

  @ffi.Uint8()
  external int mid_value_type;

  @ffi.Uint8()
  external int mid_rule_type;

  @lxw_color_t()
  external int mid_color;

  @ffi.Double()
  external double max_value;

  external ffi.Pointer<ffi.Char> max_value_string;

  @ffi.Uint8()
  external int max_value_type;

  @ffi.Uint8()
  external int max_rule_type;

  @lxw_color_t()
  external int max_color;

  @ffi.Uint8()
  external int data_bar_2010;

  @ffi.Uint8()
  external int auto_min;

  @ffi.Uint8()
  external int auto_max;

  @ffi.Uint8()
  external int bar_only;

  @ffi.Uint8()
  external int bar_solid;

  @ffi.Uint8()
  external int bar_negative_color_same;

  @ffi.Uint8()
  external int bar_negative_border_color_same;

  @ffi.Uint8()
  external int bar_no_border;

  @ffi.Uint8()
  external int bar_direction;

  @ffi.Uint8()
  external int bar_axis_position;

  @lxw_color_t()
  external int bar_color;

  @lxw_color_t()
  external int bar_negative_color;

  @lxw_color_t()
  external int bar_border_color;

  @lxw_color_t()
  external int bar_negative_border_color;

  @lxw_color_t()
  external int bar_axis_color;

  @ffi.Uint8()
  external int icon_style;

  @ffi.Uint8()
  external int reverse_icons;

  @ffi.Uint8()
  external int icons_only;

  @ffi.Uint8()
  external int stop_if_true;

  @ffi.Uint8()
  external int has_max;

  external ffi.Pointer<ffi.Char> type_string;

  external ffi.Pointer<ffi.Char> guid;

  @ffi.Int32()
  external int dxf_index;

  @ffi.Uint32()
  external int dxf_priority;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> first_cell;

  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> sqref;

  external UnnamedStruct18 list_pointers;
}

class UnnamedStruct18 extends ffi.Struct {
  external ffi.Pointer<lxw_cond_format_obj> stqe_next;
}

class UnnamedStruct19 extends ffi.Struct {
  external ffi.Pointer<lxw_cond_format_hash_element> rbe_left;

  external ffi.Pointer<lxw_cond_format_hash_element> rbe_right;

  external ffi.Pointer<lxw_cond_format_hash_element> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

/// Define a RB_TREE struct manually to add extra members.
class lxw_table_rows extends ffi.Struct {
  external ffi.Pointer<lxw_row> rbh_root;

  external ffi.Pointer<lxw_row> cached_row;

  @lxw_row_t()
  external int cached_row_num;
}

/// Struct to represent a worksheet row.
class lxw_row extends ffi.Struct {
  @lxw_row_t()
  external int row_num;

  @ffi.Double()
  external double height;

  external ffi.Pointer<lxw_format> format;

  @ffi.Uint8()
  external int hidden;

  @ffi.Uint8()
  external int level;

  @ffi.Uint8()
  external int collapsed;

  @ffi.Uint8()
  external int row_changed;

  @ffi.Uint8()
  external int data_changed;

  @ffi.Uint8()
  external int height_changed;

  external ffi.Pointer<lxw_table_cells> cells;

  /// tree management pointers for tree.h.
  external UnnamedStruct20 tree_pointers;
}

class UnnamedStruct20 extends ffi.Struct {
  external ffi.Pointer<lxw_row> rbe_left;

  external ffi.Pointer<lxw_row> rbe_right;

  external ffi.Pointer<lxw_row> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

class lxw_merged_ranges extends ffi.Struct {
  external ffi.Pointer<lxw_merged_range> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_merged_range>> stqh_last;
}

class lxw_merged_range extends ffi.Struct {
  @lxw_row_t()
  external int first_row;

  @lxw_row_t()
  external int last_row;

  @lxw_col_t()
  external int first_col;

  @lxw_col_t()
  external int last_col;

  external UnnamedStruct21 list_pointers;
}

class UnnamedStruct21 extends ffi.Struct {
  external ffi.Pointer<lxw_merged_range> stqe_next;
}

class lxw_selections extends ffi.Struct {
  external ffi.Pointer<lxw_selection> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_selection>> stqh_last;
}

class lxw_selection extends ffi.Struct {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Char> pane;

  @ffi.Array.multi([28])
  external ffi.Array<ffi.Char> active_cell;

  @ffi.Array.multi([28])
  external ffi.Array<ffi.Char> sqref;

  external UnnamedStruct22 list_pointers;
}

class UnnamedStruct22 extends ffi.Struct {
  external ffi.Pointer<lxw_selection> stqe_next;
}

class lxw_data_validations extends ffi.Struct {
  external ffi.Pointer<lxw_data_val_obj> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_data_val_obj>> stqh_last;
}

/// A copy of lxw_data_validation which is used internally and which contains
/// some additional fields.
class lxw_data_val_obj extends ffi.Struct {
  @ffi.Uint8()
  external int validate;

  @ffi.Uint8()
  external int criteria;

  @ffi.Uint8()
  external int ignore_blank;

  @ffi.Uint8()
  external int show_input;

  @ffi.Uint8()
  external int show_error;

  @ffi.Uint8()
  external int error_type;

  @ffi.Uint8()
  external int dropdown;

  @ffi.Double()
  external double value_number;

  external ffi.Pointer<ffi.Char> value_formula;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> value_list;

  @ffi.Double()
  external double minimum_number;

  external ffi.Pointer<ffi.Char> minimum_formula;

  external lxw_datetime minimum_datetime;

  @ffi.Double()
  external double maximum_number;

  external ffi.Pointer<ffi.Char> maximum_formula;

  external lxw_datetime maximum_datetime;

  external ffi.Pointer<ffi.Char> input_title;

  external ffi.Pointer<ffi.Char> input_message;

  external ffi.Pointer<ffi.Char> error_title;

  external ffi.Pointer<ffi.Char> error_message;

  @ffi.Array.multi([28])
  external ffi.Array<ffi.Char> sqref;

  external UnnamedStruct23 list_pointers;
}

class UnnamedStruct23 extends ffi.Struct {
  external ffi.Pointer<lxw_data_val_obj> stqe_next;
}

class lxw_image_props extends ffi.Struct {
  external ffi.Pointer<lxw_object_properties> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_object_properties>> stqh_last;
}

/// Internal struct to represent lxw_image_options and lxw_chart_options
/// values as well as internal metadata.
class lxw_object_properties extends ffi.Struct {
  @ffi.Int32()
  external int x_offset;

  @ffi.Int32()
  external int y_offset;

  @ffi.Double()
  external double x_scale;

  @ffi.Double()
  external double y_scale;

  @lxw_row_t()
  external int row;

  @lxw_col_t()
  external int col;

  external ffi.Pointer<ffi.Char> filename;

  external ffi.Pointer<ffi.Char> description;

  external ffi.Pointer<ffi.Char> url;

  external ffi.Pointer<ffi.Char> tip;

  @ffi.Uint8()
  external int object_position;

  external ffi.Pointer<FILE> stream;

  @ffi.Uint8()
  external int image_type;

  @ffi.Uint8()
  external int is_image_buffer;

  external ffi.Pointer<ffi.Char> image_buffer;

  @ffi.Size()
  external int image_buffer_size;

  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;

  external ffi.Pointer<ffi.Char> extension1;

  @ffi.Double()
  external double x_dpi;

  @ffi.Double()
  external double y_dpi;

  external ffi.Pointer<lxw_chart> chart;

  @ffi.Uint8()
  external int is_duplicate;

  @ffi.Uint8()
  external int is_background;

  external ffi.Pointer<ffi.Char> md5;

  external ffi.Pointer<ffi.Char> image_position;

  @ffi.Uint8()
  external int decorative;

  external UnnamedStruct24 list_pointers;
}

class UnnamedStruct24 extends ffi.Struct {
  external ffi.Pointer<lxw_object_properties> stqe_next;
}

class lxw_chart_props extends ffi.Struct {
  external ffi.Pointer<lxw_object_properties> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_object_properties>> stqh_last;
}

class lxw_comment_objs extends ffi.Struct {
  external ffi.Pointer<lxw_vml_obj> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_vml_obj>> stqh_last;
}

class lxw_table_objs extends ffi.Struct {
  external ffi.Pointer<lxw_table_obj> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_table_obj>> stqh_last;
}

class lxw_table_obj extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> total_string;

  external ffi.Pointer<ffi.Pointer<lxw_table_column>> columns;

  @ffi.Uint8()
  external int banded_columns;

  @ffi.Uint8()
  external int first_column;

  @ffi.Uint8()
  external int last_column;

  @ffi.Uint8()
  external int no_autofilter;

  @ffi.Uint8()
  external int no_banded_rows;

  @ffi.Uint8()
  external int no_header_row;

  @ffi.Uint8()
  external int style_type;

  @ffi.Uint8()
  external int style_type_number;

  @ffi.Uint8()
  external int total_row;

  @lxw_row_t()
  external int first_row;

  @lxw_col_t()
  external int first_col;

  @lxw_row_t()
  external int last_row;

  @lxw_col_t()
  external int last_col;

  @lxw_col_t()
  external int num_cols;

  @ffi.Uint32()
  external int id;

  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> sqref;

  @ffi.Array.multi([2080])
  external ffi.Array<ffi.Char> filter_sqref;

  external UnnamedStruct25 list_pointers;
}

/// @brief Table columns options.
///
/// Structure to set the options of a table column added with
/// worksheet_add_table(). See @ref ww_tables_columns.
class lxw_table_column extends ffi.Struct {
  /// Set the header name/caption for the column. If NULL the header defaults
  /// to  Column 1, Column 2, etc.
  external ffi.Pointer<ffi.Char> header;

  /// Set the formula for the column.
  external ffi.Pointer<ffi.Char> formula;

  /// Set the string description for the column total.
  external ffi.Pointer<ffi.Char> total_string;

  /// Set the function for the column total.
  @ffi.Uint8()
  external int total_function;

  /// Set the format for the column header.
  external ffi.Pointer<lxw_format> header_format;

  /// Set the format for the data rows in the column.
  external ffi.Pointer<lxw_format> format;

  /// Set the formula value for the column total (not generally required).
  @ffi.Double()
  external double total_value;
}

class UnnamedStruct25 extends ffi.Struct {
  external ffi.Pointer<lxw_table_obj> stqe_next;
}

/// @brief Options for rows and columns.
///
/// Options struct for the worksheet_set_column() and worksheet_set_row()
/// functions.
///
/// It has the following members:
///
/// * `hidden`
/// * `level`
/// * `collapsed`
///
/// The members of this struct are explained in @ref ww_outlines_grouping.
class lxw_row_col_options extends ffi.Struct {
  /// Hide the row/column. @ref ww_outlines_grouping.
  @ffi.Uint8()
  external int hidden;

  /// Outline level. See @ref ww_outlines_grouping.
  @ffi.Uint8()
  external int level;

  /// Set the outline row as collapsed. See @ref ww_outlines_grouping.
  @ffi.Uint8()
  external int collapsed;
}

class lxw_col_options extends ffi.Struct {
  @lxw_col_t()
  external int firstcol;

  @lxw_col_t()
  external int lastcol;

  @ffi.Double()
  external double width;

  external ffi.Pointer<lxw_format> format;

  @ffi.Uint8()
  external int hidden;

  @ffi.Uint8()
  external int level;

  @ffi.Uint8()
  external int collapsed;
}

class lxw_repeat_rows extends ffi.Struct {
  @ffi.Uint8()
  external int in_use;

  @lxw_row_t()
  external int first_row;

  @lxw_row_t()
  external int last_row;
}

class lxw_repeat_cols extends ffi.Struct {
  @ffi.Uint8()
  external int in_use;

  @lxw_col_t()
  external int first_col;

  @lxw_col_t()
  external int last_col;
}

class lxw_print_area extends ffi.Struct {
  @ffi.Uint8()
  external int in_use;

  @lxw_row_t()
  external int first_row;

  @lxw_row_t()
  external int last_row;

  @lxw_col_t()
  external int first_col;

  @lxw_col_t()
  external int last_col;
}

class lxw_autofilter extends ffi.Struct {
  @ffi.Uint8()
  external int in_use;

  @ffi.Uint8()
  external int has_rules;

  @lxw_row_t()
  external int first_row;

  @lxw_row_t()
  external int last_row;

  @lxw_col_t()
  external int first_col;

  @lxw_col_t()
  external int last_col;
}

class lxw_panes extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @lxw_row_t()
  external int first_row;

  @lxw_col_t()
  external int first_col;

  @lxw_row_t()
  external int top_row;

  @lxw_col_t()
  external int left_col;

  @ffi.Double()
  external double x_split;

  @ffi.Double()
  external double y_split;
}

/// @brief Worksheet data validation options.
class lxw_data_validation extends ffi.Struct {
  /// Set the validation type. Should be a #lxw_validation_types value.
  @ffi.Uint8()
  external int validate;

  /// Set the validation criteria type to select the data. Should be a
  /// #lxw_validation_criteria value.
  @ffi.Uint8()
  external int criteria;

  /// Controls whether a data validation is not applied to blank data in the
  /// cell. Should be a #lxw_validation_boolean value. It is on by
  /// default.
  @ffi.Uint8()
  external int ignore_blank;

  /// This parameter is used to toggle on and off the 'Show input message
  /// when cell is selected' option in the Excel data validation dialog. When
  /// the option is off an input message is not displayed even if it has been
  /// set using input_message. Should be a #lxw_validation_boolean value. It
  /// is on by default.
  @ffi.Uint8()
  external int show_input;

  /// This parameter is used to toggle on and off the 'Show error alert
  /// after invalid data is entered' option in the Excel data validation
  /// dialog. When the option is off an error message is not displayed even
  /// if it has been set using error_message. Should be a
  /// #lxw_validation_boolean value. It is on by default.
  @ffi.Uint8()
  external int show_error;

  /// This parameter is used to specify the type of error dialog that is
  /// displayed. Should be a #lxw_validation_error_types value.
  @ffi.Uint8()
  external int error_type;

  /// This parameter is used to toggle on and off the 'In-cell dropdown'
  /// option in the Excel data validation dialog. When the option is on a
  /// dropdown list will be shown for list validations. Should be a
  /// #lxw_validation_boolean value. It is on by default.
  @ffi.Uint8()
  external int dropdown;

  /// This parameter is used to set the limiting value to which the criteria
  /// is applied using a whole or decimal number.
  @ffi.Double()
  external double value_number;

  /// This parameter is used to set the limiting value to which the criteria
  /// is applied using a cell reference. It is valid for any of the
  /// `_FORMULA` validation types.
  external ffi.Pointer<ffi.Char> value_formula;

  /// This parameter is used to set a list of strings for a drop down list.
  /// The list should be a `NULL` terminated array of char* strings:
  ///
  /// @code
  /// char *list[] = {"open", "high", "close", NULL};
  ///
  /// data_validation->validate   = LXW_VALIDATION_TYPE_LIST;
  /// data_validation->value_list = list;
  /// @endcode
  ///
  /// The `value_formula` parameter can also be used to specify a list from
  /// an Excel cell range.
  ///
  /// Note, the string list is restricted by Excel to 255 characters,
  /// including comma separators.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> value_list;

  /// This parameter is used to set the limiting value to which the date or
  /// time criteria is applied using a #lxw_datetime struct.
  external lxw_datetime value_datetime;

  /// This parameter is the same as `value_number` but for the minimum value
  /// when a `BETWEEN` criteria is used.
  @ffi.Double()
  external double minimum_number;

  /// This parameter is the same as `value_formula` but for the minimum value
  /// when a `BETWEEN` criteria is used.
  external ffi.Pointer<ffi.Char> minimum_formula;

  /// This parameter is the same as `value_datetime` but for the minimum value
  /// when a `BETWEEN` criteria is used.
  external lxw_datetime minimum_datetime;

  /// This parameter is the same as `value_number` but for the maximum value
  /// when a `BETWEEN` criteria is used.
  @ffi.Double()
  external double maximum_number;

  /// This parameter is the same as `value_formula` but for the maximum value
  /// when a `BETWEEN` criteria is used.
  external ffi.Pointer<ffi.Char> maximum_formula;

  /// This parameter is the same as `value_datetime` but for the maximum value
  /// when a `BETWEEN` criteria is used.
  external lxw_datetime maximum_datetime;

  /// The input_title parameter is used to set the title of the input message
  /// that is displayed when a cell is entered. It has no default value and
  /// is only displayed if the input message is displayed. See the
  /// `input_message` parameter below.
  ///
  /// The maximum title length is 32 characters.
  external ffi.Pointer<ffi.Char> input_title;

  /// The input_message parameter is used to set the input message that is
  /// displayed when a cell is entered. It has no default value.
  ///
  /// The message can be split over several lines using newlines. The maximum
  /// message length is 255 characters.
  external ffi.Pointer<ffi.Char> input_message;

  /// The error_title parameter is used to set the title of the error message
  /// that is displayed when the data validation criteria is not met. The
  /// default error title is 'Microsoft Excel'. The maximum title length is
  /// 32 characters.
  external ffi.Pointer<ffi.Char> error_title;

  /// The error_message parameter is used to set the error message that is
  /// displayed when a cell is entered. The default error message is "The
  /// value you entered is not valid. A user has restricted values that can
  /// be entered into the cell".
  ///
  /// The message can be split over several lines using newlines. The maximum
  /// message length is 255 characters.
  external ffi.Pointer<ffi.Char> error_message;
}

/// @brief Worksheet conditional formatting options.
///
/// The fields/options in the the lxw_conditional_format are used to define a
/// worksheet conditional format. It is used in conjunction with
/// `worksheet_conditional_format()`.
class lxw_conditional_format extends ffi.Struct {
  /// The type of conditional format such as #LXW_CONDITIONAL_TYPE_CELL or
  /// #LXW_CONDITIONAL_DATA_BAR. Should be a #lxw_conditional_format_types
  /// value.
  @ffi.Uint8()
  external int type;

  /// The criteria parameter is used to set the criteria by which the cell
  /// data will be evaluated. For example in the expression `a > 5 the
  /// criteria is `>` or, in libxlsxwriter terms,
  /// #LXW_CONDITIONAL_CRITERIA_GREATER_THAN. The criteria that are
  /// applicable depend on the conditional format type.  The criteria
  /// options are defined in #lxw_conditional_criteria.
  @ffi.Uint8()
  external int criteria;

  /// The number value to which the condition refers. For example in the
  /// expression `a > 5`, the value is 5.
  @ffi.Double()
  external double value;

  /// The string value to which the condition refers, such as `"=A1"`. If a
  /// value_string exists in the struct then the number value is
  /// ignored. Note, if the condition refers to a text string then it must
  /// be double quoted like this `"foo"`.
  external ffi.Pointer<ffi.Char> value_string;

  /// The format field is used to specify the #lxw_format format that will
  /// be applied to the cell when the conditional formatting criterion is
  /// met. The #lxw_format is created using the `workbook_add_format()`
  /// method in the same way as cell formats.
  ///
  /// @note In Excel, a conditional format is superimposed over the existing
  /// cell format and not all cell format properties can be
  /// modified. Properties that @b cannot be modified, in Excel, by a
  /// conditional format are: font name, font size, superscript and
  /// subscript, diagonal borders, all alignment properties and all
  /// protection properties.
  external ffi.Pointer<lxw_format> format;

  /// The minimum value used for Cell, Color Scale and Data Bar conditional
  /// formats. For Cell types this is usually used with a "Between" style criteria.
  @ffi.Double()
  external double min_value;

  /// The minimum string value used for Cell, Color Scale and Data Bar conditional
  /// formats. Usually used to set ranges like `=A1`.
  external ffi.Pointer<ffi.Char> min_value_string;

  /// The rule used for the minimum condition in Color Scale and Data Bar
  /// conditional formats. The rule types are defined in
  /// #lxw_conditional_format_rule_types.
  @ffi.Uint8()
  external int min_rule_type;

  /// The color used for the minimum Color Scale conditional format.
  /// See @ref working_with_colors.
  @lxw_color_t()
  external int min_color;

  /// The middle value used for Color Scale and Data Bar conditional
  /// formats.
  @ffi.Double()
  external double mid_value;

  /// The middle string value used for Color Scale and Data Bar conditional
  /// formats. Usually used to set ranges like `=A1`.
  external ffi.Pointer<ffi.Char> mid_value_string;

  /// The rule used for the middle condition in Color Scale and Data Bar
  /// conditional formats. The rule types are defined in
  /// #lxw_conditional_format_rule_types.
  @ffi.Uint8()
  external int mid_rule_type;

  /// The color used for the middle Color Scale conditional format.
  /// See @ref working_with_colors.
  @lxw_color_t()
  external int mid_color;

  /// The maximum value used for Cell, Color Scale and Data Bar conditional
  /// formats. For Cell types this is usually used with a "Between" style
  /// criteria.
  @ffi.Double()
  external double max_value;

  /// The maximum string value used for Cell, Color Scale and Data Bar conditional
  /// formats. Usually used to set ranges like `=A1`.
  external ffi.Pointer<ffi.Char> max_value_string;

  /// The rule used for the maximum condition in Color Scale and Data Bar
  /// conditional formats. The rule types are defined in
  /// #lxw_conditional_format_rule_types.
  @ffi.Uint8()
  external int max_rule_type;

  /// The color used for the maximum Color Scale conditional format.
  /// See @ref working_with_colors.
  @lxw_color_t()
  external int max_color;

  /// The bar_color field sets the fill color for data bars. See @ref
  /// working_with_colors.
  @lxw_color_t()
  external int bar_color;

  /// The bar_only field sets The bar_only field displays a bar data but
  /// not the data in the cells.
  @ffi.Uint8()
  external int bar_only;

  /// In Excel 2010 additional data bar properties were added such as solid
  /// (non-gradient) bars and control over how negative values are
  /// displayed. These properties can shown below.
  ///
  /// The data_bar_2010 field sets Excel 2010 style data bars even when
  /// Excel 2010 specific properties aren't used.
  @ffi.Uint8()
  external int data_bar_2010;

  /// The bar_solid field turns on a solid (non-gradient) fill for data
  /// bars. Set to LXW_TRUE to turn on. Excel 2010 only.
  @ffi.Uint8()
  external int bar_solid;

  /// The bar_negative_color field sets the color fill for the negative
  /// portion of a data bar. See @ref working_with_colors. Excel 2010 only.
  @lxw_color_t()
  external int bar_negative_color;

  /// The bar_border_color field sets the color for the border line of a
  /// data bar. See @ref working_with_colors. Excel 2010 only.
  @lxw_color_t()
  external int bar_border_color;

  /// The bar_negative_border_color field sets the color for the border of
  /// the negative portion of a data bar. See @ref
  /// working_with_colors. Excel 2010 only.
  @lxw_color_t()
  external int bar_negative_border_color;

  /// The bar_negative_color_same field sets the fill color for the negative
  /// portion of a data bar to be the same as the fill color for the
  /// positive portion of the data bar. Set to LXW_TRUE to turn on. Excel
  /// 2010 only.
  @ffi.Uint8()
  external int bar_negative_color_same;

  /// The bar_negative_border_color_same field sets the border color for the
  /// negative portion of a data bar to be the same as the border color for
  /// the positive portion of the data bar. Set to LXW_TRUE to turn
  /// on. Excel 2010 only.
  @ffi.Uint8()
  external int bar_negative_border_color_same;

  /// The bar_no_border field turns off the border for data bars. Set to
  /// LXW_TRUE to enable. Excel 2010 only.
  @ffi.Uint8()
  external int bar_no_border;

  /// The bar_direction field sets the direction for data bars. This
  /// property can be either left for left-to-right or right for
  /// right-to-left. If the property isn't set then Excel will adjust the
  /// position automatically based on the context. Should be a
  /// #lxw_conditional_format_bar_direction value. Excel 2010 only.
  @ffi.Uint8()
  external int bar_direction;

  /// The bar_axis_position field sets the position within the cells for the
  /// axis that is shown in data bars when there are negative values to
  /// display. The property can be either middle or none. If the property
  /// isn't set then Excel will position the axis based on the range of
  /// positive and negative values. Should be a
  /// lxw_conditional_bar_axis_position value. Excel 2010 only.
  @ffi.Uint8()
  external int bar_axis_position;

  /// The bar_axis_color field sets the color for the axis that is shown
  /// in data bars when there are negative values to display. See @ref
  /// working_with_colors. Excel 2010 only.
  @lxw_color_t()
  external int bar_axis_color;

  /// The Icons Sets style is specified by the icon_style parameter. Should
  /// be a #lxw_conditional_icon_types.
  @ffi.Uint8()
  external int icon_style;

  /// The order of Icon Sets icons can be reversed by setting reverse_icons
  /// to LXW_TRUE.
  @ffi.Uint8()
  external int reverse_icons;

  /// The icons can be displayed without the cell value by settings the
  /// icons_only parameter to LXW_TRUE.
  @ffi.Uint8()
  external int icons_only;

  /// The multi_range field is used to extend a conditional format over
  /// non-contiguous ranges.
  ///
  /// It is possible to apply the conditional format to different cell
  /// ranges in a worksheet using multiple calls to
  /// `worksheet_conditional_format()`. However, as a minor optimization it
  /// is also possible in Excel to apply the same conditional format to
  /// different non-contiguous cell ranges.
  ///
  /// This is replicated in `worksheet_conditional_format()` using the
  /// multi_range option. The range must contain the primary range for the
  /// conditional format and any others separated by spaces. For example
  /// `"A1 C1:C5 E2 G1:G100"`.
  external ffi.Pointer<ffi.Char> multi_range;

  /// The stop_if_true parameter can be used to set the "stop if true"
  /// feature of a conditional formatting rule when more than one rule is
  /// applied to a cell or a range of cells. When this parameter is set then
  /// subsequent rules are not evaluated if the current rule is true. Set to
  /// LXW_TRUE to turn on.
  @ffi.Uint8()
  external int stop_if_true;
}

/// @brief Worksheet table options.
///
/// Options used to define worksheet tables. See @ref working_with_tables for
/// more information.
class lxw_table_options extends ffi.Struct {
  /// The `name` parameter is used to set the name of the table. This
  /// parameter is optional and by default tables are named `Table1`,
  /// `Table2`, etc. in the worksheet order that they are added.
  ///
  /// @code
  /// lxw_table_options options = {.name = "Sales"};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
  /// @endcode
  ///
  /// If you override the table name you must ensure that it doesn't clash
  /// with an existing table name and that it follows Excel's requirements
  /// for table names, see the Microsoft Office documentation on
  /// [Naming an Excel Table]
  /// (https://support.microsoft.com/en-us/office/rename-an-excel-table-fbf49a4f-82a3-43eb-8ba2-44d21233b114).
  external ffi.Pointer<ffi.Char> name;

  /// The `no_header_row` parameter can be used to turn off the header row in
  /// the table. It is on by default:
  ///
  /// @code
  /// lxw_table_options options = {.no_header_row = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B4:F7"), &options);
  /// @endcode
  ///
  /// @image html tables4.png
  ///
  /// Without this option the header row will contain default captions such
  /// as `Column 1`, ``Column 2``, etc. These captions can be overridden
  /// using the `columns` parameter shown below.
  @ffi.Uint8()
  external int no_header_row;

  /// The `no_autofilter` parameter can be used to turn off the autofilter in
  /// the header row. It is on by default:
  ///
  /// @code
  /// lxw_table_options options = {.no_autofilter = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
  /// @endcode
  ///
  /// @image html tables3.png
  ///
  /// The autofilter is only shown if the `no_header_row` parameter is off
  /// (the default). Filter conditions within the table are not supported.
  @ffi.Uint8()
  external int no_autofilter;

  /// The `no_banded_rows` parameter can be used to turn off the rows of alternating
  /// color in the table. It is on by default:
  ///
  /// @code
  /// lxw_table_options options = {.no_banded_rows = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
  /// @endcode
  ///
  /// @image html tables6.png
  @ffi.Uint8()
  external int no_banded_rows;

  /// The `banded_columns` parameter can be used to used to create columns of
  /// alternating color in the table. It is off by default:
  ///
  /// @code
  /// lxw_table_options options = {.banded_columns = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
  /// @endcode
  ///
  /// The banded columns formatting is shown in the image in the previous
  /// section above.
  @ffi.Uint8()
  external int banded_columns;

  /// The `first_column` parameter can be used to highlight the first column
  /// of the table. The type of highlighting will depend on the `style_type`
  /// of the table. It may be bold text or a different color. It is off by
  /// default:
  ///
  /// @code
  /// lxw_table_options options = {.first_column = LXW_TRUE, .last_column = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
  /// @endcode
  ///
  /// @image html tables5.png
  @ffi.Uint8()
  external int first_column;

  /// The `last_column` parameter can be used to highlight the last column of
  /// the table. The type of highlighting will depend on the `style` of the
  /// table. It may be bold text or a different color. It is off by default:
  ///
  /// @code
  /// lxw_table_options options = {.first_column = LXW_TRUE, .last_column = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
  /// @endcode
  ///
  /// The `last_column` formatting is shown in the image in the previous
  /// section above.
  @ffi.Uint8()
  external int last_column;

  /// The `style_type` parameter can be used to set the style of the table,
  /// in conjunction with the `style_type_number` parameter:
  ///
  /// @code
  /// lxw_table_options options = {
  /// .style_type = LXW_TABLE_STYLE_TYPE_LIGHT,
  /// .style_type_number = 11,
  /// };
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
  /// @endcode
  ///
  ///
  /// @image html tables11.png
  ///
  /// There are three types of table style in Excel: Light, Medium and Dark
  /// which are represented using the #lxw_table_style_type enum values:
  ///
  /// - #LXW_TABLE_STYLE_TYPE_LIGHT
  ///
  /// - #LXW_TABLE_STYLE_TYPE_MEDIUM
  ///
  /// - #LXW_TABLE_STYLE_TYPE_DARK
  ///
  /// Within those ranges there are between 11 and 28 other style types which
  /// can be set with `style_type_number` (depending on the style type).
  /// Check Excel to find the style that you want. The dialog with the
  /// options laid out in numeric order are shown below:
  ///
  /// @image html tables14.png
  ///
  /// The default table style in Excel is 'Table Style Medium 9' (highlighted
  /// with a green border in the image above), which is set by default in
  /// libxlsxwriter as:
  ///
  /// @code
  /// lxw_table_options options = {
  /// .style_type = LXW_TABLE_STYLE_TYPE_MEDIUM,
  /// .style_type_number = 9,
  /// };
  /// @endcode
  ///
  /// You can also turn the table style off by setting it to Light 0:
  ///
  /// @code
  /// lxw_table_options options = {
  /// .style_type = LXW_TABLE_STYLE_TYPE_LIGHT,
  /// .style_type_number = 0,
  /// };
  /// @endcode
  ///
  /// @image html tables13.png
  @ffi.Uint8()
  external int style_type;

  /// The `style_type_number` parameter is used with `style_type` to set the
  /// style of a worksheet table.
  @ffi.Uint8()
  external int style_type_number;

  /// The `total_row` parameter can be used to turn on the total row in the
  /// last row of a table. It is distinguished from the other rows by a
  /// different formatting and also with dropdown `SUBTOTAL` functions:
  ///
  /// @code
  /// lxw_table_options options = {.total_row = LXW_TRUE};
  ///
  /// worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
  /// @endcode
  ///
  /// @image html tables9.png
  ///
  /// The default total row doesn't have any captions or functions. These
  /// must by specified via the `columns` parameter below.
  @ffi.Uint8()
  external int total_row;

  /// The `columns` parameter can be used to set properties for columns
  /// within the table. See @ref ww_tables_columns for a detailed
  /// explanation.
  external ffi.Pointer<ffi.Pointer<lxw_table_column>> columns;
}

/// @brief Options for autofilter rules.
///
/// Options to define an autofilter rule.
class lxw_filter_rule extends ffi.Struct {
  /// The #lxw_filter_criteria to define the rule.
  @ffi.Uint8()
  external int criteria;

  /// String value to which the criteria applies.
  external ffi.Pointer<ffi.Char> value_string;

  /// Numeric value to which the criteria applies (if value_string isn't used).
  @ffi.Double()
  external double value;
}

class lxw_filter_rule_obj extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int is_custom;

  @ffi.Uint8()
  external int has_blanks;

  @lxw_col_t()
  external int col_num;

  @ffi.Uint8()
  external int criteria1;

  @ffi.Uint8()
  external int criteria2;

  @ffi.Double()
  external double value1;

  @ffi.Double()
  external double value2;

  external ffi.Pointer<ffi.Char> value1_string;

  external ffi.Pointer<ffi.Char> value2_string;

  @ffi.Uint16()
  external int num_list_filters;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> list;
}

/// @brief Options for inserted images.
///
/// Options for modifying images inserted via `worksheet_insert_image_opt()`.
class lxw_image_options extends ffi.Struct {
  /// Offset from the left of the cell in pixels.
  @ffi.Int32()
  external int x_offset;

  /// Offset from the top of the cell in pixels.
  @ffi.Int32()
  external int y_offset;

  /// X scale of the image as a decimal.
  @ffi.Double()
  external double x_scale;

  /// Y scale of the image as a decimal.
  @ffi.Double()
  external double y_scale;

  /// Object position - use one of the values of #lxw_object_position.
  /// See @ref working_with_object_positioning.
  @ffi.Uint8()
  external int object_position;

  /// Optional description or "Alt text" for the image. This field can be
  /// used to provide a text description of the image to help
  /// accessibility. Defaults to the image filename as in Excel. Set to ""
  /// to ignore the description field.
  external ffi.Pointer<ffi.Char> description;

  /// Optional parameter to help accessibility. It is used to mark the image
  /// as decorative, and thus uninformative, for automated screen
  /// readers. As in Excel, if this parameter is in use the `description`
  /// field isn't written.
  @ffi.Uint8()
  external int decorative;

  /// Add an optional hyperlink to the image. Follows the same URL rules
  /// and types as `worksheet_write_url()`.
  external ffi.Pointer<ffi.Char> url;

  /// Add an optional mouseover tip for a hyperlink to the image.
  external ffi.Pointer<ffi.Char> tip;
}

/// @brief Options for inserted charts.
///
/// Options for modifying charts inserted via `worksheet_insert_chart_opt()`.
class lxw_chart_options extends ffi.Struct {
  /// Offset from the left of the cell in pixels.
  @ffi.Int32()
  external int x_offset;

  /// Offset from the top of the cell in pixels.
  @ffi.Int32()
  external int y_offset;

  /// X scale of the chart as a decimal.
  @ffi.Double()
  external double x_scale;

  /// Y scale of the chart as a decimal.
  @ffi.Double()
  external double y_scale;

  /// Object position - use one of the values of #lxw_object_position.
  /// See @ref working_with_object_positioning.
  @ffi.Uint8()
  external int object_position;

  /// Optional description or "Alt text" for the chart. This field can be
  /// used to provide a text description of the chart to help
  /// accessibility. Defaults to the image filename as in Excel. Set to NULL
  /// to ignore the description field.
  external ffi.Pointer<ffi.Char> description;

  /// Optional parameter to help accessibility. It is used to mark the chart
  /// as decorative, and thus uninformative, for automated screen
  /// readers. As in Excel, if this parameter is in use the `description`
  /// field isn't written.
  @ffi.Uint8()
  external int decorative;
}

/// @brief Options for inserted comments.
///
/// Options for modifying comments inserted via `worksheet_write_comment_opt()`.
class lxw_comment_options extends ffi.Struct {
  /// This option is used to make a cell comment visible when the worksheet
  /// is opened. The default behavior in Excel is that comments are
  /// initially hidden. However, it is also possible in Excel to make
  /// individual comments or all comments visible.  You can make all
  /// comments in the worksheet visible using the
  /// `worksheet_show_comments()` function. Defaults to
  /// LXW_COMMENT_DISPLAY_DEFAULT. See also @ref ww_comments_visible.
  @ffi.Uint8()
  external int visible;

  /// This option is used to indicate the author of the cell comment. Excel
  /// displays the author in the status bar at the bottom of the
  /// worksheet. The default author for all cell comments in a worksheet can
  /// be set using the `worksheet_set_comments_author()` function. Set to
  /// NULL if not required.  See also @ref ww_comments_author.
  external ffi.Pointer<ffi.Char> author;

  /// This option is used to set the width of the cell comment box
  /// explicitly in pixels. The default width is 128 pixels. See also @ref
  /// ww_comments_width.
  @ffi.Uint16()
  external int width;

  /// This option is used to set the height of the cell comment box
  /// explicitly in pixels. The default height is 74 pixels.  See also @ref
  /// ww_comments_height.
  @ffi.Uint16()
  external int height;

  /// X scale of the comment as a decimal. See also
  /// @ref ww_comments_x_scale.
  @ffi.Double()
  external double x_scale;

  /// Y scale of the comment as a decimal. See also
  /// @ref ww_comments_y_scale.
  @ffi.Double()
  external double y_scale;

  /// This option is used to set the background color of cell comment
  /// box. The color should be an RGB integer value, see @ref
  /// working_with_colors. See also @ref ww_comments_color.
  @lxw_color_t()
  external int color;

  /// This option is used to set the font for the comment. The default font
  /// is 'Tahoma'.  See also @ref ww_comments_font_name.
  external ffi.Pointer<ffi.Char> font_name;

  /// This option is used to set the font size for the comment. The default
  /// is 8. See also @ref ww_comments_font_size.
  @ffi.Double()
  external double font_size;

  /// This option is used to set the font family number for the comment.
  /// Not required very often. Set to 0.
  @ffi.Uint8()
  external int font_family;

  /// This option is used to set the row in which the comment will
  /// appear. By default Excel displays comments one cell to the right and
  /// one cell above the cell to which the comment relates. The `start_row`
  /// and `start_col` options should both be set to 0 if not used.  See also
  /// @ref ww_comments_start_row.
  @lxw_row_t()
  external int start_row;

  /// This option is used to set the column in which the comment will
  /// appear. See the `start_row` option for more information and see also
  /// @ref ww_comments_start_col.
  @lxw_col_t()
  external int start_col;

  /// Offset from the left of the cell in pixels. See also
  /// @ref ww_comments_x_offset.
  @ffi.Int32()
  external int x_offset;

  /// Offset from the top of the cell in pixels. See also
  /// @ref ww_comments_y_offset.
  @ffi.Int32()
  external int y_offset;
}

/// @brief Options for inserted buttons.
///
/// Options for modifying buttons inserted via `worksheet_insert_button()`.
class lxw_button_options extends ffi.Struct {
  /// Sets the caption on the button. The default is "Button n" where n is
  /// the current number of buttons in the worksheet, including this
  /// button.
  external ffi.Pointer<ffi.Char> caption;

  /// Name of the macro to run when the button is pressed. The macro must be
  /// included with workbook_add_vba_project().
  external ffi.Pointer<ffi.Char> macro;

  /// Optional description or "Alt text" for the button. This field can be
  /// used to provide a text description of the button to help
  /// accessibility. Set to NULL to ignore the description field.
  external ffi.Pointer<ffi.Char> description;

  /// This option is used to set the width of the cell button box
  /// explicitly in pixels. The default width is 64 pixels.
  @ffi.Uint16()
  external int width;

  /// This option is used to set the height of the cell button box
  /// explicitly in pixels. The default height is 20 pixels.
  @ffi.Uint16()
  external int height;

  /// X scale of the button as a decimal.
  @ffi.Double()
  external double x_scale;

  /// Y scale of the button as a decimal.
  @ffi.Double()
  external double y_scale;

  /// Offset from the left of the cell in pixels.
  @ffi.Int32()
  external int x_offset;

  /// Offset from the top of the cell in pixels.
  @ffi.Int32()
  external int y_offset;
}

/// @brief Header and footer options.
///
/// Optional parameters used in the `worksheet_set_header_opt()` and
/// worksheet_set_footer_opt() functions.
class lxw_header_footer_options extends ffi.Struct {
  /// Header or footer margin in inches. Excel default is 0.3. Must by
  /// larger than 0.0.  See `worksheet_set_header_opt()`.
  @ffi.Double()
  external double margin;

  /// The left header image filename, with path if required. This should
  /// have a corresponding `&G/&[Picture]` placeholder in the `&L` section of
  /// the header/footer string. See `worksheet_set_header_opt()`.
  external ffi.Pointer<ffi.Char> image_left;

  /// The center header image filename, with path if required. This should
  /// have a corresponding `&G/&[Picture]` placeholder in the `&C` section of
  /// the header/footer string. See `worksheet_set_header_opt()`.
  external ffi.Pointer<ffi.Char> image_center;

  /// The right header image filename, with path if required. This should
  /// have a corresponding `&G/&[Picture]` placeholder in the `&R` section of
  /// the header/footer string. See `worksheet_set_header_opt()`.
  external ffi.Pointer<ffi.Char> image_right;
}

/// @brief Worksheet protection options.
class lxw_protection extends ffi.Struct {
  /// Turn off selection of locked cells. This in on in Excel by default.
  @ffi.Uint8()
  external int no_select_locked_cells;

  /// Turn off selection of unlocked cells. This in on in Excel by default.
  @ffi.Uint8()
  external int no_select_unlocked_cells;

  /// Prevent formatting of cells.
  @ffi.Uint8()
  external int format_cells;

  /// Prevent formatting of columns.
  @ffi.Uint8()
  external int format_columns;

  /// Prevent formatting of rows.
  @ffi.Uint8()
  external int format_rows;

  /// Prevent insertion of columns.
  @ffi.Uint8()
  external int insert_columns;

  /// Prevent insertion of rows.
  @ffi.Uint8()
  external int insert_rows;

  /// Prevent insertion of hyperlinks.
  @ffi.Uint8()
  external int insert_hyperlinks;

  /// Prevent deletion of columns.
  @ffi.Uint8()
  external int delete_columns;

  /// Prevent deletion of rows.
  @ffi.Uint8()
  external int delete_rows;

  /// Prevent sorting data.
  @ffi.Uint8()
  external int sort;

  /// Prevent filtering data.
  @ffi.Uint8()
  external int autofilter;

  /// Prevent insertion of pivot tables.
  @ffi.Uint8()
  external int pivot_tables;

  /// Protect scenarios.
  @ffi.Uint8()
  external int scenarios;

  /// Protect drawing objects. Worksheets only.
  @ffi.Uint8()
  external int objects;

  /// Turn off chartsheet content protection.
  @ffi.Uint8()
  external int no_content;

  /// Turn off chartsheet objects.
  @ffi.Uint8()
  external int no_objects;
}

/// Internal struct to copy lxw_protection options and internal metadata.
class lxw_protection_obj extends ffi.Struct {
  @ffi.Uint8()
  external int no_select_locked_cells;

  @ffi.Uint8()
  external int no_select_unlocked_cells;

  @ffi.Uint8()
  external int format_cells;

  @ffi.Uint8()
  external int format_columns;

  @ffi.Uint8()
  external int format_rows;

  @ffi.Uint8()
  external int insert_columns;

  @ffi.Uint8()
  external int insert_rows;

  @ffi.Uint8()
  external int insert_hyperlinks;

  @ffi.Uint8()
  external int delete_columns;

  @ffi.Uint8()
  external int delete_rows;

  @ffi.Uint8()
  external int sort;

  @ffi.Uint8()
  external int autofilter;

  @ffi.Uint8()
  external int pivot_tables;

  @ffi.Uint8()
  external int scenarios;

  @ffi.Uint8()
  external int objects;

  @ffi.Uint8()
  external int no_content;

  @ffi.Uint8()
  external int no_objects;

  @ffi.Uint8()
  external int no_sheet;

  @ffi.Uint8()
  external int is_configured;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Char> hash;
}

/// @brief Struct to represent a rich string format/string pair.
///
/// Arrays of this struct are used to define "rich" multi-format strings that
/// are passed to `worksheet_write_rich_string()`. Each struct represents a
/// fragment of the rich multi-format string with a lxw_format to define the
/// format for the string part. If the string fragment is unformatted then
/// `NULL` can be used for the format.
class lxw_rich_string_tuple extends ffi.Struct {
  /// The format for a string fragment in a rich string. NULL if the string
  /// isn't formatted.
  external ffi.Pointer<lxw_format> format;

  /// The string fragment.
  external ffi.Pointer<ffi.Char> string;
}

/// @brief Struct to represent an Excel worksheet.
///
/// The members of the lxw_worksheet struct aren't modified directly. Instead
/// the worksheet properties are set by calling the functions shown in
/// worksheet.h.
class lxw_worksheet extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  external ffi.Pointer<FILE> optimize_tmpfile;

  external ffi.Pointer<ffi.Char> optimize_buffer;

  @ffi.Size()
  external int optimize_buffer_size;

  external ffi.Pointer<lxw_table_rows> table;

  external ffi.Pointer<lxw_table_rows> hyperlinks;

  external ffi.Pointer<lxw_table_rows> comments;

  external ffi.Pointer<ffi.Pointer<lxw_cell>> array;

  external ffi.Pointer<lxw_merged_ranges> merged_ranges;

  external ffi.Pointer<lxw_selections> selections;

  external ffi.Pointer<lxw_data_validations> data_validations;

  external ffi.Pointer<lxw_cond_format_hash> conditional_formats;

  external ffi.Pointer<lxw_image_props> image_props;

  external ffi.Pointer<lxw_chart_props> chart_data;

  external ffi.Pointer<lxw_drawing_rel_ids> drawing_rel_ids;

  external ffi.Pointer<lxw_vml_drawing_rel_ids> vml_drawing_rel_ids;

  external ffi.Pointer<lxw_comment_objs> comment_objs;

  external ffi.Pointer<lxw_comment_objs> header_image_objs;

  external ffi.Pointer<lxw_comment_objs> button_objs;

  external ffi.Pointer<lxw_table_objs> table_objs;

  @ffi.Uint16()
  external int table_count;

  @lxw_row_t()
  external int dim_rowmin;

  @lxw_row_t()
  external int dim_rowmax;

  @lxw_col_t()
  external int dim_colmin;

  @lxw_col_t()
  external int dim_colmax;

  external ffi.Pointer<lxw_sst> sst;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> quoted_name;

  external ffi.Pointer<ffi.Char> tmpdir;

  @ffi.Uint16()
  external int index;

  @ffi.Uint8()
  external int active;

  @ffi.Uint8()
  external int selected;

  @ffi.Uint8()
  external int hidden;

  external ffi.Pointer<ffi.Uint16> active_sheet;

  external ffi.Pointer<ffi.Uint16> first_sheet;

  @ffi.Uint8()
  external int is_chartsheet;

  external ffi.Pointer<ffi.Pointer<lxw_col_options>> col_options;

  @ffi.Uint16()
  external int col_options_max;

  external ffi.Pointer<ffi.Double> col_sizes;

  @ffi.Uint16()
  external int col_sizes_max;

  external ffi.Pointer<ffi.Pointer<lxw_format>> col_formats;

  @ffi.Uint16()
  external int col_formats_max;

  @ffi.Uint8()
  external int col_size_changed;

  @ffi.Uint8()
  external int row_size_changed;

  @ffi.Uint8()
  external int optimize;

  external ffi.Pointer<lxw_row> optimize_row;

  @ffi.Uint16()
  external int fit_height;

  @ffi.Uint16()
  external int fit_width;

  @ffi.Uint16()
  external int horizontal_dpi;

  @ffi.Uint16()
  external int hlink_count;

  @ffi.Uint16()
  external int page_start;

  @ffi.Uint16()
  external int print_scale;

  @ffi.Uint16()
  external int rel_count;

  @ffi.Uint16()
  external int vertical_dpi;

  @ffi.Uint16()
  external int zoom;

  @ffi.Uint8()
  external int filter_on;

  @ffi.Uint8()
  external int fit_page;

  @ffi.Uint8()
  external int hcenter;

  @ffi.Uint8()
  external int orientation;

  @ffi.Uint8()
  external int outline_changed;

  @ffi.Uint8()
  external int outline_on;

  @ffi.Uint8()
  external int outline_style;

  @ffi.Uint8()
  external int outline_below;

  @ffi.Uint8()
  external int outline_right;

  @ffi.Uint8()
  external int page_order;

  @ffi.Uint8()
  external int page_setup_changed;

  @ffi.Uint8()
  external int page_view;

  @ffi.Uint8()
  external int paper_size;

  @ffi.Uint8()
  external int print_gridlines;

  @ffi.Uint8()
  external int print_headers;

  @ffi.Uint8()
  external int print_options_changed;

  @ffi.Uint8()
  external int right_to_left;

  @ffi.Uint8()
  external int screen_gridlines;

  @ffi.Uint8()
  external int show_zeros;

  @ffi.Uint8()
  external int vcenter;

  @ffi.Uint8()
  external int zoom_scale_normal;

  @ffi.Uint8()
  external int black_white;

  @ffi.Uint8()
  external int num_validations;

  @ffi.Uint8()
  external int has_dynamic_arrays;

  external ffi.Pointer<ffi.Char> vba_codename;

  @ffi.Uint16()
  external int num_buttons;

  @lxw_color_t()
  external int tab_color;

  @ffi.Double()
  external double margin_left;

  @ffi.Double()
  external double margin_right;

  @ffi.Double()
  external double margin_top;

  @ffi.Double()
  external double margin_bottom;

  @ffi.Double()
  external double margin_header;

  @ffi.Double()
  external double margin_footer;

  @ffi.Double()
  external double default_row_height;

  @ffi.Uint32()
  external int default_row_pixels;

  @ffi.Uint32()
  external int default_col_pixels;

  @ffi.Uint8()
  external int default_row_zeroed;

  @ffi.Uint8()
  external int default_row_set;

  @ffi.Uint8()
  external int outline_row_level;

  @ffi.Uint8()
  external int outline_col_level;

  @ffi.Uint8()
  external int header_footer_changed;

  external ffi.Pointer<ffi.Char> header;

  external ffi.Pointer<ffi.Char> footer;

  external lxw_repeat_rows repeat_rows;

  external lxw_repeat_cols repeat_cols;

  external lxw_print_area print_area;

  external lxw_autofilter autofilter;

  @ffi.Uint16()
  external int merged_range_count;

  @ffi.Uint16()
  external int max_url_length;

  external ffi.Pointer<lxw_row_t> hbreaks;

  external ffi.Pointer<lxw_col_t> vbreaks;

  @ffi.Uint16()
  external int hbreaks_count;

  @ffi.Uint16()
  external int vbreaks_count;

  @ffi.Uint32()
  external int drawing_rel_id;

  @ffi.Uint32()
  external int vml_drawing_rel_id;

  external ffi.Pointer<lxw_rel_tuples> external_hyperlinks;

  external ffi.Pointer<lxw_rel_tuples> external_drawing_links;

  external ffi.Pointer<lxw_rel_tuples> drawing_links;

  external ffi.Pointer<lxw_rel_tuples> vml_drawing_links;

  external ffi.Pointer<lxw_rel_tuples> external_table_links;

  external lxw_panes panes;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> top_left_cell;

  external lxw_protection_obj protection;

  external ffi.Pointer<lxw_drawing> drawing;

  external ffi.Pointer<lxw_format> default_url_format;

  @ffi.Uint8()
  external int has_vml;

  @ffi.Uint8()
  external int has_comments;

  @ffi.Uint8()
  external int has_header_vml;

  @ffi.Uint8()
  external int has_background_image;

  @ffi.Uint8()
  external int has_buttons;

  external ffi.Pointer<lxw_rel_tuple> external_vml_comment_link;

  external ffi.Pointer<lxw_rel_tuple> external_comment_link;

  external ffi.Pointer<lxw_rel_tuple> external_vml_header_link;

  external ffi.Pointer<lxw_rel_tuple> external_background_link;

  external ffi.Pointer<ffi.Char> comment_author;

  external ffi.Pointer<ffi.Char> vml_data_id_str;

  external ffi.Pointer<ffi.Char> vml_header_id_str;

  @ffi.Uint32()
  external int vml_shape_id;

  @ffi.Uint32()
  external int vml_header_id;

  @ffi.Uint32()
  external int dxf_priority;

  @ffi.Uint8()
  external int comment_display_default;

  @ffi.Uint32()
  external int data_bar_2010_index;

  @ffi.Uint8()
  external int has_ignore_errors;

  external ffi.Pointer<ffi.Char> ignore_number_stored_as_text;

  external ffi.Pointer<ffi.Char> ignore_eval_error;

  external ffi.Pointer<ffi.Char> ignore_formula_differs;

  external ffi.Pointer<ffi.Char> ignore_formula_range;

  external ffi.Pointer<ffi.Char> ignore_formula_unlocked;

  external ffi.Pointer<ffi.Char> ignore_empty_cell_reference;

  external ffi.Pointer<ffi.Char> ignore_list_data_validation;

  external ffi.Pointer<ffi.Char> ignore_calculated_column;

  external ffi.Pointer<ffi.Char> ignore_two_digit_text_year;

  @ffi.Uint16()
  external int excel_version;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Pointer<ffi.Pointer<lxw_object_properties>>>
      header_footer_objs;

  external ffi.Pointer<lxw_object_properties> header_left_object_props;

  external ffi.Pointer<lxw_object_properties> header_center_object_props;

  external ffi.Pointer<lxw_object_properties> header_right_object_props;

  external ffi.Pointer<lxw_object_properties> footer_left_object_props;

  external ffi.Pointer<lxw_object_properties> footer_center_object_props;

  external ffi.Pointer<lxw_object_properties> footer_right_object_props;

  external ffi.Pointer<lxw_object_properties> background_image;

  external ffi.Pointer<ffi.Pointer<lxw_filter_rule_obj>> filter_rules;

  @lxw_col_t()
  external int num_filter_rules;

  external UnnamedStruct26 list_pointers;
}

class UnnamedStruct26 extends ffi.Struct {
  external ffi.Pointer<lxw_worksheet> stqe_next;
}

/// Worksheet initialization data.
class lxw_worksheet_init_data extends ffi.Struct {
  @ffi.Uint16()
  external int index;

  @ffi.Uint8()
  external int hidden;

  @ffi.Uint8()
  external int optimize;

  external ffi.Pointer<ffi.Uint16> active_sheet;

  external ffi.Pointer<ffi.Uint16> first_sheet;

  external ffi.Pointer<lxw_sst> sst;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> quoted_name;

  external ffi.Pointer<ffi.Char> tmpdir;

  external ffi.Pointer<lxw_format> default_url_format;

  @ffi.Uint16()
  external int max_url_length;
}

/// @brief Struct to represent an Excel chartsheet.
///
/// The members of the lxw_chartsheet struct aren't modified directly. Instead
/// the chartsheet properties are set by calling the functions shown in
/// chartsheet.h.
class lxw_chartsheet extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  external ffi.Pointer<lxw_worksheet> worksheet;

  external ffi.Pointer<lxw_chart> chart;

  external lxw_protection_obj protection;

  @ffi.Uint8()
  external int is_protected;

  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> quoted_name;

  external ffi.Pointer<ffi.Char> tmpdir;

  @ffi.Uint16()
  external int index;

  @ffi.Uint8()
  external int active;

  @ffi.Uint8()
  external int selected;

  @ffi.Uint8()
  external int hidden;

  external ffi.Pointer<ffi.Uint16> active_sheet;

  external ffi.Pointer<ffi.Uint16> first_sheet;

  @ffi.Uint16()
  external int rel_count;

  external UnnamedStruct27 list_pointers;
}

class UnnamedStruct27 extends ffi.Struct {
  external ffi.Pointer<lxw_chartsheet> stqe_next;
}

/// Define the tree.h RB structs for the red-black head types.
class lxw_worksheet_names extends ffi.Struct {
  external ffi.Pointer<lxw_worksheet_name> rbh_root;
}

/// Struct to represent a worksheet name/pointer pair.
class lxw_worksheet_name extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<lxw_worksheet> worksheet;

  external UnnamedStruct28 tree_pointers;
}

class UnnamedStruct28 extends ffi.Struct {
  external ffi.Pointer<lxw_worksheet_name> rbe_left;

  external ffi.Pointer<lxw_worksheet_name> rbe_right;

  external ffi.Pointer<lxw_worksheet_name> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

class lxw_chartsheet_names extends ffi.Struct {
  external ffi.Pointer<lxw_chartsheet_name> rbh_root;
}

/// Struct to represent a chartsheet name/pointer pair.
class lxw_chartsheet_name extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<lxw_chartsheet> chartsheet;

  external UnnamedStruct29 tree_pointers;
}

class UnnamedStruct29 extends ffi.Struct {
  external ffi.Pointer<lxw_chartsheet_name> rbe_left;

  external ffi.Pointer<lxw_chartsheet_name> rbe_right;

  external ffi.Pointer<lxw_chartsheet_name> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

class lxw_image_md5s extends ffi.Struct {
  external ffi.Pointer<lxw_image_md5> rbh_root;
}

/// Struct to represent an image MD5/ID pair.
class lxw_image_md5 extends ffi.Struct {
  @ffi.Uint32()
  external int id;

  external ffi.Pointer<ffi.Char> md5;

  external UnnamedStruct30 tree_pointers;
}

class UnnamedStruct30 extends ffi.Struct {
  external ffi.Pointer<lxw_image_md5> rbe_left;

  external ffi.Pointer<lxw_image_md5> rbe_right;

  external ffi.Pointer<lxw_image_md5> rbe_parent;

  @ffi.Int()
  external int rbe_color;
}

/// Define the queue.h structs for the workbook lists.
class lxw_sheets extends ffi.Struct {
  external ffi.Pointer<lxw_sheet> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_sheet>> stqh_last;
}

/// Struct to hold the 2 sheet types.
class lxw_sheet extends ffi.Struct {
  @ffi.Uint8()
  external int is_chartsheet;

  external UnnamedUnion3 u;

  external UnnamedStruct31 list_pointers;
}

class UnnamedUnion3 extends ffi.Union {
  external ffi.Pointer<lxw_worksheet> worksheet;

  external ffi.Pointer<lxw_chartsheet> chartsheet;
}

class UnnamedStruct31 extends ffi.Struct {
  external ffi.Pointer<lxw_sheet> stqe_next;
}

class lxw_worksheets extends ffi.Struct {
  external ffi.Pointer<lxw_worksheet> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_worksheet>> stqh_last;
}

class lxw_chartsheets extends ffi.Struct {
  external ffi.Pointer<lxw_chartsheet> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_chartsheet>> stqh_last;
}

class lxw_charts extends ffi.Struct {
  external ffi.Pointer<lxw_chart> stqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_chart>> stqh_last;
}

class lxw_defined_names extends ffi.Struct {
  external ffi.Pointer<lxw_defined_name> tqh_first;

  external ffi.Pointer<ffi.Pointer<lxw_defined_name>> tqh_last;
}

/// Struct to represent a defined name.
class lxw_defined_name extends ffi.Struct {
  @ffi.Int16()
  external int index;

  @ffi.Uint8()
  external int hidden;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> name;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> app_name;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> formula;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> normalised_name;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> normalised_sheetname;

  /// List pointers for queue.h.
  external UnnamedStruct32 list_pointers;
}

class UnnamedStruct32 extends ffi.Struct {
  external ffi.Pointer<lxw_defined_name> tqe_next;

  external ffi.Pointer<ffi.Pointer<lxw_defined_name>> tqe_prev;
}

/// Workbook document properties. Set any unused fields to NULL or 0.
class lxw_doc_properties extends ffi.Struct {
  /// The title of the Excel Document.
  external ffi.Pointer<ffi.Char> title;

  /// The subject of the Excel Document.
  external ffi.Pointer<ffi.Char> subject;

  /// The author of the Excel Document.
  external ffi.Pointer<ffi.Char> author;

  /// The manager field of the Excel Document.
  external ffi.Pointer<ffi.Char> manager;

  /// The company field of the Excel Document.
  external ffi.Pointer<ffi.Char> company;

  /// The category of the Excel Document.
  external ffi.Pointer<ffi.Char> category;

  /// The keywords of the Excel Document.
  external ffi.Pointer<ffi.Char> keywords;

  /// The comment field of the Excel Document.
  external ffi.Pointer<ffi.Char> comments;

  /// The status of the Excel Document.
  external ffi.Pointer<ffi.Char> status;

  /// The hyperlink base URL of the Excel Document.
  external ffi.Pointer<ffi.Char> hyperlink_base;

  /// The file creation date/time shown in Excel. This defaults to the
  /// current time and date if set to 0. If you wish to create files that are
  /// binary equivalent (for the same input data) then you should set this
  /// creation date/time to a known value.
  @time_t()
  external int created;
}

typedef time_t = __time_t;
typedef __time_t = ffi.Long;

/// @brief Workbook options.
///
/// Optional parameters when creating a new Workbook object via
/// workbook_new_opt().
///
/// The following properties are supported:
///
/// - `constant_memory`: This option reduces the amount of data stored in
/// memory so that large files can be written efficiently. This option is off
/// by default. See the notes below for limitations when this mode is on.
///
/// - `tmpdir`: libxlsxwriter stores workbook data in temporary files prior to
/// assembling the final XLSX file. The temporary files are created in the
/// system's temp directory. If the default temporary directory isn't
/// accessible to your application, or doesn't contain enough space, you can
/// specify an alternative location using the `tmpdir` option.
///
/// - `use_zip64`: Make the zip library use ZIP64 extensions when writing very
/// large xlsx files to allow the zip container, or individual XML files
/// within it, to be greater than 4 GB. See [ZIP64 on Wikipedia][zip64_wiki]
/// for more information. This option is off by default.
///
/// [zip64_wiki]: https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64
///
/// - `output_buffer`: Output to a buffer instead of a file. The buffer must be
/// freed manually by calling free(). This option can only be used if filename
/// is NULL.
///
/// - `output_buffer_size`: Used with output_buffer to get the size of the
/// created buffer. This option can only be used if filename is NULL.
///
/// @note In `constant_memory` mode each row of in-memory data is written to
/// disk and then freed when a new row is started via one of the
/// `worksheet_write_*()` functions. Therefore, once this option is active data
/// should be written in sequential row by row order. For this reason
/// `worksheet_merge_range()` and some other row based functionality doesn't
/// work in this mode. See @ref ww_mem_constant for more details.
///
/// @note Also, in `constant_memory` mode the library uses temp file storage
/// for worksheet data. This can lead to an issue on OSes that map the `/tmp`
/// directory into memory since it is possible to consume the "system" memory
/// even though the "process" memory remains constant. In these cases you
/// should use an alternative temp file location by using the `tmpdir` option
/// shown above. See @ref ww_mem_temp for more details.
class lxw_workbook_options extends ffi.Struct {
  /// Optimize the workbook to use constant memory for worksheets.
  @ffi.Uint8()
  external int constant_memory;

  /// Directory to use for the temporary files created by libxlsxwriter.
  external ffi.Pointer<ffi.Char> tmpdir;

  /// Allow ZIP64 extensions when creating the xlsx file zip container.
  @ffi.Uint8()
  external int use_zip64;

  /// Output buffer to use instead of writing to a file
  external ffi.Pointer<ffi.Pointer<ffi.Char>> output_buffer;

  /// Used with output_buffer to get the size of the created buffer
  external ffi.Pointer<ffi.Size> output_buffer_size;
}

/// @brief Struct to represent an Excel workbook.
///
/// The members of the lxw_workbook struct aren't modified directly. Instead
/// the workbook properties are set by calling the functions shown in
/// workbook.h.
class lxw_workbook extends ffi.Struct {
  external ffi.Pointer<FILE> file;

  external ffi.Pointer<lxw_sheets> sheets;

  external ffi.Pointer<lxw_worksheets> worksheets;

  external ffi.Pointer<lxw_chartsheets> chartsheets;

  external ffi.Pointer<lxw_worksheet_names> worksheet_names;

  external ffi.Pointer<lxw_chartsheet_names> chartsheet_names;

  external ffi.Pointer<lxw_image_md5s> image_md5s;

  external ffi.Pointer<lxw_image_md5s> header_image_md5s;

  external ffi.Pointer<lxw_image_md5s> background_md5s;

  external ffi.Pointer<lxw_charts> charts;

  external ffi.Pointer<lxw_charts> ordered_charts;

  external ffi.Pointer<lxw_formats> formats;

  external ffi.Pointer<lxw_defined_names> defined_names;

  external ffi.Pointer<lxw_sst> sst;

  external ffi.Pointer<lxw_doc_properties> properties;

  external ffi.Pointer<lxw_custom_properties> custom_properties;

  external ffi.Pointer<ffi.Char> filename;

  external lxw_workbook_options options;

  @ffi.Uint16()
  external int num_sheets;

  @ffi.Uint16()
  external int num_worksheets;

  @ffi.Uint16()
  external int num_chartsheets;

  @ffi.Uint16()
  external int first_sheet;

  @ffi.Uint16()
  external int active_sheet;

  @ffi.Uint16()
  external int num_xf_formats;

  @ffi.Uint16()
  external int num_dxf_formats;

  @ffi.Uint16()
  external int num_format_count;

  @ffi.Uint16()
  external int drawing_count;

  @ffi.Uint16()
  external int comment_count;

  @ffi.Uint16()
  external int font_count;

  @ffi.Uint16()
  external int border_count;

  @ffi.Uint16()
  external int fill_count;

  @ffi.Uint8()
  external int optimize;

  @ffi.Uint16()
  external int max_url_length;

  @ffi.Uint8()
  external int read_only;

  @ffi.Uint8()
  external int has_png;

  @ffi.Uint8()
  external int has_jpeg;

  @ffi.Uint8()
  external int has_bmp;

  @ffi.Uint8()
  external int has_gif;

  @ffi.Uint8()
  external int has_vml;

  @ffi.Uint8()
  external int has_comments;

  @ffi.Uint8()
  external int has_metadata;

  external ffi.Pointer<lxw_hash_table> used_xf_formats;

  external ffi.Pointer<lxw_hash_table> used_dxf_formats;

  external ffi.Pointer<ffi.Char> vba_project;

  external ffi.Pointer<ffi.Char> vba_codename;

  external ffi.Pointer<lxw_format> default_url_format;
}

const int SPLAY_NEGINF = -1;

const int SPLAY_INF = 1;

const int RB_BLACK = 0;

const int RB_RED = 1;

const int RB_NEGINF = -1;

const int RB_INF = 1;

const int LXW_MD5_SIZE = 16;

const int LXW_SHEETNAME_MAX = 31;

const int LXW_MAX_SHEETNAME_LENGTH = 127;

const int LXW_MAX_COL_NAME_LENGTH = 5;

const int LXW_MAX_ROW_NAME_LENGTH = 9;

const int LXW_MAX_CELL_NAME_LENGTH = 14;

const int LXW_MAX_CELL_RANGE_LENGTH = 28;

const int LXW_MAX_FORMULA_RANGE_LENGTH = 155;

const int LXW_DATETIME_LENGTH = 21;

const int LXW_GUID_LENGTH = 40;

const int LXW_EPOCH_1900 = 0;

const int LXW_EPOCH_1904 = 1;

const int LXW_UINT32_T_LENGTH = 11;

const int LXW_FILENAME_LENGTH = 128;

const int LXW_IGNORE = 1;

const int LXW_PORTRAIT = 1;

const int LXW_LANDSCAPE = 0;

const String LXW_SCHEMA_MS =
    'http://schemas.microsoft.com/office/2006/relationships';

const String LXW_SCHEMA_ROOT = 'http://schemas.openxmlformats.org';

const String LXW_SCHEMA_DRAWING =
    'http://schemas.openxmlformats.org/drawingml/2006';

const String LXW_SCHEMA_OFFICEDOC =
    'http://schemas.openxmlformats.org/officeDocument/2006';

const String LXW_SCHEMA_PACKAGE =
    'http://schemas.openxmlformats.org/package/2006/relationships';

const String LXW_SCHEMA_DOCUMENT =
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships';

const String LXW_SCHEMA_CONTENT =
    'http://schemas.openxmlformats.org/package/2006/content-types';

const int LXW_FORMAT_FIELD_LEN = 128;

const String LXW_DEFAULT_FONT_NAME = 'Calibri';

const int LXW_DEFAULT_FONT_FAMILY = 2;

const int LXW_DEFAULT_FONT_THEME = 1;

const int LXW_PROPERTY_UNSET = -1;

const int LXW_COLOR_UNSET = 0;

const int LXW_COLOR_MASK = 16777215;

const double LXW_MIN_FONT_SIZE = 1.0;

const double LXW_MAX_FONT_SIZE = 409.0;

const int LXW_CHART_NUM_FORMAT_LEN = 128;

const int LXW_CHART_DEFAULT_GAP = 501;

const int LXW_MAX_ATTRIBUTE_LENGTH = 2080;

const int LXW_ATTR_32 = 32;

const int LXW_ROW_MAX = 1048576;

const int LXW_COL_MAX = 16384;

const int LXW_COL_META_MAX = 128;

const int LXW_HEADER_FOOTER_MAX = 255;

const int LXW_MAX_NUMBER_URLS = 65530;

const int LXW_PANE_NAME_LENGTH = 12;

const int LXW_IMAGE_BUFFER_SIZE = 1024;

const int LXW_HEADER_FOOTER_OBJS_MAX = 6;

const int LXW_BREAKS_MAX = 1023;

const double LXW_DEF_COL_WIDTH = 8.43;

const double LXW_DEF_ROW_HEIGHT = 15.0;

const int LXW_DEF_COL_WIDTH_PIXELS = 64;

const int LXW_DEF_ROW_HEIGHT_PIXELS = 20;

const int LXW_DEFINED_NAME_LENGTH = 128;

const String LXW_VERSION = '1.1.5';

const int LXW_VERSION_ID = 115;

const String LXW_SOVERSION = '5';
